{"visual":{"name":"testcell1","displayName":"testcell1","guid":"testcell1F3809C28F3FF40148F8285F9834834B5_DEBUG","visualClassName":"Visual","version":"1.0.0","description":"","supportUrl":"","gitHubUrl":""},"apiVersion":"1.11.0","author":{"name":"","email":""},"assets":{"icon":"assets/icon.png"},"externalJS":["node_modules/powerbi-visuals-utils-dataviewutils/lib/index.js","node_modules/globalize/lib/globalize.js","node_modules/globalize/lib/cultures/globalize.culture.en-US.js","node_modules/powerbi-visuals-utils-typeutils/lib/index.js","node_modules/powerbi-visuals-utils-dataviewutils/lib/index.js","node_modules/powerbi-visuals-utils-formattingutils/lib/index.js"],"style":"style/visual.less","capabilities":{"dataRoles":[{"displayName":"Field","name":"category","kind":"GroupingOrMeasure"}],"objects":{"dataPoint":{"displayName":"Formatting","properties":{"defaultColor":{"displayName":"Default color","type":{"fill":{"solid":{"color":true}}}},"fontSize":{"displayName":"Text Size","type":{"formatting":{"fontSize":true}}},"alignment":{"displayName":"Alignment","type":{"formatting":{"alignment":true}}},"formatString":{"displayName":"Format (#,#)","type":{"text":true}},"formatCulture":{"displayName":"Culture (en-US)","type":{"text":true}},"htmlTemplate":{"displayName":"HTML Template","type":{"text":true}},"forceThousandSeparatorCharacter":{"displayName":"Thousand separator character (force)","type":{"text":true}}}}},"dataViewMappings":[{"categorical":{"categories":{"for":{"in":"category"},"dataReductionAlgorithm":{"top":{}}},"values":{"select":[{"bind":{"to":"category"}}]}}}]},"stringResources":{},"content":{"js":"/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var dataview;\r\n            (function (dataview) {\r\n                // TODO: refactor & focus DataViewTransform into a service with well-defined dependencies.\r\n                var DataViewTransform;\r\n                (function (DataViewTransform) {\r\n                    // TODO: refactor this, setGrouped, and groupValues to a test helper to stop using it in the product\r\n                    function createValueColumns(values, valueIdentityFields, source) {\r\n                        if (values === void 0) { values = []; }\r\n                        var result = values;\r\n                        setGrouped(result);\r\n                        if (valueIdentityFields) {\r\n                            result.identityFields = valueIdentityFields;\r\n                        }\r\n                        if (source) {\r\n                            result.source = source;\r\n                        }\r\n                        return result;\r\n                    }\r\n                    DataViewTransform.createValueColumns = createValueColumns;\r\n                    function setGrouped(values, groupedResult) {\r\n                        values.grouped = groupedResult\r\n                            ? function () { return groupedResult; }\r\n                            : function () { return groupValues(values); };\r\n                    }\r\n                    DataViewTransform.setGrouped = setGrouped;\r\n                    /** Group together the values with a common identity. */\r\n                    function groupValues(values) {\r\n                        var groups = [], currentGroup;\r\n                        for (var i = 0, len = values.length; i < len; i++) {\r\n                            var value = values[i];\r\n                            if (!currentGroup || currentGroup.identity !== value.identity) {\r\n                                currentGroup = {\r\n                                    values: []\r\n                                };\r\n                                if (value.identity) {\r\n                                    currentGroup.identity = value.identity;\r\n                                    var source = value.source;\r\n                                    // allow null, which will be formatted as (Blank).\r\n                                    if (source.groupName !== undefined) {\r\n                                        currentGroup.name = source.groupName;\r\n                                    }\r\n                                    else if (source.displayName) {\r\n                                        currentGroup.name = source.displayName;\r\n                                    }\r\n                                }\r\n                                groups.push(currentGroup);\r\n                            }\r\n                            currentGroup.values.push(value);\r\n                        }\r\n                        return groups;\r\n                    }\r\n                    DataViewTransform.groupValues = groupValues;\r\n                })(DataViewTransform = dataview.DataViewTransform || (dataview.DataViewTransform = {}));\r\n            })(dataview = utils.dataview || (utils.dataview = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var dataview;\r\n            (function (dataview) {\r\n                var DataRoleHelper;\r\n                (function (DataRoleHelper) {\r\n                    function getMeasureIndexOfRole(grouped, roleName) {\r\n                        if (!grouped || !grouped.length) {\r\n                            return -1;\r\n                        }\r\n                        var firstGroup = grouped[0];\r\n                        if (firstGroup.values && firstGroup.values.length > 0) {\r\n                            for (var i = 0, len = firstGroup.values.length; i < len; ++i) {\r\n                                var value = firstGroup.values[i];\r\n                                if (value && value.source) {\r\n                                    if (hasRole(value.source, roleName)) {\r\n                                        return i;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        return -1;\r\n                    }\r\n                    DataRoleHelper.getMeasureIndexOfRole = getMeasureIndexOfRole;\r\n                    function getCategoryIndexOfRole(categories, roleName) {\r\n                        if (categories && categories.length) {\r\n                            for (var i = 0, ilen = categories.length; i < ilen; i++) {\r\n                                if (hasRole(categories[i].source, roleName)) {\r\n                                    return i;\r\n                                }\r\n                            }\r\n                        }\r\n                        return -1;\r\n                    }\r\n                    DataRoleHelper.getCategoryIndexOfRole = getCategoryIndexOfRole;\r\n                    function hasRole(column, name) {\r\n                        var roles = column.roles;\r\n                        return roles && roles[name];\r\n                    }\r\n                    DataRoleHelper.hasRole = hasRole;\r\n                    function hasRoleInDataView(dataView, name) {\r\n                        return dataView != null\r\n                            && dataView.metadata != null\r\n                            && dataView.metadata.columns\r\n                            && dataView.metadata.columns.some(function (c) { return c.roles && c.roles[name] !== undefined; }); // any is an alias of some\r\n                    }\r\n                    DataRoleHelper.hasRoleInDataView = hasRoleInDataView;\r\n                    function hasRoleInValueColumn(valueColumn, name) {\r\n                        return valueColumn\r\n                            && valueColumn.source\r\n                            && valueColumn.source.roles\r\n                            && (valueColumn.source.roles[name] === true);\r\n                    }\r\n                    DataRoleHelper.hasRoleInValueColumn = hasRoleInValueColumn;\r\n                })(DataRoleHelper = dataview.DataRoleHelper || (dataview.DataRoleHelper = {}));\r\n            })(dataview = utils.dataview || (utils.dataview = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var dataview;\r\n            (function (dataview) {\r\n                var DataViewObject;\r\n                (function (DataViewObject) {\r\n                    function getValue(object, propertyName, defaultValue) {\r\n                        if (!object) {\r\n                            return defaultValue;\r\n                        }\r\n                        var propertyValue = object[propertyName];\r\n                        if (propertyValue === undefined) {\r\n                            return defaultValue;\r\n                        }\r\n                        return propertyValue;\r\n                    }\r\n                    DataViewObject.getValue = getValue;\r\n                    /** Gets the solid color from a fill property using only a propertyName */\r\n                    function getFillColorByPropertyName(object, propertyName, defaultColor) {\r\n                        var value = getValue(object, propertyName);\r\n                        if (!value || !value.solid) {\r\n                            return defaultColor;\r\n                        }\r\n                        return value.solid.color;\r\n                    }\r\n                    DataViewObject.getFillColorByPropertyName = getFillColorByPropertyName;\r\n                })(DataViewObject = dataview.DataViewObject || (dataview.DataViewObject = {}));\r\n            })(dataview = utils.dataview || (utils.dataview = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var dataview;\r\n            (function (dataview) {\r\n                var DataViewObjects;\r\n                (function (DataViewObjects) {\r\n                    /** Gets the value of the given object/property pair. */\r\n                    function getValue(objects, propertyId, defaultValue) {\r\n                        if (!objects) {\r\n                            return defaultValue;\r\n                        }\r\n                        return dataview.DataViewObject.getValue(objects[propertyId.objectName], propertyId.propertyName, defaultValue);\r\n                    }\r\n                    DataViewObjects.getValue = getValue;\r\n                    /** Gets an object from objects. */\r\n                    function getObject(objects, objectName, defaultValue) {\r\n                        if (objects && objects[objectName]) {\r\n                            return objects[objectName];\r\n                        }\r\n                        return defaultValue;\r\n                    }\r\n                    DataViewObjects.getObject = getObject;\r\n                    /** Gets the solid color from a fill property. */\r\n                    function getFillColor(objects, propertyId, defaultColor) {\r\n                        var value = getValue(objects, propertyId);\r\n                        if (!value || !value.solid) {\r\n                            return defaultColor;\r\n                        }\r\n                        return value.solid.color;\r\n                    }\r\n                    DataViewObjects.getFillColor = getFillColor;\r\n                    function getCommonValue(objects, propertyId, defaultValue) {\r\n                        var value = getValue(objects, propertyId, defaultValue);\r\n                        if (value && value.solid) {\r\n                            return value.solid.color;\r\n                        }\r\n                        if (value === undefined\r\n                            || value === null\r\n                            || (typeof value === \"object\" && !value.solid)) {\r\n                            return defaultValue;\r\n                        }\r\n                        return value;\r\n                    }\r\n                    DataViewObjects.getCommonValue = getCommonValue;\r\n                })(DataViewObjects = dataview.DataViewObjects || (dataview.DataViewObjects = {}));\r\n            })(dataview = utils.dataview || (utils.dataview = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var dataview;\r\n            (function (dataview) {\r\n                // powerbi.extensibility.utils.dataview\r\n                var DataRoleHelper = powerbi.extensibility.utils.dataview.DataRoleHelper;\r\n                var converterHelper;\r\n                (function (converterHelper) {\r\n                    function categoryIsAlsoSeriesRole(dataView, seriesRoleName, categoryRoleName) {\r\n                        if (dataView.categories && dataView.categories.length > 0) {\r\n                            // Need to pivot data if our category soure is a series role\r\n                            var category = dataView.categories[0];\r\n                            return category.source &&\r\n                                DataRoleHelper.hasRole(category.source, seriesRoleName) &&\r\n                                DataRoleHelper.hasRole(category.source, categoryRoleName);\r\n                        }\r\n                        return false;\r\n                    }\r\n                    converterHelper.categoryIsAlsoSeriesRole = categoryIsAlsoSeriesRole;\r\n                    function getSeriesName(source) {\r\n                        return (source.groupName !== undefined)\r\n                            ? source.groupName\r\n                            : source.queryName;\r\n                    }\r\n                    converterHelper.getSeriesName = getSeriesName;\r\n                    function isImageUrlColumn(column) {\r\n                        var misc = getMiscellaneousTypeDescriptor(column);\r\n                        return misc != null && misc.imageUrl === true;\r\n                    }\r\n                    converterHelper.isImageUrlColumn = isImageUrlColumn;\r\n                    function isWebUrlColumn(column) {\r\n                        var misc = getMiscellaneousTypeDescriptor(column);\r\n                        return misc != null && misc.webUrl === true;\r\n                    }\r\n                    converterHelper.isWebUrlColumn = isWebUrlColumn;\r\n                    function getMiscellaneousTypeDescriptor(column) {\r\n                        return column\r\n                            && column.type\r\n                            && column.type.misc;\r\n                    }\r\n                    converterHelper.getMiscellaneousTypeDescriptor = getMiscellaneousTypeDescriptor;\r\n                    function hasImageUrlColumn(dataView) {\r\n                        if (!dataView || !dataView.metadata || !dataView.metadata.columns || !dataView.metadata.columns.length) {\r\n                            return false;\r\n                        }\r\n                        return dataView.metadata.columns.some(function (column) { return isImageUrlColumn(column) === true; });\r\n                    }\r\n                    converterHelper.hasImageUrlColumn = hasImageUrlColumn;\r\n                })(converterHelper = dataview.converterHelper || (dataview.converterHelper = {}));\r\n            })(dataview = utils.dataview || (utils.dataview = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var dataview;\r\n            (function (dataview) {\r\n                var DataViewObjectsParser = (function () {\r\n                    function DataViewObjectsParser() {\r\n                    }\r\n                    DataViewObjectsParser.getDefault = function () {\r\n                        return new this();\r\n                    };\r\n                    DataViewObjectsParser.createPropertyIdentifier = function (objectName, propertyName) {\r\n                        return {\r\n                            objectName: objectName,\r\n                            propertyName: propertyName\r\n                        };\r\n                    };\r\n                    DataViewObjectsParser.parse = function (dataView) {\r\n                        var dataViewObjectParser = this.getDefault(), properties;\r\n                        if (!dataView || !dataView.metadata || !dataView.metadata.objects) {\r\n                            return dataViewObjectParser;\r\n                        }\r\n                        properties = dataViewObjectParser.getProperties();\r\n                        for (var objectName in properties) {\r\n                            for (var propertyName in properties[objectName]) {\r\n                                var defaultValue = dataViewObjectParser[objectName][propertyName];\r\n                                dataViewObjectParser[objectName][propertyName] = dataview.DataViewObjects.getCommonValue(dataView.metadata.objects, properties[objectName][propertyName], defaultValue);\r\n                            }\r\n                        }\r\n                        return dataViewObjectParser;\r\n                    };\r\n                    DataViewObjectsParser.isPropertyEnumerable = function (propertyName) {\r\n                        return !DataViewObjectsParser.InnumerablePropertyPrefix.test(propertyName);\r\n                    };\r\n                    DataViewObjectsParser.enumerateObjectInstances = function (dataViewObjectParser, options) {\r\n                        var dataViewProperties = dataViewObjectParser && dataViewObjectParser[options.objectName];\r\n                        if (!dataViewProperties) {\r\n                            return [];\r\n                        }\r\n                        var instance = {\r\n                            objectName: options.objectName,\r\n                            selector: null,\r\n                            properties: {}\r\n                        };\r\n                        for (var key in dataViewProperties) {\r\n                            if (dataViewProperties.hasOwnProperty(key)) {\r\n                                instance.properties[key] = dataViewProperties[key];\r\n                            }\r\n                        }\r\n                        return {\r\n                            instances: [instance]\r\n                        };\r\n                    };\r\n                    DataViewObjectsParser.prototype.getProperties = function () {\r\n                        var _this = this;\r\n                        var properties = {}, objectNames = Object.keys(this);\r\n                        objectNames.forEach(function (objectName) {\r\n                            if (DataViewObjectsParser.isPropertyEnumerable(objectName)) {\r\n                                var propertyNames = Object.keys(_this[objectName]);\r\n                                properties[objectName] = {};\r\n                                propertyNames.forEach(function (propertyName) {\r\n                                    if (DataViewObjectsParser.isPropertyEnumerable(objectName)) {\r\n                                        properties[objectName][propertyName] =\r\n                                            DataViewObjectsParser.createPropertyIdentifier(objectName, propertyName);\r\n                                    }\r\n                                });\r\n                            }\r\n                        });\r\n                        return properties;\r\n                    };\r\n                    return DataViewObjectsParser;\r\n                }());\r\n                DataViewObjectsParser.InnumerablePropertyPrefix = /^_/;\r\n                dataview.DataViewObjectsParser = DataViewObjectsParser;\r\n            })(dataview = utils.dataview || (utils.dataview = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n\n/*!\n * Globalize\n *\n * http://github.com/jquery/globalize\n *\n * Copyright Software Freedom Conservancy, Inc.\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n */\n\n(function( window, undefined ) {\n\nvar Globalize,\n\t// private variables\n\tregexHex,\n\tregexInfinity,\n\tregexParseFloat,\n\tregexTrim,\n\t// private JavaScript utility functions\n\tarrayIndexOf,\n\tendsWith,\n\textend,\n\tisArray,\n\tisFunction,\n\tisObject,\n\tstartsWith,\n\ttrim,\n\tzeroPad,\n\t// private Globalization utility functions\n\tappendPreOrPostMatch,\n\texpandFormat,\n\tformatDate,\n\tformatNumber,\n\tgetTokenRegExp,\n\tgetEra,\n\tgetEraYear,\n\tparseExact,\n\tparseNegativePattern;\n\n// Global variable (Globalize) or CommonJS module (globalize)\nGlobalize = function( cultureSelector ) {\n\treturn new Globalize.prototype.init( cultureSelector );\n};\n\nif ( typeof require !== \"undefined\"\n\t&& typeof exports !== \"undefined\"\n\t&& typeof module !== \"undefined\" ) {\n\t// Assume CommonJS\n\tmodule.exports = Globalize;\n} else {\n\t// Export as global variable\n\twindow.Globalize = Globalize;\n}\n\nGlobalize.cultures = {};\n\nGlobalize.prototype = {\n\tconstructor: Globalize,\n\tinit: function( cultureSelector ) {\n\t\tthis.cultures = Globalize.cultures;\n\t\tthis.cultureSelector = cultureSelector;\n\n\t\treturn this;\n\t}\n};\nGlobalize.prototype.init.prototype = Globalize.prototype;\n\n// 1.\t When defining a culture, all fields are required except the ones stated as optional.\n// 2.\t Each culture should have a \".calendars\" object with at least one calendar named \"standard\"\n//\t\t which serves as the default calendar in use by that culture.\n// 3.\t Each culture should have a \".calendar\" object which is the current calendar being used,\n//\t\t it may be dynamically changed at any time to one of the calendars in \".calendars\".\nGlobalize.cultures[ \"default\" ] = {\n\t// A unique name for the culture in the form <language code>-<country/region code>\n\tname: \"en\",\n\t// the name of the culture in the english language\n\tenglishName: \"English\",\n\t// the name of the culture in its own language\n\tnativeName: \"English\",\n\t// whether the culture uses right-to-left text\n\tisRTL: false,\n\t// \"language\" is used for so-called \"specific\" cultures.\n\t// For example, the culture \"es-CL\" means \"Spanish, in Chili\".\n\t// It represents the Spanish-speaking culture as it is in Chili,\n\t// which might have different formatting rules or even translations\n\t// than Spanish in Spain. A \"neutral\" culture is one that is not\n\t// specific to a region. For example, the culture \"es\" is the generic\n\t// Spanish culture, which may be a more generalized version of the language\n\t// that may or may not be what a specific culture expects.\n\t// For a specific culture like \"es-CL\", the \"language\" field refers to the\n\t// neutral, generic culture information for the language it is using.\n\t// This is not always a simple matter of the string before the dash.\n\t// For example, the \"zh-Hans\" culture is netural (Simplified Chinese).\n\t// And the \"zh-SG\" culture is Simplified Chinese in Singapore, whose lanugage\n\t// field is \"zh-CHS\", not \"zh\".\n\t// This field should be used to navigate from a specific culture to it's\n\t// more general, neutral culture. If a culture is already as general as it\n\t// can get, the language may refer to itself.\n\tlanguage: \"en\",\n\t// numberFormat defines general number formatting rules, like the digits in\n\t// each grouping, the group separator, and how negative numbers are displayed.\n\tnumberFormat: {\n\t\t// [negativePattern]\n\t\t// Note, numberFormat.pattern has no \"positivePattern\" unlike percent and currency,\n\t\t// but is still defined as an array for consistency with them.\n\t\t//   negativePattern: one of \"(n)|-n|- n|n-|n -\"\n\t\tpattern: [ \"-n\" ],\n\t\t// number of decimal places normally shown\n\t\tdecimals: 2,\n\t\t// string that separates number groups, as in 1,000,000\n\t\t\",\": \",\",\n\t\t// string that separates a number from the fractional portion, as in 1.99\n\t\t\".\": \".\",\n\t\t// array of numbers indicating the size of each number group.\n\t\t// TODO: more detailed description and example\n\t\tgroupSizes: [ 3 ],\n\t\t// symbol used for positive numbers\n\t\t\"+\": \"+\",\n\t\t// symbol used for negative numbers\n\t\t\"-\": \"-\",\n\t\tpercent: {\n\t\t\t// [negativePattern, positivePattern]\n\t\t\t//   negativePattern: one of \"-n %|-n%|-%n|%-n|%n-|n-%|n%-|-% n|n %-|% n-|% -n|n- %\"\n\t\t\t//   positivePattern: one of \"n %|n%|%n|% n\"\n\t\t\tpattern: [ \"-n %\", \"n %\" ],\n\t\t\t// number of decimal places normally shown\n\t\t\tdecimals: 2,\n\t\t\t// array of numbers indicating the size of each number group.\n\t\t\t// TODO: more detailed description and example\n\t\t\tgroupSizes: [ 3 ],\n\t\t\t// string that separates number groups, as in 1,000,000\n\t\t\t\",\": \",\",\n\t\t\t// string that separates a number from the fractional portion, as in 1.99\n\t\t\t\".\": \".\",\n\t\t\t// symbol used to represent a percentage\n\t\t\tsymbol: \"%\"\n\t\t},\n\t\tcurrency: {\n\t\t\t// [negativePattern, positivePattern]\n\t\t\t//   negativePattern: one of \"($n)|-$n|$-n|$n-|(n$)|-n$|n-$|n$-|-n $|-$ n|n $-|$ n-|$ -n|n- $|($ n)|(n $)\"\n\t\t\t//   positivePattern: one of \"$n|n$|$ n|n $\"\n\t\t\tpattern: [ \"($n)\", \"$n\" ],\n\t\t\t// number of decimal places normally shown\n\t\t\tdecimals: 2,\n\t\t\t// array of numbers indicating the size of each number group.\n\t\t\t// TODO: more detailed description and example\n\t\t\tgroupSizes: [ 3 ],\n\t\t\t// string that separates number groups, as in 1,000,000\n\t\t\t\",\": \",\",\n\t\t\t// string that separates a number from the fractional portion, as in 1.99\n\t\t\t\".\": \".\",\n\t\t\t// symbol used to represent currency\n\t\t\tsymbol: \"$\"\n\t\t}\n\t},\n\t// calendars defines all the possible calendars used by this culture.\n\t// There should be at least one defined with name \"standard\", and is the default\n\t// calendar used by the culture.\n\t// A calendar contains information about how dates are formatted, information about\n\t// the calendar's eras, a standard set of the date formats,\n\t// translations for day and month names, and if the calendar is not based on the Gregorian\n\t// calendar, conversion functions to and from the Gregorian calendar.\n\tcalendars: {\n\t\tstandard: {\n\t\t\t// name that identifies the type of calendar this is\n\t\t\tname: \"Gregorian_USEnglish\",\n\t\t\t// separator of parts of a date (e.g. \"/\" in 11/05/1955)\n\t\t\t\"/\": \"/\",\n\t\t\t// separator of parts of a time (e.g. \":\" in 05:44 PM)\n\t\t\t\":\": \":\",\n\t\t\t// the first day of the week (0 = Sunday, 1 = Monday, etc)\n\t\t\tfirstDay: 0,\n\t\t\tdays: {\n\t\t\t\t// full day names\n\t\t\t\tnames: [ \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" ],\n\t\t\t\t// abbreviated day names\n\t\t\t\tnamesAbbr: [ \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\" ],\n\t\t\t\t// shortest day names\n\t\t\t\tnamesShort: [ \"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\" ]\n\t\t\t},\n\t\t\tmonths: {\n\t\t\t\t// full month names (13 months for lunar calendards -- 13th month should be \"\" if not lunar)\n\t\t\t\tnames: [ \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\", \"\" ],\n\t\t\t\t// abbreviated month names\n\t\t\t\tnamesAbbr: [ \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", \"\" ]\n\t\t\t},\n\t\t\t// AM and PM designators in one of these forms:\n\t\t\t// The usual view, and the upper and lower case versions\n\t\t\t//   [ standard, lowercase, uppercase ]\n\t\t\t// The culture does not use AM or PM (likely all standard date formats use 24 hour time)\n\t\t\t//   null\n\t\t\tAM: [ \"AM\", \"am\", \"AM\" ],\n\t\t\tPM: [ \"PM\", \"pm\", \"PM\" ],\n\t\t\teras: [\n\t\t\t\t// eras in reverse chronological order.\n\t\t\t\t// name: the name of the era in this culture (e.g. A.D., C.E.)\n\t\t\t\t// start: when the era starts in ticks (gregorian, gmt), null if it is the earliest supported era.\n\t\t\t\t// offset: offset in years from gregorian calendar\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"A.D.\",\n\t\t\t\t\t\"start\": null,\n\t\t\t\t\t\"offset\": 0\n\t\t\t\t}\n\t\t\t],\n\t\t\t// when a two digit year is given, it will never be parsed as a four digit\n\t\t\t// year greater than this year (in the appropriate era for the culture)\n\t\t\t// Set it as a full year (e.g. 2029) or use an offset format starting from\n\t\t\t// the current year: \"+19\" would correspond to 2029 if the current year 2010.\n\t\t\ttwoDigitYearMax: 2029,\n\t\t\t// set of predefined date and time patterns used by the culture\n\t\t\t// these represent the format someone in this culture would expect\n\t\t\t// to see given the portions of the date that are shown.\n\t\t\tpatterns: {\n\t\t\t\t// short date pattern\n\t\t\t\td: \"M/d/yyyy\",\n\t\t\t\t// long date pattern\n\t\t\t\tD: \"dddd, MMMM dd, yyyy\",\n\t\t\t\t// short time pattern\n\t\t\t\tt: \"h:mm tt\",\n\t\t\t\t// long time pattern\n\t\t\t\tT: \"h:mm:ss tt\",\n\t\t\t\t// long date, short time pattern\n\t\t\t\tf: \"dddd, MMMM dd, yyyy h:mm tt\",\n\t\t\t\t// long date, long time pattern\n\t\t\t\tF: \"dddd, MMMM dd, yyyy h:mm:ss tt\",\n\t\t\t\t// month/day pattern\n\t\t\t\tM: \"MMMM dd\",\n\t\t\t\t// month/year pattern\n\t\t\t\tY: \"yyyy MMMM\",\n\t\t\t\t// S is a sortable format that does not vary by culture\n\t\t\t\tS: \"yyyy\\u0027-\\u0027MM\\u0027-\\u0027dd\\u0027T\\u0027HH\\u0027:\\u0027mm\\u0027:\\u0027ss\"\n\t\t\t}\n\t\t\t// optional fields for each calendar:\n\t\t\t/*\n\t\t\tmonthsGenitive:\n\t\t\t\tSame as months but used when the day preceeds the month.\n\t\t\t\tOmit if the culture has no genitive distinction in month names.\n\t\t\t\tFor an explaination of genitive months, see http://blogs.msdn.com/michkap/archive/2004/12/25/332259.aspx\n\t\t\tconvert:\n\t\t\t\tAllows for the support of non-gregorian based calendars. This convert object is used to\n\t\t\t\tto convert a date to and from a gregorian calendar date to handle parsing and formatting.\n\t\t\t\tThe two functions:\n\t\t\t\t\tfromGregorian( date )\n\t\t\t\t\t\tGiven the date as a parameter, return an array with parts [ year, month, day ]\n\t\t\t\t\t\tcorresponding to the non-gregorian based year, month, and day for the calendar.\n\t\t\t\t\ttoGregorian( year, month, day )\n\t\t\t\t\t\tGiven the non-gregorian year, month, and day, return a new Date() object\n\t\t\t\t\t\tset to the corresponding date in the gregorian calendar.\n\t\t\t*/\n\t\t}\n\t},\n\t// For localized strings\n\tmessages: {}\n};\n\nGlobalize.cultures[ \"default\" ].calendar = Globalize.cultures[ \"default\" ].calendars.standard;\n\nGlobalize.cultures[ \"en\" ] = Globalize.cultures[ \"default\" ];\n\nGlobalize.cultureSelector = \"en\";\n\n//\n// private variables\n//\n\nregexHex = /^0x[a-f0-9]+$/i;\nregexInfinity = /^[+-]?infinity$/i;\nregexParseFloat = /^[+-]?\\d*\\.?\\d*(e[+-]?\\d+)?$/;\nregexTrim = /^\\s+|\\s+$/g;\n\n//\n// private JavaScript utility functions\n//\n\narrayIndexOf = function( array, item ) {\n\tif ( array.indexOf ) {\n\t\treturn array.indexOf( item );\n\t}\n\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\tif ( array[i] === item ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\nendsWith = function( value, pattern ) {\n\treturn value.substr( value.length - pattern.length ) === pattern;\n};\n\nextend = function( deep ) {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( isObject(copy) || (copyIsArray = isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && isObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\nisArray = Array.isArray || function( obj ) {\n\treturn Object.prototype.toString.call( obj ) === \"[object Array]\";\n};\n\nisFunction = function( obj ) {\n\treturn Object.prototype.toString.call( obj ) === \"[object Function]\"\n}\n\nisObject = function( obj ) {\n\treturn Object.prototype.toString.call( obj ) === \"[object Object]\";\n};\n\nstartsWith = function( value, pattern ) {\n\treturn value.indexOf( pattern ) === 0;\n};\n\ntrim = function( value ) {\n\treturn ( value + \"\" ).replace( regexTrim, \"\" );\n};\n\nzeroPad = function( str, count, left ) {\n\tvar l;\n\tfor ( l = str.length; l < count; l += 1 ) {\n\t\tstr = ( left ? (\"0\" + str) : (str + \"0\") );\n\t}\n\treturn str;\n};\n\n//\n// private Globalization utility functions\n//\n\nappendPreOrPostMatch = function( preMatch, strings ) {\n\t// appends pre- and post- token match strings while removing escaped characters.\n\t// Returns a single quote count which is used to determine if the token occurs\n\t// in a string literal.\n\tvar quoteCount = 0,\n\t\tescaped = false;\n\tfor ( var i = 0, il = preMatch.length; i < il; i++ ) {\n\t\tvar c = preMatch.charAt( i );\n\t\tswitch ( c ) {\n\t\t\tcase \"\\'\":\n\t\t\t\tif ( escaped ) {\n\t\t\t\t\tstrings.push( \"\\'\" );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tquoteCount++;\n\t\t\t\t}\n\t\t\t\tescaped = false;\n\t\t\t\tbreak;\n\t\t\tcase \"\\\\\":\n\t\t\t\tif ( escaped ) {\n\t\t\t\t\tstrings.push( \"\\\\\" );\n\t\t\t\t}\n\t\t\t\tescaped = !escaped;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstrings.push( c );\n\t\t\t\tescaped = false;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn quoteCount;\n};\n\nexpandFormat = function( cal, format ) {\n\t// expands unspecified or single character date formats into the full pattern.\n\tformat = format || \"F\";\n\tvar pattern,\n\t\tpatterns = cal.patterns,\n\t\tlen = format.length;\n\tif ( len === 1 ) {\n\t\tpattern = patterns[ format ];\n\t\tif ( !pattern ) {\n\t\t\tthrow \"Invalid date format string \\'\" + format + \"\\'.\";\n\t\t}\n\t\tformat = pattern;\n\t}\n\telse if ( len === 2 && format.charAt(0) === \"%\" ) {\n\t\t// %X escape format -- intended as a custom format string that is only one character, not a built-in format.\n\t\tformat = format.charAt( 1 );\n\t}\n\treturn format;\n};\n\nformatDate = function( value, format, culture ) {\n\tvar cal = culture.calendar,\n\t\tconvert = cal.convert;\n\n\tif ( !format || !format.length || format === \"i\" ) {\n\t\tvar ret;\n\t\tif ( culture && culture.name.length ) {\n\t\t\tif ( convert ) {\n\t\t\t\t// non-gregorian calendar, so we cannot use built-in toLocaleString()\n\t\t\t\tret = formatDate( value, cal.patterns.F, culture );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar eraDate = new Date( value.getTime() ),\n\t\t\t\t\tera = getEra( value, cal.eras );\n\t\t\t\teraDate.setFullYear( getEraYear(value, cal, era) );\n\t\t\t\tret = eraDate.toLocaleString();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tret = value.toString();\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvar eras = cal.eras,\n\t\tsortable = format === \"s\";\n\tformat = expandFormat( cal, format );\n\n\t// Start with an empty string\n\tret = [];\n\tvar hour,\n\t\tzeros = [ \"0\", \"00\", \"000\" ],\n\t\tfoundDay,\n\t\tcheckedDay,\n\t\tdayPartRegExp = /([^d]|^)(d|dd)([^d]|$)/g,\n\t\tquoteCount = 0,\n\t\ttokenRegExp = getTokenRegExp(),\n\t\tconverted;\n\n\tfunction padZeros( num, c ) {\n\t\tvar r, s = num + \"\";\n\t\tif ( c > 1 && s.length < c ) {\n\t\t\tr = ( zeros[c - 2] + s);\n\t\t\treturn r.substr( r.length - c, c );\n\t\t}\n\t\telse {\n\t\t\tr = s;\n\t\t}\n\t\treturn r;\n\t}\n\n\tfunction hasDay() {\n\t\tif ( foundDay || checkedDay ) {\n\t\t\treturn foundDay;\n\t\t}\n\t\tfoundDay = dayPartRegExp.test( format );\n\t\tcheckedDay = true;\n\t\treturn foundDay;\n\t}\n\n\tfunction getPart( date, part ) {\n\t\tif ( converted ) {\n\t\t\treturn converted[ part ];\n\t\t}\n\t\tswitch ( part ) {\n\t\t\tcase 0: return date.getFullYear();\n\t\t\tcase 1: return date.getMonth();\n\t\t\tcase 2: return date.getDate();\n\t\t}\n\t}\n\n\tif ( !sortable && convert ) {\n\t\tconverted = convert.fromGregorian( value );\n\t}\n\n\tfor ( ; ; ) {\n\t\t// Save the current index\n\t\tvar index = tokenRegExp.lastIndex,\n\t\t\t// Look for the next pattern\n\t\t\tar = tokenRegExp.exec( format );\n\n\t\t// Append the text before the pattern (or the end of the string if not found)\n\t\tvar preMatch = format.slice( index, ar ? ar.index : format.length );\n\t\tquoteCount += appendPreOrPostMatch( preMatch, ret );\n\n\t\tif ( !ar ) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// do not replace any matches that occur inside a string literal.\n\t\tif ( quoteCount % 2 ) {\n\t\t\tret.push( ar[0] );\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar current = ar[ 0 ],\n\t\t\tclength = current.length;\n\n\t\tswitch ( current ) {\n\t\t\tcase \"ddd\":\n\t\t\t\t//Day of the week, as a three-letter abbreviation\n\t\t\tcase \"dddd\":\n\t\t\t\t// Day of the week, using the full name\n\t\t\t\tvar names = ( clength === 3 ) ? cal.days.namesAbbr : cal.days.names;\n\t\t\t\tret.push( names[value.getDay()] );\n\t\t\t\tbreak;\n\t\t\tcase \"d\":\n\t\t\t\t// Day of month, without leading zero for single-digit days\n\t\t\tcase \"dd\":\n\t\t\t\t// Day of month, with leading zero for single-digit days\n\t\t\t\tfoundDay = true;\n\t\t\t\tret.push(\n\t\t\t\t\tpadZeros( getPart(value, 2), clength )\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"MMM\":\n\t\t\t\t// Month, as a three-letter abbreviation\n\t\t\tcase \"MMMM\":\n\t\t\t\t// Month, using the full name\n\t\t\t\tvar part = getPart( value, 1 );\n\t\t\t\tret.push(\n\t\t\t\t\t( cal.monthsGenitive && hasDay() )\n\t\t\t\t\t?\n\t\t\t\t\tcal.monthsGenitive[ clength === 3 ? \"namesAbbr\" : \"names\" ][ part ]\n\t\t\t\t\t:\n\t\t\t\t\tcal.months[ clength === 3 ? \"namesAbbr\" : \"names\" ][ part ]\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"M\":\n\t\t\t\t// Month, as digits, with no leading zero for single-digit months\n\t\t\tcase \"MM\":\n\t\t\t\t// Month, as digits, with leading zero for single-digit months\n\t\t\t\tret.push(\n\t\t\t\t\tpadZeros( getPart(value, 1) + 1, clength )\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"y\":\n\t\t\t\t// Year, as two digits, but with no leading zero for years less than 10\n\t\t\tcase \"yy\":\n\t\t\t\t// Year, as two digits, with leading zero for years less than 10\n\t\t\tcase \"yyyy\":\n\t\t\t\t// Year represented by four full digits\n\t\t\t\tpart = converted ? converted[ 0 ] : getEraYear( value, cal, getEra(value, eras), sortable );\n\t\t\t\tif ( clength < 4 ) {\n\t\t\t\t\tpart = part % 100;\n\t\t\t\t}\n\t\t\t\tret.push(\n\t\t\t\t\tpadZeros( part, clength )\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"h\":\n\t\t\t\t// Hours with no leading zero for single-digit hours, using 12-hour clock\n\t\t\tcase \"hh\":\n\t\t\t\t// Hours with leading zero for single-digit hours, using 12-hour clock\n\t\t\t\thour = value.getHours() % 12;\n\t\t\t\tif ( hour === 0 ) hour = 12;\n\t\t\t\tret.push(\n\t\t\t\t\tpadZeros( hour, clength )\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"H\":\n\t\t\t\t// Hours with no leading zero for single-digit hours, using 24-hour clock\n\t\t\tcase \"HH\":\n\t\t\t\t// Hours with leading zero for single-digit hours, using 24-hour clock\n\t\t\t\tret.push(\n\t\t\t\t\tpadZeros( value.getHours(), clength )\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"m\":\n\t\t\t\t// Minutes with no leading zero for single-digit minutes\n\t\t\tcase \"mm\":\n\t\t\t\t// Minutes with leading zero for single-digit minutes\n\t\t\t\tret.push(\n\t\t\t\t\tpadZeros( value.getMinutes(), clength )\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"s\":\n\t\t\t\t// Seconds with no leading zero for single-digit seconds\n\t\t\tcase \"ss\":\n\t\t\t\t// Seconds with leading zero for single-digit seconds\n\t\t\t\tret.push(\n\t\t\t\t\tpadZeros( value.getSeconds(), clength )\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"t\":\n\t\t\t\t// One character am/pm indicator (\"a\" or \"p\")\n\t\t\tcase \"tt\":\n\t\t\t\t// Multicharacter am/pm indicator\n\t\t\t\tpart = value.getHours() < 12 ? ( cal.AM ? cal.AM[0] : \" \" ) : ( cal.PM ? cal.PM[0] : \" \" );\n\t\t\t\tret.push( clength === 1 ? part.charAt(0) : part );\n\t\t\t\tbreak;\n\t\t\tcase \"f\":\n\t\t\t\t// Deciseconds\n\t\t\tcase \"ff\":\n\t\t\t\t// Centiseconds\n\t\t\tcase \"fff\":\n\t\t\t\t// Milliseconds\n\t\t\t\tret.push(\n\t\t\t\t\tpadZeros( value.getMilliseconds(), 3 ).substr( 0, clength )\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"z\":\n\t\t\t\t// Time zone offset, no leading zero\n\t\t\tcase \"zz\":\n\t\t\t\t// Time zone offset with leading zero\n\t\t\t\thour = value.getTimezoneOffset() / 60;\n\t\t\t\tret.push(\n\t\t\t\t\t( hour <= 0 ? \"+\" : \"-\" ) + padZeros( Math.floor(Math.abs(hour)), clength )\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"zzz\":\n\t\t\t\t// Time zone offset with leading zero\n\t\t\t\thour = value.getTimezoneOffset() / 60;\n\t\t\t\tret.push(\n\t\t\t\t\t( hour <= 0 ? \"+\" : \"-\" ) + padZeros( Math.floor(Math.abs(hour)), 2 )\n\t\t\t\t\t// Hard coded \":\" separator, rather than using cal.TimeSeparator\n\t\t\t\t\t// Repeated here for consistency, plus \":\" was already assumed in date parsing.\n\t\t\t\t\t+ \":\" + padZeros( Math.abs(value.getTimezoneOffset() % 60), 2 )\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"g\":\n\t\t\tcase \"gg\":\n\t\t\t\tif ( cal.eras ) {\n\t\t\t\t\tret.push(\n\t\t\t\t\t\tcal.eras[ getEra(value, eras) ].name\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\tcase \"/\":\n\t\t\tret.push( cal[\"/\"] );\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow \"Invalid date format pattern \\'\" + current + \"\\'.\";\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret.join( \"\" );\n};\n\n// formatNumber\n(function() {\n\tvar expandNumber;\n\n\texpandNumber = function( number, precision, formatInfo ) {\n\t\tvar groupSizes = formatInfo.groupSizes,\n\t\t\tcurSize = groupSizes[ 0 ],\n\t\t\tcurGroupIndex = 1,\n\t\t\tfactor = Math.pow( 10, precision ),\n\t\t\trounded = Math.round( number * factor ) / factor;\n\n\t\tif ( !isFinite(rounded) ) {\n\t\t\trounded = number;\n\t\t}\n\t\tnumber = rounded;\n\n\t\tvar numberString = number+\"\",\n\t\t\tright = \"\",\n\t\t\tsplit = numberString.split( /e/i ),\n\t\t\texponent = split.length > 1 ? parseInt( split[1], 10 ) : 0;\n\t\tnumberString = split[ 0 ];\n\t\tsplit = numberString.split( \".\" );\n\t\tnumberString = split[ 0 ];\n\t\tright = split.length > 1 ? split[ 1 ] : \"\";\n\n\t\tvar l;\n\t\tif ( exponent > 0 ) {\n\t\t\tright = zeroPad( right, exponent, false );\n\t\t\tnumberString += right.slice( 0, exponent );\n\t\t\tright = right.substr( exponent );\n\t\t}\n\t\telse if ( exponent < 0 ) {\n\t\t\texponent = -exponent;\n\t\t\tnumberString = zeroPad( numberString, exponent + 1 );\n\t\t\tright = numberString.slice( -exponent, numberString.length ) + right;\n\t\t\tnumberString = numberString.slice( 0, -exponent );\n\t\t}\n\n\t\tif ( precision > 0 ) {\n\t\t\tright = formatInfo[ \".\" ] +\n\t\t\t\t( (right.length > precision) ? right.slice(0, precision) : zeroPad(right, precision) );\n\t\t}\n\t\telse {\n\t\t\tright = \"\";\n\t\t}\n\n\t\tvar stringIndex = numberString.length - 1,\n\t\t\tsep = formatInfo[ \",\" ],\n\t\t\tret = \"\";\n\n\t\twhile ( stringIndex >= 0 ) {\n\t\t\tif ( curSize === 0 || curSize > stringIndex ) {\n\t\t\t\treturn numberString.slice( 0, stringIndex + 1 ) + ( ret.length ? (sep + ret + right) : right );\n\t\t\t}\n\t\t\tret = numberString.slice( stringIndex - curSize + 1, stringIndex + 1 ) + ( ret.length ? (sep + ret) : \"\" );\n\n\t\t\tstringIndex -= curSize;\n\n\t\t\tif ( curGroupIndex < groupSizes.length ) {\n\t\t\t\tcurSize = groupSizes[ curGroupIndex ];\n\t\t\t\tcurGroupIndex++;\n\t\t\t}\n\t\t}\n\n\t\treturn numberString.slice( 0, stringIndex + 1 ) + sep + ret + right;\n\t};\n\n\tformatNumber = function( value, format, culture ) {\n\t\tif ( !format || format === \"i\" ) {\n\t\t\treturn culture.name.length ? value.toLocaleString() : value.toString();\n\t\t}\n\t\tformat = format || \"D\";\n\n\t\tvar nf = culture.numberFormat,\n\t\t\tnumber = Math.abs( value ),\n\t\t\tprecision = -1,\n\t\t\tpattern;\n\t\tif ( format.length > 1 ) precision = parseInt( format.slice(1), 10 );\n\n\t\tvar current = format.charAt( 0 ).toUpperCase(),\n\t\t\tformatInfo;\n\n\t\tswitch ( current ) {\n\t\t\tcase \"D\":\n\t\t\t\tpattern = \"n\";\n\t\t\t\tif ( precision !== -1 ) {\n\t\t\t\t\tnumber = zeroPad( \"\" + number, precision, true );\n\t\t\t\t}\n\t\t\t\tif ( value < 0 ) number = -number;\n\t\t\t\tbreak;\n\t\t\tcase \"N\":\n\t\t\t\tformatInfo = nf;\n\t\t\t\t// fall through\n\t\t\tcase \"C\":\n\t\t\t\tformatInfo = formatInfo || nf.currency;\n\t\t\t\t// fall through\n\t\t\tcase \"P\":\n\t\t\t\tformatInfo = formatInfo || nf.percent;\n\t\t\t\tpattern = value < 0 ? formatInfo.pattern[ 0 ] : ( formatInfo.pattern[1] || \"n\" );\n\t\t\t\tif ( precision === -1 ) precision = formatInfo.decimals;\n\t\t\t\tnumber = expandNumber( number * (current === \"P\" ? 100 : 1), precision, formatInfo );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow \"Bad number format specifier: \" + current;\n\t\t}\n\n\t\tvar patternParts = /n|\\$|-|%/g,\n\t\t\tret = \"\";\n\t\tfor ( ; ; ) {\n\t\t\tvar index = patternParts.lastIndex,\n\t\t\t\tar = patternParts.exec( pattern );\n\n\t\t\tret += pattern.slice( index, ar ? ar.index : pattern.length );\n\n\t\t\tif ( !ar ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch ( ar[0] ) {\n\t\t\t\tcase \"n\":\n\t\t\t\t\tret += number;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"$\":\n\t\t\t\t\tret += nf.currency.symbol;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"-\":\n\t\t\t\t\t// don't make 0 negative\n\t\t\t\t\tif ( /[1-9]/.test(number) ) {\n\t\t\t\t\t\tret += nf[ \"-\" ];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"%\":\n\t\t\t\t\tret += nf.percent.symbol;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t};\n\n}());\n\ngetTokenRegExp = function() {\n\t// regular expression for matching date and time tokens in format strings.\n\treturn /\\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|zzz|zz|z|gg|g/g;\n};\n\ngetEra = function( date, eras ) {\n\tif ( !eras ) return 0;\n\tvar start, ticks = date.getTime();\n\tfor ( var i = 0, l = eras.length; i < l; i++ ) {\n\t\tstart = eras[ i ].start;\n\t\tif ( start === null || ticks >= start ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn 0;\n};\n\ngetEraYear = function( date, cal, era, sortable ) {\n\tvar year = date.getFullYear();\n\tif ( !sortable && cal.eras ) {\n\t\t// convert normal gregorian year to era-shifted gregorian\n\t\t// year by subtracting the era offset\n\t\tyear -= cal.eras[ era ].offset;\n\t}\n\treturn year;\n};\n\n// parseExact\n(function() {\n\tvar expandYear,\n\t\tgetDayIndex,\n\t\tgetMonthIndex,\n\t\tgetParseRegExp,\n\t\toutOfRange,\n\t\ttoUpper,\n\t\ttoUpperArray;\n\n\texpandYear = function( cal, year ) {\n\t\t// expands 2-digit year into 4 digits.\n\t\tvar now = new Date(),\n\t\t\tera = getEra( now );\n\t\tif ( year < 100 ) {\n\t\t\tvar twoDigitYearMax = cal.twoDigitYearMax;\n\t\t\ttwoDigitYearMax = typeof twoDigitYearMax === \"string\" ? new Date().getFullYear() % 100 + parseInt( twoDigitYearMax, 10 ) : twoDigitYearMax;\n\t\t\tvar curr = getEraYear( now, cal, era );\n\t\t\tyear += curr - ( curr % 100 );\n\t\t\tif ( year > twoDigitYearMax ) {\n\t\t\t\tyear -= 100;\n\t\t\t}\n\t\t}\n\t\treturn year;\n\t};\n\n\tgetDayIndex = function\t( cal, value, abbr ) {\n\t\tvar ret,\n\t\t\tdays = cal.days,\n\t\t\tupperDays = cal._upperDays;\n\t\tif ( !upperDays ) {\n\t\t\tcal._upperDays = upperDays = [\n\t\t\t\ttoUpperArray( days.names ),\n\t\t\t\ttoUpperArray( days.namesAbbr ),\n\t\t\t\ttoUpperArray( days.namesShort )\n\t\t\t];\n\t\t}\n\t\tvalue = toUpper( value );\n\t\tif ( abbr ) {\n\t\t\tret = arrayIndexOf( upperDays[1], value );\n\t\t\tif ( ret === -1 ) {\n\t\t\t\tret = arrayIndexOf( upperDays[2], value );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tret = arrayIndexOf( upperDays[0], value );\n\t\t}\n\t\treturn ret;\n\t};\n\n\tgetMonthIndex = function( cal, value, abbr ) {\n\t\tvar months = cal.months,\n\t\t\tmonthsGen = cal.monthsGenitive || cal.months,\n\t\t\tupperMonths = cal._upperMonths,\n\t\t\tupperMonthsGen = cal._upperMonthsGen;\n\t\tif ( !upperMonths ) {\n\t\t\tcal._upperMonths = upperMonths = [\n\t\t\t\ttoUpperArray( months.names ),\n\t\t\t\ttoUpperArray( months.namesAbbr )\n\t\t\t];\n\t\t\tcal._upperMonthsGen = upperMonthsGen = [\n\t\t\t\ttoUpperArray( monthsGen.names ),\n\t\t\t\ttoUpperArray( monthsGen.namesAbbr )\n\t\t\t];\n\t\t}\n\t\tvalue = toUpper( value );\n\t\tvar i = arrayIndexOf( abbr ? upperMonths[1] : upperMonths[0], value );\n\t\tif ( i < 0 ) {\n\t\t\ti = arrayIndexOf( abbr ? upperMonthsGen[1] : upperMonthsGen[0], value );\n\t\t}\n\t\treturn i;\n\t};\n\n\tgetParseRegExp = function( cal, format ) {\n\t\t// converts a format string into a regular expression with groups that\n\t\t// can be used to extract date fields from a date string.\n\t\t// check for a cached parse regex.\n\t\tvar re = cal._parseRegExp;\n\t\tif ( !re ) {\n\t\t\tcal._parseRegExp = re = {};\n\t\t}\n\t\telse {\n\t\t\tvar reFormat = re[ format ];\n\t\t\tif ( reFormat ) {\n\t\t\t\treturn reFormat;\n\t\t\t}\n\t\t}\n\n\t\t// expand single digit formats, then escape regular expression characters.\n\t\tvar expFormat = expandFormat( cal, format ).replace( /([\\^\\$\\.\\*\\+\\?\\|\\[\\]\\(\\)\\{\\}])/g, \"\\\\\\\\$1\" ),\n\t\t\tregexp = [ \"^\" ],\n\t\t\tgroups = [],\n\t\t\tindex = 0,\n\t\t\tquoteCount = 0,\n\t\t\ttokenRegExp = getTokenRegExp(),\n\t\t\tmatch;\n\n\t\t// iterate through each date token found.\n\t\twhile ( (match = tokenRegExp.exec(expFormat)) !== null ) {\n\t\t\tvar preMatch = expFormat.slice( index, match.index );\n\t\t\tindex = tokenRegExp.lastIndex;\n\n\t\t\t// don't replace any matches that occur inside a string literal.\n\t\t\tquoteCount += appendPreOrPostMatch( preMatch, regexp );\n\t\t\tif ( quoteCount % 2 ) {\n\t\t\t\tregexp.push( match[0] );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// add a regex group for the token.\n\t\t\tvar m = match[ 0 ],\n\t\t\t\tlen = m.length,\n\t\t\t\tadd;\n\t\t\tswitch ( m ) {\n\t\t\t\tcase \"dddd\": case \"ddd\":\n\t\t\t\tcase \"MMMM\": case \"MMM\":\n\t\t\t\tcase \"gg\": case \"g\":\n\t\t\t\t\tadd = \"(\\\\D+)\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"tt\": case \"t\":\n\t\t\t\t\tadd = \"(\\\\D*)\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"yyyy\":\n\t\t\t\tcase \"fff\":\n\t\t\t\tcase \"ff\":\n\t\t\t\tcase \"f\":\n\t\t\t\t\tadd = \"(\\\\d{\" + len + \"})\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"dd\": case \"d\":\n\t\t\t\tcase \"MM\": case \"M\":\n\t\t\t\tcase \"yy\": case \"y\":\n\t\t\t\tcase \"HH\": case \"H\":\n\t\t\t\tcase \"hh\": case \"h\":\n\t\t\t\tcase \"mm\": case \"m\":\n\t\t\t\tcase \"ss\": case \"s\":\n\t\t\t\t\tadd = \"(\\\\d\\\\d?)\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"zzz\":\n\t\t\t\t\tadd = \"([+-]?\\\\d\\\\d?:\\\\d{2})\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"zz\": case \"z\":\n\t\t\t\t\tadd = \"([+-]?\\\\d\\\\d?)\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"/\":\n\t\t\t\t\tadd = \"(\\\\\" + cal[ \"/\" ] + \")\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow \"Invalid date format pattern \\'\" + m + \"\\'.\";\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( add ) {\n\t\t\t\tregexp.push( add );\n\t\t\t}\n\t\t\tgroups.push( match[0] );\n\t\t}\n\t\tappendPreOrPostMatch( expFormat.slice(index), regexp );\n\t\tregexp.push( \"$\" );\n\n\t\t// allow whitespace to differ when matching formats.\n\t\tvar regexpStr = regexp.join( \"\" ).replace( /\\s+/g, \"\\\\s+\" ),\n\t\t\tparseRegExp = { \"regExp\": regexpStr, \"groups\": groups };\n\n\t\t// cache the regex for this format.\n\t\treturn re[ format ] = parseRegExp;\n\t};\n\n\toutOfRange = function( value, low, high ) {\n\t\treturn value < low || value > high;\n\t};\n\n\ttoUpper = function( value ) {\n\t\t// \"he-IL\" has non-breaking space in weekday names.\n\t\treturn value.split( \"\\u00A0\" ).join( \" \" ).toUpperCase();\n\t};\n\n\ttoUpperArray = function( arr ) {\n\t\tvar results = [];\n\t\tfor ( var i = 0, l = arr.length; i < l; i++ ) {\n\t\t\tresults[ i ] = toUpper( arr[i] );\n\t\t}\n\t\treturn results;\n\t};\n\n\tparseExact = function( value, format, culture ) {\n\t\t// try to parse the date string by matching against the format string\n\t\t// while using the specified culture for date field names.\n\t\tvalue = trim( value );\n\t\tvar cal = culture.calendar,\n\t\t\t// convert date formats into regular expressions with groupings.\n\t\t\t// use the regexp to determine the input format and extract the date fields.\n\t\t\tparseInfo = getParseRegExp( cal, format ),\n\t\t\tmatch = new RegExp( parseInfo.regExp ).exec( value );\n\t\tif ( match === null ) {\n\t\t\treturn null;\n\t\t}\n\t\t// found a date format that matches the input.\n\t\tvar groups = parseInfo.groups,\n\t\t\tera = null, year = null, month = null, date = null, weekDay = null,\n\t\t\thour = 0, hourOffset, min = 0, sec = 0, msec = 0, tzMinOffset = null,\n\t\t\tpmHour = false;\n\t\t// iterate the format groups to extract and set the date fields.\n\t\tfor ( var j = 0, jl = groups.length; j < jl; j++ ) {\n\t\t\tvar matchGroup = match[ j + 1 ];\n\t\t\tif ( matchGroup ) {\n\t\t\t\tvar current = groups[ j ],\n\t\t\t\t\tclength = current.length,\n\t\t\t\t\tmatchInt = parseInt( matchGroup, 10 );\n\t\t\t\tswitch ( current ) {\n\t\t\t\t\tcase \"dd\": case \"d\":\n\t\t\t\t\t\t// Day of month.\n\t\t\t\t\t\tdate = matchInt;\n\t\t\t\t\t\t// check that date is generally in valid range, also checking overflow below.\n\t\t\t\t\t\tif ( outOfRange(date, 1, 31) ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"MMM\": case \"MMMM\":\n\t\t\t\t\t\tmonth = getMonthIndex( cal, matchGroup, clength === 3 );\n\t\t\t\t\t\tif ( outOfRange(month, 0, 11) ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"M\": case \"MM\":\n\t\t\t\t\t\t// Month.\n\t\t\t\t\t\tmonth = matchInt - 1;\n\t\t\t\t\t\tif ( outOfRange(month, 0, 11) ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"y\": case \"yy\":\n\t\t\t\t\tcase \"yyyy\":\n\t\t\t\t\t\tyear = clength < 4 ? expandYear( cal, matchInt ) : matchInt;\n\t\t\t\t\t\tif ( outOfRange(year, 0, 9999) ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"h\": case \"hh\":\n\t\t\t\t\t\t// Hours (12-hour clock).\n\t\t\t\t\t\thour = matchInt;\n\t\t\t\t\t\tif ( hour === 12 ) hour = 0;\n\t\t\t\t\t\tif ( outOfRange(hour, 0, 11) ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"H\": case \"HH\":\n\t\t\t\t\t\t// Hours (24-hour clock).\n\t\t\t\t\t\thour = matchInt;\n\t\t\t\t\t\tif ( outOfRange(hour, 0, 23) ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"m\": case \"mm\":\n\t\t\t\t\t\t// Minutes.\n\t\t\t\t\t\tmin = matchInt;\n\t\t\t\t\t\tif ( outOfRange(min, 0, 59) ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"s\": case \"ss\":\n\t\t\t\t\t\t// Seconds.\n\t\t\t\t\t\tsec = matchInt;\n\t\t\t\t\t\tif ( outOfRange(sec, 0, 59) ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"tt\": case \"t\":\n\t\t\t\t\t\t// AM/PM designator.\n\t\t\t\t\t\t// see if it is standard, upper, or lower case PM. If not, ensure it is at least one of\n\t\t\t\t\t\t// the AM tokens. If not, fail the parse for this format.\n\t\t\t\t\t\tpmHour = cal.PM && ( matchGroup === cal.PM[0] || matchGroup === cal.PM[1] || matchGroup === cal.PM[2] );\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!pmHour && (\n\t\t\t\t\t\t\t\t!cal.AM || ( matchGroup !== cal.AM[0] && matchGroup !== cal.AM[1] && matchGroup !== cal.AM[2] )\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"f\":\n\t\t\t\t\t\t// Deciseconds.\n\t\t\t\t\tcase \"ff\":\n\t\t\t\t\t\t// Centiseconds.\n\t\t\t\t\tcase \"fff\":\n\t\t\t\t\t\t// Milliseconds.\n\t\t\t\t\t\tmsec = matchInt * Math.pow( 10, 3 - clength );\n\t\t\t\t\t\tif ( outOfRange(msec, 0, 999) ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"ddd\":\n\t\t\t\t\t\t// Day of week.\n\t\t\t\t\tcase \"dddd\":\n\t\t\t\t\t\t// Day of week.\n\t\t\t\t\t\tweekDay = getDayIndex( cal, matchGroup, clength === 3 );\n\t\t\t\t\t\tif ( outOfRange(weekDay, 0, 6) ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"zzz\":\n\t\t\t\t\t\t// Time zone offset in +/- hours:min.\n\t\t\t\t\t\tvar offsets = matchGroup.split( /:/ );\n\t\t\t\t\t\tif ( offsets.length !== 2 ) return null;\n\t\t\t\t\t\thourOffset = parseInt( offsets[0], 10 );\n\t\t\t\t\t\tif ( outOfRange(hourOffset, -12, 13) ) return null;\n\t\t\t\t\t\tvar minOffset = parseInt( offsets[1], 10 );\n\t\t\t\t\t\tif ( outOfRange(minOffset, 0, 59) ) return null;\n\t\t\t\t\t\ttzMinOffset = ( hourOffset * 60 ) + ( startsWith(matchGroup, \"-\") ? -minOffset : minOffset );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"z\": case \"zz\":\n\t\t\t\t\t\t// Time zone offset in +/- hours.\n\t\t\t\t\t\thourOffset = matchInt;\n\t\t\t\t\t\tif ( outOfRange(hourOffset, -12, 13) ) return null;\n\t\t\t\t\t\ttzMinOffset = hourOffset * 60;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"g\": case \"gg\":\n\t\t\t\t\t\tvar eraName = matchGroup;\n\t\t\t\t\t\tif ( !eraName || !cal.eras ) return null;\n\t\t\t\t\t\teraName = trim( eraName.toLowerCase() );\n\t\t\t\t\t\tfor ( var i = 0, l = cal.eras.length; i < l; i++ ) {\n\t\t\t\t\t\t\tif ( eraName === cal.eras[i].name.toLowerCase() ) {\n\t\t\t\t\t\t\t\tera = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// could not find an era with that name\n\t\t\t\t\t\tif ( era === null ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar result = new Date(), defaultYear, convert = cal.convert;\n\t\tdefaultYear = convert ? convert.fromGregorian( result )[ 0 ] : result.getFullYear();\n\t\tif ( year === null ) {\n\t\t\tyear = defaultYear;\n\t\t}\n\t\telse if ( cal.eras ) {\n\t\t\t// year must be shifted to normal gregorian year\n\t\t\t// but not if year was not specified, its already normal gregorian\n\t\t\t// per the main if clause above.\n\t\t\tyear += cal.eras[( era || 0 )].offset;\n\t\t}\n\t\t// set default day and month to 1 and January, so if unspecified, these are the defaults\n\t\t// instead of the current day/month.\n\t\tif ( month === null ) {\n\t\t\tmonth = 0;\n\t\t}\n\t\tif ( date === null ) {\n\t\t\tdate = 1;\n\t\t}\n\t\t// now have year, month, and date, but in the culture's calendar.\n\t\t// convert to gregorian if necessary\n\t\tif ( convert ) {\n\t\t\tresult = convert.toGregorian( year, month, date );\n\t\t\t// conversion failed, must be an invalid match\n\t\t\tif ( result === null ) return null;\n\t\t}\n\t\telse {\n\t\t\t// have to set year, month and date together to avoid overflow based on current date.\n\t\t\tresult.setFullYear( year, month, date );\n\t\t\t// check to see if date overflowed for specified month (only checked 1-31 above).\n\t\t\tif ( result.getDate() !== date ) return null;\n\t\t\t// invalid day of week.\n\t\t\tif ( weekDay !== null && result.getDay() !== weekDay ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t// if pm designator token was found make sure the hours fit the 24-hour clock.\n\t\tif ( pmHour && hour < 12 ) {\n\t\t\thour += 12;\n\t\t}\n\t\tresult.setHours( hour, min, sec, msec );\n\t\tif ( tzMinOffset !== null ) {\n\t\t\t// adjust timezone to utc before applying local offset.\n\t\t\tvar adjustedMin = result.getMinutes() - ( tzMinOffset + result.getTimezoneOffset() );\n\t\t\t// Safari limits hours and minutes to the range of -127 to 127.\t We need to use setHours\n\t\t\t// to ensure both these fields will not exceed this range.\tadjustedMin will range\n\t\t\t// somewhere between -1440 and 1500, so we only need to split this into hours.\n\t\t\tresult.setHours( result.getHours() + parseInt(adjustedMin / 60, 10), adjustedMin % 60 );\n\t\t}\n\t\treturn result;\n\t};\n}());\n\nparseNegativePattern = function( value, nf, negativePattern ) {\n\tvar neg = nf[ \"-\" ],\n\t\tpos = nf[ \"+\" ],\n\t\tret;\n\tswitch ( negativePattern ) {\n\t\tcase \"n -\":\n\t\t\tneg = \" \" + neg;\n\t\t\tpos = \" \" + pos;\n\t\t\t// fall through\n\t\tcase \"n-\":\n\t\t\tif ( endsWith(value, neg) ) {\n\t\t\t\tret = [ \"-\", value.substr(0, value.length - neg.length) ];\n\t\t\t}\n\t\t\telse if ( endsWith(value, pos) ) {\n\t\t\t\tret = [ \"+\", value.substr(0, value.length - pos.length) ];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"- n\":\n\t\t\tneg += \" \";\n\t\t\tpos += \" \";\n\t\t\t// fall through\n\t\tcase \"-n\":\n\t\t\tif ( startsWith(value, neg) ) {\n\t\t\t\tret = [ \"-\", value.substr(neg.length) ];\n\t\t\t}\n\t\t\telse if ( startsWith(value, pos) ) {\n\t\t\t\tret = [ \"+\", value.substr(pos.length) ];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"(n)\":\n\t\t\tif ( startsWith(value, \"(\") && endsWith(value, \")\") ) {\n\t\t\t\tret = [ \"-\", value.substr(1, value.length - 2) ];\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn ret || [ \"\", value ];\n};\n\n//\n// public instance functions\n//\n\nGlobalize.prototype.findClosestCulture = function( cultureSelector ) {\n\treturn Globalize.findClosestCulture.call( this, cultureSelector );\n};\n\nGlobalize.prototype.format = function( value, format, cultureSelector ) {\n\treturn Globalize.format.call( this, value, format, cultureSelector );\n};\n\nGlobalize.prototype.localize = function( key, cultureSelector ) {\n\treturn Globalize.localize.call( this, key, cultureSelector );\n};\n\nGlobalize.prototype.parseInt = function( value, radix, cultureSelector ) {\n\treturn Globalize.parseInt.call( this, value, radix, cultureSelector );\n};\n\nGlobalize.prototype.parseFloat = function( value, radix, cultureSelector ) {\n\treturn Globalize.parseFloat.call( this, value, radix, cultureSelector );\n};\n\nGlobalize.prototype.culture = function( cultureSelector ) {\n\treturn Globalize.culture.call( this, cultureSelector );\n};\n\n//\n// public singleton functions\n//\n\nGlobalize.addCultureInfo = function( cultureName, baseCultureName, info ) {\n\n\tvar base = {},\n\t\tisNew = false;\n\n\tif ( typeof cultureName !== \"string\" ) {\n\t\t// cultureName argument is optional string. If not specified, assume info is first\n\t\t// and only argument. Specified info deep-extends current culture.\n\t\tinfo = cultureName;\n\t\tcultureName = this.culture().name;\n\t\tbase = this.cultures[ cultureName ];\n\t} else if ( typeof baseCultureName !== \"string\" ) {\n\t\t// baseCultureName argument is optional string. If not specified, assume info is second\n\t\t// argument. Specified info deep-extends specified culture.\n\t\t// If specified culture does not exist, create by deep-extending default\n\t\tinfo = baseCultureName;\n\t\tisNew = ( this.cultures[ cultureName ] == null );\n\t\tbase = this.cultures[ cultureName ] || this.cultures[ \"default\" ];\n\t} else {\n\t\t// cultureName and baseCultureName specified. Assume a new culture is being created\n\t\t// by deep-extending an specified base culture\n\t\tisNew = true;\n\t\tbase = this.cultures[ baseCultureName ];\n\t}\n\n\tthis.cultures[ cultureName ] = extend(true, {},\n\t\tbase,\n\t\tinfo\n\t);\n\t// Make the standard calendar the current culture if it's a new culture\n\tif ( isNew ) {\n\t\tthis.cultures[ cultureName ].calendar = this.cultures[ cultureName ].calendars.standard;\n\t}\n};\n\nGlobalize.findClosestCulture = function( name ) {\n\tvar match;\n\tif ( !name ) {\n\t\treturn this.cultures[ this.cultureSelector ] || this.cultures[ \"default\" ];\n\t}\n\tif ( typeof name === \"string\" ) {\n\t\tname = name.split( \",\" );\n\t}\n\tif ( isArray(name) ) {\n\t\tvar lang,\n\t\t\tcultures = this.cultures,\n\t\t\tlist = name,\n\t\t\ti, l = list.length,\n\t\t\tprioritized = [];\n\t\tfor ( i = 0; i < l; i++ ) {\n\t\t\tname = trim( list[i] );\n\t\t\tvar pri, parts = name.split( \";\" );\n\t\t\tlang = trim( parts[0] );\n\t\t\tif ( parts.length === 1 ) {\n\t\t\t\tpri = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tname = trim( parts[1] );\n\t\t\t\tif ( name.indexOf(\"q=\") === 0 ) {\n\t\t\t\t\tname = name.substr( 2 );\n\t\t\t\t\tpri = parseFloat( name );\n\t\t\t\t\tpri = isNaN( pri ) ? 0 : pri;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpri = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprioritized.push({ lang: lang, pri: pri });\n\t\t}\n\t\tprioritized.sort(function( a, b ) {\n\t\t\treturn a.pri < b.pri ? 1 : -1;\n\t\t});\n\n\t\t// exact match\n\t\tfor ( i = 0; i < l; i++ ) {\n\t\t\tlang = prioritized[ i ].lang;\n\t\t\tmatch = cultures[ lang ];\n\t\t\tif ( match ) {\n\t\t\t\treturn match;\n\t\t\t}\n\t\t}\n\n\t\t// neutral language match\n\t\tfor ( i = 0; i < l; i++ ) {\n\t\t\tlang = prioritized[ i ].lang;\n\t\t\tdo {\n\t\t\t\tvar index = lang.lastIndexOf( \"-\" );\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// strip off the last part. e.g. en-US => en\n\t\t\t\tlang = lang.substr( 0, index );\n\t\t\t\tmatch = cultures[ lang ];\n\t\t\t\tif ( match ) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile ( 1 );\n\t\t}\n\n\t\t// last resort: match first culture using that language\n\t\tfor ( i = 0; i < l; i++ ) {\n\t\t\tlang = prioritized[ i ].lang;\n\t\t\tfor ( var cultureKey in cultures ) {\n\t\t\t\tvar culture = cultures[ cultureKey ];\n\t\t\t\tif ( culture.language == lang ) {\n\t\t\t\t\treturn culture;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse if ( typeof name === \"object\" ) {\n\t\treturn name;\n\t}\n\treturn match || null;\n};\n\nGlobalize.format = function( value, format, cultureSelector ) {\n\tculture = this.findClosestCulture( cultureSelector );\n\tif ( value instanceof Date ) {\n\t\tvalue = formatDate( value, format, culture );\n\t}\n\telse if ( typeof value === \"number\" ) {\n\t\tvalue = formatNumber( value, format, culture );\n\t}\n\treturn value;\n};\n\nGlobalize.localize = function( key, cultureSelector ) {\n\treturn (\n\t\tthis.findClosestCulture( cultureSelector ).messages[ key ]\n\t\t||\n\t\tthis.cultures[ \"default\" ].messages[ \"key\" ]\n\t);\n};\n\nGlobalize.parseDate = function( value, formats, culture ) {\n\tculture = this.findClosestCulture( culture );\n\n\tvar date, prop, patterns;\n\tif ( formats ) {\n\t\tif ( typeof formats === \"string\" ) {\n\t\t\tformats = [ formats ];\n\t\t}\n\t\tif ( formats.length ) {\n\t\t\tfor ( var i = 0, l = formats.length; i < l; i++ ) {\n\t\t\t\tvar format = formats[ i ];\n\t\t\t\tif ( format ) {\n\t\t\t\t\tdate = parseExact( value, format, culture );\n\t\t\t\t\tif ( date ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpatterns = culture.calendar.patterns;\n\t\tfor ( prop in patterns ) {\n\t\t\tdate = parseExact( value, patterns[prop], culture );\n\t\t\tif ( date ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn date || null;\n};\n\nGlobalize.parseInt = function( value, radix, cultureSelector ) {\n\treturn Math.floor( Globalize.parseFloat(value, radix, cultureSelector) );\n};\n\nGlobalize.parseFloat = function( value, radix, cultureSelector ) {\n\t// radix argument is optional\n\tif ( typeof radix !== \"number\" ) {\n\t\tcultureSelector = radix;\n\t\tradix = 10;\n\t}\n\n\tvar culture = this.findClosestCulture( cultureSelector );\n\tvar ret = NaN,\n\t\tnf = culture.numberFormat;\n\n\tif ( value.indexOf(culture.numberFormat.currency.symbol) > -1 ) {\n\t\t// remove currency symbol\n\t\tvalue = value.replace( culture.numberFormat.currency.symbol, \"\" );\n\t\t// replace decimal seperator\n\t\tvalue = value.replace( culture.numberFormat.currency[\".\"], culture.numberFormat[\".\"] );\n\t}\n\n\t// trim leading and trailing whitespace\n\tvalue = trim( value );\n\n\t// allow infinity or hexidecimal\n\tif ( regexInfinity.test(value) ) {\n\t\tret = parseFloat( value );\n\t}\n\telse if ( !radix && regexHex.test(value) ) {\n\t\tret = parseInt( value, 16 );\n\t}\n\telse {\n\t\tvar signInfo = parseNegativePattern( value, nf, nf.pattern[0] ),\n\t\t\tsign = signInfo[ 0 ],\n\t\t\tnum = signInfo[ 1 ];\n\t\t// determine sign and number\n\t\tif ( sign === \"\" && nf.pattern[0] !== \"-n\" ) {\n\t\t\tsignInfo = parseNegativePattern( value, nf, \"-n\" );\n\t\t\tsign = signInfo[ 0 ];\n\t\t\tnum = signInfo[ 1 ];\n\t\t}\n\t\tsign = sign || \"+\";\n\t\t// determine exponent and number\n\t\tvar exponent,\n\t\t\tintAndFraction,\n\t\t\texponentPos = num.indexOf( \"e\" );\n\t\tif ( exponentPos < 0 ) exponentPos = num.indexOf( \"E\" );\n\t\tif ( exponentPos < 0 ) {\n\t\t\tintAndFraction = num;\n\t\t\texponent = null;\n\t\t}\n\t\telse {\n\t\t\tintAndFraction = num.substr( 0, exponentPos );\n\t\t\texponent = num.substr( exponentPos + 1 );\n\t\t}\n\t\t// determine decimal position\n\t\tvar integer,\n\t\t\tfraction,\n\t\t\tdecSep = nf[ \".\" ],\n\t\t\tdecimalPos = intAndFraction.indexOf( decSep );\n\t\tif ( decimalPos < 0 ) {\n\t\t\tinteger = intAndFraction;\n\t\t\tfraction = null;\n\t\t}\n\t\telse {\n\t\t\tinteger = intAndFraction.substr( 0, decimalPos );\n\t\t\tfraction = intAndFraction.substr( decimalPos + decSep.length );\n\t\t}\n\t\t// handle groups (e.g. 1,000,000)\n\t\tvar groupSep = nf[ \",\" ];\n\t\tinteger = integer.split( groupSep ).join( \"\" );\n\t\tvar altGroupSep = groupSep.replace( /\\u00A0/g, \" \" );\n\t\tif ( groupSep !== altGroupSep ) {\n\t\t\tinteger = integer.split( altGroupSep ).join( \"\" );\n\t\t}\n\t\t// build a natively parsable number string\n\t\tvar p = sign + integer;\n\t\tif ( fraction !== null ) {\n\t\t\tp += \".\" + fraction;\n\t\t}\n\t\tif ( exponent !== null ) {\n\t\t\t// exponent itself may have a number patternd\n\t\t\tvar expSignInfo = parseNegativePattern( exponent, nf, \"-n\" );\n\t\t\tp += \"e\" + ( expSignInfo[0] || \"+\" ) + expSignInfo[ 1 ];\n\t\t}\n\t\tif ( regexParseFloat.test(p) ) {\n\t\t\tret = parseFloat( p );\n\t\t}\n\t}\n\treturn ret;\n};\n\nGlobalize.culture = function( cultureSelector ) {\n\t// setter\n\tif ( typeof cultureSelector !== \"undefined\" ) {\n\t\tthis.cultureSelector = cultureSelector;\n\t}\n\t// getter\n\treturn this.findClosestCulture( cultureSelector ) || this.culture[ \"default\" ];\n};\n\n}( this ));\n\n/*\n * Globalize Culture en-US\n *\n * http://github.com/jquery/globalize\n *\n * Copyright Software Freedom Conservancy, Inc.\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n *\n * This file was generated by the Globalize Culture Generator\n * Translation: bugs found in this file need to be fixed in the generator\n */\n\n(function( window, undefined ) {\n\nvar Globalize;\n\nif ( typeof require !== \"undefined\"\n\t&& typeof exports !== \"undefined\"\n\t&& typeof module !== \"undefined\" ) {\n\t// Assume CommonJS\n\tGlobalize = require( \"globalize\" );\n} else {\n\t// Global variable\n\tGlobalize = window.Globalize;\n}\n\nGlobalize.addCultureInfo( \"en-US\", \"default\", {\n\tenglishName: \"English (United States)\"\n});\n\n}( this ));\n\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var type;\r\n            (function (type) {\r\n                /**\r\n                 * Module Double contains a set of constants and precision based utility methods\r\n                 * for dealing with doubles and their decimal garbage in the javascript.\r\n                 */\r\n                var Double;\r\n                (function (Double) {\r\n                    // Constants.\r\n                    Double.MIN_VALUE = -Number.MAX_VALUE;\r\n                    Double.MAX_VALUE = Number.MAX_VALUE;\r\n                    Double.MIN_EXP = -308;\r\n                    Double.MAX_EXP = 308;\r\n                    Double.EPSILON = 1E-323;\r\n                    Double.DEFAULT_PRECISION = 0.0001;\r\n                    Double.DEFAULT_PRECISION_IN_DECIMAL_DIGITS = 12;\r\n                    Double.LOG_E_10 = Math.log(10);\r\n                    Double.POSITIVE_POWERS = [\r\n                        1E0, 1E1, 1E2, 1E3, 1E4, 1E5, 1E6, 1E7, 1E8, 1E9, 1E10, 1E11, 1E12, 1E13, 1E14, 1E15, 1E16, 1E17, 1E18, 1E19, 1E20, 1E21, 1E22, 1E23, 1E24, 1E25, 1E26, 1E27, 1E28, 1E29, 1E30, 1E31, 1E32, 1E33, 1E34, 1E35, 1E36, 1E37, 1E38, 1E39, 1E40, 1E41, 1E42, 1E43, 1E44, 1E45, 1E46, 1E47, 1E48, 1E49, 1E50, 1E51, 1E52, 1E53, 1E54, 1E55, 1E56, 1E57, 1E58, 1E59, 1E60, 1E61, 1E62, 1E63, 1E64, 1E65, 1E66, 1E67, 1E68, 1E69, 1E70, 1E71, 1E72, 1E73, 1E74, 1E75, 1E76, 1E77, 1E78, 1E79, 1E80, 1E81, 1E82, 1E83, 1E84, 1E85, 1E86, 1E87, 1E88, 1E89, 1E90, 1E91, 1E92, 1E93, 1E94, 1E95, 1E96, 1E97, 1E98, 1E99,\r\n                        1E100, 1E101, 1E102, 1E103, 1E104, 1E105, 1E106, 1E107, 1E108, 1E109, 1E110, 1E111, 1E112, 1E113, 1E114, 1E115, 1E116, 1E117, 1E118, 1E119, 1E120, 1E121, 1E122, 1E123, 1E124, 1E125, 1E126, 1E127, 1E128, 1E129, 1E130, 1E131, 1E132, 1E133, 1E134, 1E135, 1E136, 1E137, 1E138, 1E139, 1E140, 1E141, 1E142, 1E143, 1E144, 1E145, 1E146, 1E147, 1E148, 1E149, 1E150, 1E151, 1E152, 1E153, 1E154, 1E155, 1E156, 1E157, 1E158, 1E159, 1E160, 1E161, 1E162, 1E163, 1E164, 1E165, 1E166, 1E167, 1E168, 1E169, 1E170, 1E171, 1E172, 1E173, 1E174, 1E175, 1E176, 1E177, 1E178, 1E179, 1E180, 1E181, 1E182, 1E183, 1E184, 1E185, 1E186, 1E187, 1E188, 1E189, 1E190, 1E191, 1E192, 1E193, 1E194, 1E195, 1E196, 1E197, 1E198, 1E199,\r\n                        1E200, 1E201, 1E202, 1E203, 1E204, 1E205, 1E206, 1E207, 1E208, 1E209, 1E210, 1E211, 1E212, 1E213, 1E214, 1E215, 1E216, 1E217, 1E218, 1E219, 1E220, 1E221, 1E222, 1E223, 1E224, 1E225, 1E226, 1E227, 1E228, 1E229, 1E230, 1E231, 1E232, 1E233, 1E234, 1E235, 1E236, 1E237, 1E238, 1E239, 1E240, 1E241, 1E242, 1E243, 1E244, 1E245, 1E246, 1E247, 1E248, 1E249, 1E250, 1E251, 1E252, 1E253, 1E254, 1E255, 1E256, 1E257, 1E258, 1E259, 1E260, 1E261, 1E262, 1E263, 1E264, 1E265, 1E266, 1E267, 1E268, 1E269, 1E270, 1E271, 1E272, 1E273, 1E274, 1E275, 1E276, 1E277, 1E278, 1E279, 1E280, 1E281, 1E282, 1E283, 1E284, 1E285, 1E286, 1E287, 1E288, 1E289, 1E290, 1E291, 1E292, 1E293, 1E294, 1E295, 1E296, 1E297, 1E298, 1E299,\r\n                        1E300, 1E301, 1E302, 1E303, 1E304, 1E305, 1E306, 1E307, 1E308\r\n                    ];\r\n                    Double.NEGATIVE_POWERS = [\r\n                        1E0, 1E-1, 1E-2, 1E-3, 1E-4, 1E-5, 1E-6, 1E-7, 1E-8, 1E-9, 1E-10, 1E-11, 1E-12, 1E-13, 1E-14, 1E-15, 1E-16, 1E-17, 1E-18, 1E-19, 1E-20, 1E-21, 1E-22, 1E-23, 1E-24, 1E-25, 1E-26, 1E-27, 1E-28, 1E-29, 1E-30, 1E-31, 1E-32, 1E-33, 1E-34, 1E-35, 1E-36, 1E-37, 1E-38, 1E-39, 1E-40, 1E-41, 1E-42, 1E-43, 1E-44, 1E-45, 1E-46, 1E-47, 1E-48, 1E-49, 1E-50, 1E-51, 1E-52, 1E-53, 1E-54, 1E-55, 1E-56, 1E-57, 1E-58, 1E-59, 1E-60, 1E-61, 1E-62, 1E-63, 1E-64, 1E-65, 1E-66, 1E-67, 1E-68, 1E-69, 1E-70, 1E-71, 1E-72, 1E-73, 1E-74, 1E-75, 1E-76, 1E-77, 1E-78, 1E-79, 1E-80, 1E-81, 1E-82, 1E-83, 1E-84, 1E-85, 1E-86, 1E-87, 1E-88, 1E-89, 1E-90, 1E-91, 1E-92, 1E-93, 1E-94, 1E-95, 1E-96, 1E-97, 1E-98, 1E-99,\r\n                        1E-100, 1E-101, 1E-102, 1E-103, 1E-104, 1E-105, 1E-106, 1E-107, 1E-108, 1E-109, 1E-110, 1E-111, 1E-112, 1E-113, 1E-114, 1E-115, 1E-116, 1E-117, 1E-118, 1E-119, 1E-120, 1E-121, 1E-122, 1E-123, 1E-124, 1E-125, 1E-126, 1E-127, 1E-128, 1E-129, 1E-130, 1E-131, 1E-132, 1E-133, 1E-134, 1E-135, 1E-136, 1E-137, 1E-138, 1E-139, 1E-140, 1E-141, 1E-142, 1E-143, 1E-144, 1E-145, 1E-146, 1E-147, 1E-148, 1E-149, 1E-150, 1E-151, 1E-152, 1E-153, 1E-154, 1E-155, 1E-156, 1E-157, 1E-158, 1E-159, 1E-160, 1E-161, 1E-162, 1E-163, 1E-164, 1E-165, 1E-166, 1E-167, 1E-168, 1E-169, 1E-170, 1E-171, 1E-172, 1E-173, 1E-174, 1E-175, 1E-176, 1E-177, 1E-178, 1E-179, 1E-180, 1E-181, 1E-182, 1E-183, 1E-184, 1E-185, 1E-186, 1E-187, 1E-188, 1E-189, 1E-190, 1E-191, 1E-192, 1E-193, 1E-194, 1E-195, 1E-196, 1E-197, 1E-198, 1E-199,\r\n                        1E-200, 1E-201, 1E-202, 1E-203, 1E-204, 1E-205, 1E-206, 1E-207, 1E-208, 1E-209, 1E-210, 1E-211, 1E-212, 1E-213, 1E-214, 1E-215, 1E-216, 1E-217, 1E-218, 1E-219, 1E-220, 1E-221, 1E-222, 1E-223, 1E-224, 1E-225, 1E-226, 1E-227, 1E-228, 1E-229, 1E-230, 1E-231, 1E-232, 1E-233, 1E-234, 1E-235, 1E-236, 1E-237, 1E-238, 1E-239, 1E-240, 1E-241, 1E-242, 1E-243, 1E-244, 1E-245, 1E-246, 1E-247, 1E-248, 1E-249, 1E-250, 1E-251, 1E-252, 1E-253, 1E-254, 1E-255, 1E-256, 1E-257, 1E-258, 1E-259, 1E-260, 1E-261, 1E-262, 1E-263, 1E-264, 1E-265, 1E-266, 1E-267, 1E-268, 1E-269, 1E-270, 1E-271, 1E-272, 1E-273, 1E-274, 1E-275, 1E-276, 1E-277, 1E-278, 1E-279, 1E-280, 1E-281, 1E-282, 1E-283, 1E-284, 1E-285, 1E-286, 1E-287, 1E-288, 1E-289, 1E-290, 1E-291, 1E-292, 1E-293, 1E-294, 1E-295, 1E-296, 1E-297, 1E-298, 1E-299,\r\n                        1E-300, 1E-301, 1E-302, 1E-303, 1E-304, 1E-305, 1E-306, 1E-307, 1E-308, 1E-309, 1E-310, 1E-311, 1E-312, 1E-313, 1E-314, 1E-315, 1E-316, 1E-317, 1E-318, 1E-319, 1E-320, 1E-321, 1E-322, 1E-323, 1E-324\r\n                    ];\r\n                    /**\r\n                     * Returns powers of 10.\r\n                     * Unlike the Math.pow this function produces no decimal garbage.\r\n                     * @param exp Exponent.\r\n                     */\r\n                    function pow10(exp) {\r\n                        // Positive & zero\r\n                        if (exp >= 0) {\r\n                            if (exp < Double.POSITIVE_POWERS.length) {\r\n                                return Double.POSITIVE_POWERS[exp];\r\n                            }\r\n                            else {\r\n                                return Infinity;\r\n                            }\r\n                        }\r\n                        // Negative\r\n                        exp = -exp;\r\n                        if (exp > 0 && exp < Double.NEGATIVE_POWERS.length) {\r\n                            return Double.NEGATIVE_POWERS[exp];\r\n                        }\r\n                        else {\r\n                            return 0;\r\n                        }\r\n                    }\r\n                    Double.pow10 = pow10;\r\n                    /**\r\n                     * Returns the 10 base logarithm of the number.\r\n                     * Unlike Math.log function this produces integer results with no decimal garbage.\r\n                     * @param val Positive value or zero.\r\n                     */\r\n                    function log10(val) {\r\n                        // Fast Log10() algorithm\r\n                        if (val > 1 && val < 1E16) {\r\n                            if (val < 1E8) {\r\n                                if (val < 1E4) {\r\n                                    if (val < 1E2) {\r\n                                        if (val < 1E1) {\r\n                                            return 0;\r\n                                        }\r\n                                        else {\r\n                                            return 1;\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        if (val < 1E3) {\r\n                                            return 2;\r\n                                        }\r\n                                        else {\r\n                                            return 3;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    if (val < 1E6) {\r\n                                        if (val < 1E5) {\r\n                                            return 4;\r\n                                        }\r\n                                        else {\r\n                                            return 5;\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        if (val < 1E7) {\r\n                                            return 6;\r\n                                        }\r\n                                        else {\r\n                                            return 7;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                if (val < 1E12) {\r\n                                    if (val < 1E10) {\r\n                                        if (val < 1E9) {\r\n                                            return 8;\r\n                                        }\r\n                                        else {\r\n                                            return 9;\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        if (val < 1E11) {\r\n                                            return 10;\r\n                                        }\r\n                                        else {\r\n                                            return 11;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    if (val < 1E14) {\r\n                                        if (val < 1E13) {\r\n                                            return 12;\r\n                                        }\r\n                                        else {\r\n                                            return 13;\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        if (val < 1E15) {\r\n                                            return 14;\r\n                                        }\r\n                                        else {\r\n                                            return 15;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        if (val > 1E-16 && val < 1) {\r\n                            if (val < 1E-8) {\r\n                                if (val < 1E-12) {\r\n                                    if (val < 1E-14) {\r\n                                        if (val < 1E-15) {\r\n                                            return -16;\r\n                                        }\r\n                                        else {\r\n                                            return -15;\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        if (val < 1E-13) {\r\n                                            return -14;\r\n                                        }\r\n                                        else {\r\n                                            return -13;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    if (val < 1E-10) {\r\n                                        if (val < 1E-11) {\r\n                                            return -12;\r\n                                        }\r\n                                        else {\r\n                                            return -11;\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        if (val < 1E-9) {\r\n                                            return -10;\r\n                                        }\r\n                                        else {\r\n                                            return -9;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                if (val < 1E-4) {\r\n                                    if (val < 1E-6) {\r\n                                        if (val < 1E-7) {\r\n                                            return -8;\r\n                                        }\r\n                                        else {\r\n                                            return -7;\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        if (val < 1E-5) {\r\n                                            return -6;\r\n                                        }\r\n                                        else {\r\n                                            return -5;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    if (val < 1E-2) {\r\n                                        if (val < 1E-3) {\r\n                                            return -4;\r\n                                        }\r\n                                        else {\r\n                                            return -3;\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        if (val < 1E-1) {\r\n                                            return -2;\r\n                                        }\r\n                                        else {\r\n                                            return -1;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        // JS Math provides only natural log function so we need to calc the 10 base logarithm:\r\n                        // logb(x) = logk(x)/logk(b);\r\n                        var log10 = Math.log(val) / Double.LOG_E_10;\r\n                        return Double.floorWithPrecision(log10);\r\n                    }\r\n                    Double.log10 = log10;\r\n                    /**\r\n                     * Returns a power of 10 representing precision of the number based on the number of meaningful decimal digits.\r\n                     * For example the precision of 56,263.3767 with the 6 meaningful decimal digit is 0.1.\r\n                     * @param x Value.\r\n                     * @param decimalDigits How many decimal digits are meaningfull.\r\n                     */\r\n                    function getPrecision(x, decimalDigits) {\r\n                        if (decimalDigits === undefined) {\r\n                            decimalDigits = Double.DEFAULT_PRECISION_IN_DECIMAL_DIGITS;\r\n                        }\r\n                        if (!x || !isFinite(x)) {\r\n                            return undefined;\r\n                        }\r\n                        var exp = Double.log10(Math.abs(x));\r\n                        if (exp < Double.MIN_EXP) {\r\n                            return 0;\r\n                        }\r\n                        var precisionExp = Math.max(exp - decimalDigits, -Double.NEGATIVE_POWERS.length + 1);\r\n                        return Double.pow10(precisionExp);\r\n                    }\r\n                    Double.getPrecision = getPrecision;\r\n                    /**\r\n                     * Checks if a delta between 2 numbers is less than provided precision.\r\n                     * @param x One value.\r\n                     * @param y Another value.\r\n                     * @param precision Precision value.\r\n                     */\r\n                    function equalWithPrecision(x, y, precision) {\r\n                        precision = detectPrecision(precision, x, y);\r\n                        return x === y || Math.abs(x - y) < precision;\r\n                    }\r\n                    Double.equalWithPrecision = equalWithPrecision;\r\n                    /**\r\n                     * Checks if a first value is less than another taking\r\n                     * into account the loose precision based equality.\r\n                     * @param x One value.\r\n                     * @param y Another value.\r\n                     * @param precision Precision value.\r\n                     */\r\n                    function lessWithPrecision(x, y, precision) {\r\n                        precision = detectPrecision(precision, x, y);\r\n                        return x < y && Math.abs(x - y) > precision;\r\n                    }\r\n                    Double.lessWithPrecision = lessWithPrecision;\r\n                    /**\r\n                     * Checks if a first value is less or equal than another taking\r\n                     * into account the loose precision based equality.\r\n                     * @param x One value.\r\n                     * @param y Another value.\r\n                     * @param precision Precision value.\r\n                     */\r\n                    function lessOrEqualWithPrecision(x, y, precision) {\r\n                        precision = detectPrecision(precision, x, y);\r\n                        return x < y || Math.abs(x - y) < precision;\r\n                    }\r\n                    Double.lessOrEqualWithPrecision = lessOrEqualWithPrecision;\r\n                    /**\r\n                     * Checks if a first value is greater than another taking\r\n                     * into account the loose precision based equality.\r\n                     * @param x One value.\r\n                     * @param y Another value.\r\n                     * @param precision Precision value.\r\n                     */\r\n                    function greaterWithPrecision(x, y, precision) {\r\n                        precision = detectPrecision(precision, x, y);\r\n                        return x > y && Math.abs(x - y) > precision;\r\n                    }\r\n                    Double.greaterWithPrecision = greaterWithPrecision;\r\n                    /**\r\n                     * Checks if a first value is greater or equal to another taking\r\n                     * into account the loose precision based equality.\r\n                     * @param x One value.\r\n                     * @param y Another value.\r\n                     * @param precision Precision value.\r\n                     */\r\n                    function greaterOrEqualWithPrecision(x, y, precision) {\r\n                        precision = detectPrecision(precision, x, y);\r\n                        return x > y || Math.abs(x - y) < precision;\r\n                    }\r\n                    Double.greaterOrEqualWithPrecision = greaterOrEqualWithPrecision;\r\n                    /**\r\n                     * Floors the number unless it's withing the precision distance from the higher int.\r\n                     * @param x One value.\r\n                     * @param precision Precision value.\r\n                     */\r\n                    function floorWithPrecision(x, precision) {\r\n                        precision = precision != null ? precision : Double.DEFAULT_PRECISION;\r\n                        var roundX = Math.round(x);\r\n                        if (Math.abs(x - roundX) < precision) {\r\n                            return roundX;\r\n                        }\r\n                        else {\r\n                            return Math.floor(x);\r\n                        }\r\n                    }\r\n                    Double.floorWithPrecision = floorWithPrecision;\r\n                    /**\r\n                     * Ceils the number unless it's withing the precision distance from the lower int.\r\n                     * @param x One value.\r\n                     * @param precision Precision value.\r\n                     */\r\n                    function ceilWithPrecision(x, precision) {\r\n                        precision = detectPrecision(precision, Double.DEFAULT_PRECISION);\r\n                        var roundX = Math.round(x);\r\n                        if (Math.abs(x - roundX) < precision) {\r\n                            return roundX;\r\n                        }\r\n                        else {\r\n                            return Math.ceil(x);\r\n                        }\r\n                    }\r\n                    Double.ceilWithPrecision = ceilWithPrecision;\r\n                    /**\r\n                     * Floors the number to the provided precision.\r\n                     * For example 234,578 floored to 1,000 precision is 234,000.\r\n                     * @param x One value.\r\n                     * @param precision Precision value.\r\n                     */\r\n                    function floorToPrecision(x, precision) {\r\n                        precision = detectPrecision(precision, Double.DEFAULT_PRECISION);\r\n                        if (precision === 0 || x === 0) {\r\n                            return x;\r\n                        }\r\n                        // Precision must be a Power of 10\r\n                        return Math.floor(x / precision) * precision;\r\n                    }\r\n                    Double.floorToPrecision = floorToPrecision;\r\n                    /**\r\n                     * Ceils the number to the provided precision.\r\n                     * For example 234,578 floored to 1,000 precision is 235,000.\r\n                     * @param x One value.\r\n                     * @param precision Precision value.\r\n                     */\r\n                    function ceilToPrecision(x, precision) {\r\n                        precision = detectPrecision(precision, Double.DEFAULT_PRECISION);\r\n                        if (precision === 0 || x === 0) {\r\n                            return x;\r\n                        }\r\n                        // Precision must be a Power of 10\r\n                        return Math.ceil(x / precision) * precision;\r\n                    }\r\n                    Double.ceilToPrecision = ceilToPrecision;\r\n                    /**\r\n                     * Rounds the number to the provided precision.\r\n                     * For example 234,578 floored to 1,000 precision is 235,000.\r\n                     * @param x One value.\r\n                     * @param precision Precision value.\r\n                     */\r\n                    function roundToPrecision(x, precision) {\r\n                        precision = detectPrecision(precision, Double.DEFAULT_PRECISION);\r\n                        if (precision === 0 || x === 0) {\r\n                            return x;\r\n                        }\r\n                        // Precision must be a Power of 10\r\n                        var result = Math.round(x / precision) * precision;\r\n                        var decimalDigits = Math.round(Double.log10(Math.abs(x)) - Double.log10(precision)) + 1;\r\n                        if (decimalDigits > 0 && decimalDigits < 16) {\r\n                            result = parseFloat(result.toPrecision(decimalDigits));\r\n                        }\r\n                        return result;\r\n                    }\r\n                    Double.roundToPrecision = roundToPrecision;\r\n                    /**\r\n                     * Returns the value making sure that it's restricted to the provided range.\r\n                     * @param x One value.\r\n                     * @param min Range min boundary.\r\n                     * @param max Range max boundary.\r\n                     */\r\n                    function ensureInRange(x, min, max) {\r\n                        if (x === undefined || x === null) {\r\n                            return x;\r\n                        }\r\n                        if (x < min) {\r\n                            return min;\r\n                        }\r\n                        if (x > max) {\r\n                            return max;\r\n                        }\r\n                        return x;\r\n                    }\r\n                    Double.ensureInRange = ensureInRange;\r\n                    /**\r\n                     * Rounds the value - this method is actually faster than Math.round - used in the graphics utils.\r\n                     * @param x Value to round.\r\n                     */\r\n                    function round(x) {\r\n                        return (0.5 + x) << 0;\r\n                    }\r\n                    Double.round = round;\r\n                    /**\r\n                     * Projects the value from the source range into the target range.\r\n                     * @param value Value to project.\r\n                     * @param fromMin Minimum of the source range.\r\n                     * @param toMin Minimum of the target range.\r\n                     * @param toMax Maximum of the target range.\r\n                     */\r\n                    function project(value, fromMin, fromSize, toMin, toSize) {\r\n                        if (fromSize === 0 || toSize === 0) {\r\n                            if (fromMin <= value && value <= fromMin + fromSize) {\r\n                                return toMin;\r\n                            }\r\n                            else {\r\n                                return NaN;\r\n                            }\r\n                        }\r\n                        var relativeX = (value - fromMin) / fromSize;\r\n                        var projectedX = toMin + relativeX * toSize;\r\n                        return projectedX;\r\n                    }\r\n                    Double.project = project;\r\n                    /**\r\n                     * Removes decimal noise.\r\n                     * @param value Value to be processed.\r\n                     */\r\n                    function removeDecimalNoise(value) {\r\n                        return roundToPrecision(value, getPrecision(value));\r\n                    }\r\n                    Double.removeDecimalNoise = removeDecimalNoise;\r\n                    /**\r\n                     * Checks whether the number is integer.\r\n                     * @param value Value to be checked.\r\n                     */\r\n                    function isInteger(value) {\r\n                        return value !== null && value % 1 === 0;\r\n                    }\r\n                    Double.isInteger = isInteger;\r\n                    /**\r\n                     * Dividing by increment will give us count of increments\r\n                     * Round out the rough edges into even integer\r\n                     * Multiply back by increment to get rounded value\r\n                     * e.g. Rounder.toIncrement(0.647291, 0.05) => 0.65\r\n                     * @param value - value to round to nearest increment\r\n                     * @param increment - smallest increment to round toward\r\n                     */\r\n                    function toIncrement(value, increment) {\r\n                        return Math.round(value / increment) * increment;\r\n                    }\r\n                    Double.toIncrement = toIncrement;\r\n                    /**\r\n                     * Overrides the given precision with defaults if necessary. Exported only for tests\r\n                     *\r\n                     * precision defined returns precision\r\n                     * x defined with y undefined returns twelve digits of precision based on x\r\n                     * x defined but zero with y defined; returns twelve digits of precision based on y\r\n                     * x and y defined retursn twelve digits of precision based on the minimum of the two\r\n                     * if no applicable precision is found based on those (such as x and y being zero), the default precision is used\r\n                     */\r\n                    function detectPrecision(precision, x, y) {\r\n                        if (precision !== undefined) {\r\n                            return precision;\r\n                        }\r\n                        var calculatedPrecision;\r\n                        if (!y) {\r\n                            calculatedPrecision = Double.getPrecision(x);\r\n                        }\r\n                        else if (!x) {\r\n                            calculatedPrecision = Double.getPrecision(y);\r\n                        }\r\n                        else {\r\n                            calculatedPrecision = Double.getPrecision(Math.min(Math.abs(x), Math.abs(y)));\r\n                        }\r\n                        return calculatedPrecision || Double.DEFAULT_PRECISION;\r\n                    }\r\n                    Double.detectPrecision = detectPrecision;\r\n                })(Double = type.Double || (type.Double = {}));\r\n            })(type = utils.type || (utils.type = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var type;\r\n            (function (type) {\r\n                var Prototype;\r\n                (function (Prototype) {\r\n                    /**\r\n                     * Returns a new object with the provided obj as its prototype.\r\n                     */\r\n                    function inherit(obj, extension) {\r\n                        function wrapCtor() { }\r\n                        wrapCtor.prototype = obj;\r\n                        var inherited = new wrapCtor();\r\n                        if (extension)\r\n                            extension(inherited);\r\n                        return inherited;\r\n                    }\r\n                    Prototype.inherit = inherit;\r\n                    /**\r\n                     * Returns a new object with the provided obj as its prototype\r\n                     * if, and only if, the prototype has not been previously set\r\n                     */\r\n                    function inheritSingle(obj) {\r\n                        var proto = Object.getPrototypeOf(obj);\r\n                        if (proto === Object.prototype || proto === Array.prototype)\r\n                            obj = inherit(obj);\r\n                        return obj;\r\n                    }\r\n                    Prototype.inheritSingle = inheritSingle;\r\n                    /**\r\n                     * Uses the provided callback function to selectively replace contents in the provided array.\r\n                     * @return A new array with those values overriden\r\n                     * or undefined if no overrides are necessary.\r\n                     */\r\n                    function overrideArray(prototype, override) {\r\n                        if (!prototype)\r\n                            return;\r\n                        var overwritten;\r\n                        for (var i = 0, len = prototype.length; i < len; i++) {\r\n                            var value = override(prototype[i]);\r\n                            if (value) {\r\n                                if (!overwritten)\r\n                                    overwritten = inherit(prototype);\r\n                                overwritten[i] = value;\r\n                            }\r\n                        }\r\n                        return overwritten;\r\n                    }\r\n                    Prototype.overrideArray = overrideArray;\r\n                })(Prototype = type.Prototype || (type.Prototype = {}));\r\n            })(type = utils.type || (utils.type = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var type;\r\n            (function (type) {\r\n                var ArrayExtensions;\r\n                (function (ArrayExtensions) {\r\n                    /**\r\n                     * Returns items that exist in target and other.\r\n                     */\r\n                    function intersect(target, other) {\r\n                        var result = [];\r\n                        for (var i = target.length - 1; i >= 0; --i) {\r\n                            if (other.indexOf(target[i]) !== -1) {\r\n                                result.push(target[i]);\r\n                            }\r\n                        }\r\n                        return result;\r\n                    }\r\n                    ArrayExtensions.intersect = intersect;\r\n                    /**\r\n                     * Return elements exists in target but not exists in other.\r\n                     */\r\n                    function diff(target, other) {\r\n                        var result = [];\r\n                        for (var i = target.length - 1; i >= 0; --i) {\r\n                            var value = target[i];\r\n                            if (other.indexOf(value) === -1) {\r\n                                result.push(value);\r\n                            }\r\n                        }\r\n                        return result;\r\n                    }\r\n                    ArrayExtensions.diff = diff;\r\n                    /**\r\n                     * Return an array with only the distinct items in the source.\r\n                     */\r\n                    function distinct(source) {\r\n                        var result = [];\r\n                        for (var i = 0, len = source.length; i < len; i++) {\r\n                            var value = source[i];\r\n                            if (result.indexOf(value) === -1) {\r\n                                result.push(value);\r\n                            }\r\n                        }\r\n                        return result;\r\n                    }\r\n                    ArrayExtensions.distinct = distinct;\r\n                    /**\r\n                     * Pushes content of source onto target,\r\n                     * for parts of course that do not already exist in target.\r\n                     */\r\n                    function union(target, source) {\r\n                        for (var i = 0, len = source.length; i < len; ++i) {\r\n                            unionSingle(target, source[i]);\r\n                        }\r\n                    }\r\n                    ArrayExtensions.union = union;\r\n                    /**\r\n                     * Pushes value onto target, if value does not already exist in target.\r\n                     */\r\n                    function unionSingle(target, value) {\r\n                        if (target.indexOf(value) < 0) {\r\n                            target.push(value);\r\n                        }\r\n                    }\r\n                    ArrayExtensions.unionSingle = unionSingle;\r\n                    /**\r\n                     * Returns an array with a range of items from source,\r\n                     * including the startIndex & endIndex.\r\n                     */\r\n                    function range(source, startIndex, endIndex) {\r\n                        var result = [];\r\n                        for (var i = startIndex; i <= endIndex; ++i) {\r\n                            result.push(source[i]);\r\n                        }\r\n                        return result;\r\n                    }\r\n                    ArrayExtensions.range = range;\r\n                    /**\r\n                     * Returns an array that includes items from source, up to the specified count.\r\n                     */\r\n                    function take(source, count) {\r\n                        var result = [];\r\n                        for (var i = 0; i < count; ++i) {\r\n                            result.push(source[i]);\r\n                        }\r\n                        return result;\r\n                    }\r\n                    ArrayExtensions.take = take;\r\n                    function copy(source) {\r\n                        return take(source, source.length);\r\n                    }\r\n                    ArrayExtensions.copy = copy;\r\n                    /**\r\n                      * Returns a value indicating whether the arrays have the same values in the same sequence.\r\n                      */\r\n                    function sequenceEqual(left, right, comparison) {\r\n                        // Normalize falsy to null\r\n                        if (!left) {\r\n                            left = null;\r\n                        }\r\n                        if (!right) {\r\n                            right = null;\r\n                        }\r\n                        // T can be same as U, and it is possible for left and right to be the same array object...\r\n                        if (left === right) {\r\n                            return true;\r\n                        }\r\n                        if (!!left !== !!right) {\r\n                            return false;\r\n                        }\r\n                        var len = left.length;\r\n                        if (len !== right.length) {\r\n                            return false;\r\n                        }\r\n                        var i = 0;\r\n                        while (i < len && comparison(left[i], right[i])) {\r\n                            ++i;\r\n                        }\r\n                        return i === len;\r\n                    }\r\n                    ArrayExtensions.sequenceEqual = sequenceEqual;\r\n                    /**\r\n                     * Returns null if the specified array is empty.\r\n                     * Otherwise returns the specified array.\r\n                     */\r\n                    function emptyToNull(array) {\r\n                        if (array && array.length === 0) {\r\n                            return null;\r\n                        }\r\n                        return array;\r\n                    }\r\n                    ArrayExtensions.emptyToNull = emptyToNull;\r\n                    function indexOf(array, predicate) {\r\n                        for (var i = 0, len = array.length; i < len; ++i) {\r\n                            if (predicate(array[i])) {\r\n                                return i;\r\n                            }\r\n                        }\r\n                        return -1;\r\n                    }\r\n                    ArrayExtensions.indexOf = indexOf;\r\n                    /**\r\n                     * Returns a copy of the array rotated by the specified offset.\r\n                     */\r\n                    function rotate(array, offset) {\r\n                        if (offset === 0)\r\n                            return array.slice();\r\n                        var rotated = array.slice(offset);\r\n                        Array.prototype.push.apply(rotated, array.slice(0, offset));\r\n                        return rotated;\r\n                    }\r\n                    ArrayExtensions.rotate = rotate;\r\n                    function createWithId() {\r\n                        return extendWithId([]);\r\n                    }\r\n                    ArrayExtensions.createWithId = createWithId;\r\n                    function extendWithId(array) {\r\n                        var extended = array;\r\n                        extended.withId = withId;\r\n                        return extended;\r\n                    }\r\n                    ArrayExtensions.extendWithId = extendWithId;\r\n                    /**\r\n                     * Finds and returns the first item with a matching ID.\r\n                     */\r\n                    function findWithId(array, id) {\r\n                        for (var i = 0, len = array.length; i < len; i++) {\r\n                            var item = array[i];\r\n                            if (item.id === id)\r\n                                return item;\r\n                        }\r\n                    }\r\n                    ArrayExtensions.findWithId = findWithId;\r\n                    function withId(id) {\r\n                        return ArrayExtensions.findWithId(this, id);\r\n                    }\r\n                    function createWithName() {\r\n                        return extendWithName([]);\r\n                    }\r\n                    ArrayExtensions.createWithName = createWithName;\r\n                    function extendWithName(array) {\r\n                        var extended = array;\r\n                        extended.withName = withName;\r\n                        return extended;\r\n                    }\r\n                    ArrayExtensions.extendWithName = extendWithName;\r\n                    function findItemWithName(array, name) {\r\n                        var index = indexWithName(array, name);\r\n                        if (index >= 0)\r\n                            return array[index];\r\n                    }\r\n                    ArrayExtensions.findItemWithName = findItemWithName;\r\n                    function indexWithName(array, name) {\r\n                        for (var i = 0, len = array.length; i < len; i++) {\r\n                            var item = array[i];\r\n                            if (item.name === name)\r\n                                return i;\r\n                        }\r\n                        return -1;\r\n                    }\r\n                    ArrayExtensions.indexWithName = indexWithName;\r\n                    /**\r\n                     * Inserts a number in sorted order into a list of numbers already in sorted order.\r\n                     * @returns True if the item was added, false if it already existed.\r\n                     */\r\n                    function insertSorted(list, value) {\r\n                        var len = list.length;\r\n                        // NOTE: iterate backwards because incoming values tend to be sorted already.\r\n                        for (var i = len - 1; i >= 0; i--) {\r\n                            var diff_1 = list[i] - value;\r\n                            if (diff_1 === 0)\r\n                                return false;\r\n                            if (diff_1 > 0)\r\n                                continue;\r\n                            // diff < 0\r\n                            list.splice(i + 1, 0, value);\r\n                            return true;\r\n                        }\r\n                        list.unshift(value);\r\n                        return true;\r\n                    }\r\n                    ArrayExtensions.insertSorted = insertSorted;\r\n                    /**\r\n                     * Removes the first occurrence of a value from a list if it exists.\r\n                     * @returns True if the value was removed, false if it did not exist in the list.\r\n                     */\r\n                    function removeFirst(list, value) {\r\n                        var index = list.indexOf(value);\r\n                        if (index < 0)\r\n                            return false;\r\n                        list.splice(index, 1);\r\n                        return true;\r\n                    }\r\n                    ArrayExtensions.removeFirst = removeFirst;\r\n                    /**\r\n                     * Finds and returns the first item with a matching name.\r\n                     */\r\n                    function withName(name) {\r\n                        var array = this;\r\n                        return findItemWithName(array, name);\r\n                    }\r\n                    /**\r\n                     * Deletes all items from the array.\r\n                     */\r\n                    function clear(array) {\r\n                        if (!array)\r\n                            return;\r\n                        while (array.length > 0)\r\n                            array.pop();\r\n                    }\r\n                    ArrayExtensions.clear = clear;\r\n                    function isUndefinedOrEmpty(array) {\r\n                        if (!array || array.length === 0) {\r\n                            return true;\r\n                        }\r\n                        return false;\r\n                    }\r\n                    ArrayExtensions.isUndefinedOrEmpty = isUndefinedOrEmpty;\r\n                    function swap(array, firstIndex, secondIndex) {\r\n                        var temp = array[firstIndex];\r\n                        array[firstIndex] = array[secondIndex];\r\n                        array[secondIndex] = temp;\r\n                    }\r\n                    ArrayExtensions.swap = swap;\r\n                    function isInArray(array, lookupItem, compareCallback) {\r\n                        return array.some(function (item) { return compareCallback(item, lookupItem); });\r\n                    }\r\n                    ArrayExtensions.isInArray = isInArray;\r\n                    /** Checks if the given object is an Array, and looking all the way up the prototype chain. */\r\n                    function isArrayOrInheritedArray(obj) {\r\n                        var nextPrototype = obj;\r\n                        while (nextPrototype != null) {\r\n                            if (Array.isArray(nextPrototype))\r\n                                return true;\r\n                            nextPrototype = Object.getPrototypeOf(nextPrototype);\r\n                        }\r\n                        return false;\r\n                    }\r\n                    ArrayExtensions.isArrayOrInheritedArray = isArrayOrInheritedArray;\r\n                    /**\r\n                     * Returns true if the specified values array is sorted in an order as determined by the specified compareFunction.\r\n                     */\r\n                    function isSorted(values, compareFunction) {\r\n                        var ilen = values.length;\r\n                        if (ilen >= 2) {\r\n                            for (var i = 1; i < ilen; i++) {\r\n                                if (compareFunction(values[i - 1], values[i]) > 0) {\r\n                                    return false;\r\n                                }\r\n                            }\r\n                        }\r\n                        return true;\r\n                    }\r\n                    ArrayExtensions.isSorted = isSorted;\r\n                    /**\r\n                     * Returns true if the specified number values array is sorted in ascending order\r\n                     * (or descending order if the specified descendingOrder is truthy).\r\n                     */\r\n                    function isSortedNumeric(values, descendingOrder) {\r\n                        var compareFunction = descendingOrder ?\r\n                            function (a, b) { return b - a; } :\r\n                            function (a, b) { return a - b; };\r\n                        return isSorted(values, compareFunction);\r\n                    }\r\n                    ArrayExtensions.isSortedNumeric = isSortedNumeric;\r\n                    /**\r\n                     * Ensures that the given T || T[] is in array form, either returning the array or\r\n                     * converting single items into an array of length one.\r\n                     */\r\n                    function ensureArray(value) {\r\n                        if (Array.isArray(value)) {\r\n                            return value;\r\n                        }\r\n                        return [value];\r\n                    }\r\n                    ArrayExtensions.ensureArray = ensureArray;\r\n                })(ArrayExtensions = type.ArrayExtensions || (type.ArrayExtensions = {}));\r\n            })(type = utils.type || (utils.type = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var type;\r\n            (function (type) {\r\n                // NOTE: this file includes standalone utilities that should have no dependencies on external libraries, including jQuery.\r\n                var Double = powerbi.extensibility.utils.type.Double;\r\n                /**\r\n                 * Extensions for Enumerations.\r\n                 */\r\n                var EnumExtensions;\r\n                (function (EnumExtensions) {\r\n                    /**\r\n                     * Gets a value indicating whether the value has the bit flags set.\r\n                     */\r\n                    function hasFlag(value, flag) {\r\n                        return (value & flag) === flag;\r\n                    }\r\n                    EnumExtensions.hasFlag = hasFlag;\r\n                    /**\r\n                     * Sets a value of a flag without modifying any other flags.\r\n                     */\r\n                    function setFlag(value, flag) {\r\n                        return value |= flag;\r\n                    }\r\n                    EnumExtensions.setFlag = setFlag;\r\n                    /**\r\n                     * Resets a value of a flag without modifying any other flags.\r\n                     */\r\n                    function resetFlag(value, flag) {\r\n                        return value &= ~flag;\r\n                    }\r\n                    EnumExtensions.resetFlag = resetFlag;\r\n                    /**\r\n                     * According to the TypeScript Handbook, this is safe to do.\r\n                     */\r\n                    function toString(enumType, value) {\r\n                        return enumType[value];\r\n                    }\r\n                    EnumExtensions.toString = toString;\r\n                    /**\r\n                     * Returns the number of 1's in the specified value that is a set of binary bit flags.\r\n                     */\r\n                    function getBitCount(value) {\r\n                        if (!Double.isInteger(value))\r\n                            return 0;\r\n                        var bitCount = 0;\r\n                        var shiftingValue = value;\r\n                        while (shiftingValue !== 0) {\r\n                            if ((shiftingValue & 1) === 1) {\r\n                                bitCount++;\r\n                            }\r\n                            shiftingValue = shiftingValue >>> 1;\r\n                        }\r\n                        return bitCount;\r\n                    }\r\n                    EnumExtensions.getBitCount = getBitCount;\r\n                })(EnumExtensions = type.EnumExtensions || (type.EnumExtensions = {}));\r\n            })(type = utils.type || (utils.type = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var type;\r\n            (function (type) {\r\n                var Double = powerbi.extensibility.utils.type.Double;\r\n                var NumericSequenceRange = (function () {\r\n                    function NumericSequenceRange() {\r\n                    }\r\n                    NumericSequenceRange.prototype._ensureIncludeZero = function () {\r\n                        if (this.includeZero) {\r\n                            // fixed min and max has higher priority than includeZero\r\n                            if (this.min > 0 && !this.hasFixedMin) {\r\n                                this.min = 0;\r\n                            }\r\n                            if (this.max < 0 && !this.hasFixedMax) {\r\n                                this.max = 0;\r\n                            }\r\n                        }\r\n                    };\r\n                    NumericSequenceRange.prototype._ensureNotEmpty = function () {\r\n                        if (this.min === this.max) {\r\n                            if (!this.min) {\r\n                                this.min = 0;\r\n                                this.max = NumericSequenceRange.DEFAULT_MAX;\r\n                                this.hasFixedMin = true;\r\n                                this.hasFixedMax = true;\r\n                            }\r\n                            else {\r\n                                // We are dealing with a single data value (includeZero is not set)\r\n                                // In order to fix the range we need to extend it in both directions by half of the interval.\r\n                                // Interval is calculated based on the number:\r\n                                // 1. Integers below 10,000 are extended by 0.5: so the [2006-2006] empty range is extended to [2005.5-2006.5] range and the ForsedSingleStop=2006\r\n                                // 2. Other numbers are extended by half of their power: [700,001-700,001] => [650,001-750,001] and the ForsedSingleStop=null as we want the intervals to be calculated to cover the range.\r\n                                var value = this.min;\r\n                                var exp = Double.log10(Math.abs(value));\r\n                                var step = void 0;\r\n                                if (exp >= 0 && exp < 4) {\r\n                                    step = 0.5;\r\n                                    this.forcedSingleStop = value;\r\n                                }\r\n                                else {\r\n                                    step = Double.pow10(exp) / 2;\r\n                                    this.forcedSingleStop = null;\r\n                                }\r\n                                this.min = value - step;\r\n                                this.max = value + step;\r\n                            }\r\n                        }\r\n                    };\r\n                    NumericSequenceRange.prototype._ensureDirection = function () {\r\n                        if (this.min > this.max) {\r\n                            var temp = this.min;\r\n                            this.min = this.max;\r\n                            this.max = temp;\r\n                        }\r\n                    };\r\n                    NumericSequenceRange.prototype.getSize = function () {\r\n                        return this.max - this.min;\r\n                    };\r\n                    NumericSequenceRange.prototype.shrinkByStep = function (range, step) {\r\n                        var oldCount = this.min / step;\r\n                        var newCount = range.min / step;\r\n                        var deltaCount = Math.floor(newCount - oldCount);\r\n                        this.min += deltaCount * step;\r\n                        oldCount = this.max / step;\r\n                        newCount = range.max / step;\r\n                        deltaCount = Math.ceil(newCount - oldCount);\r\n                        this.max += deltaCount * step;\r\n                    };\r\n                    NumericSequenceRange.calculate = function (dataMin, dataMax, fixedMin, fixedMax, includeZero) {\r\n                        var result = new NumericSequenceRange();\r\n                        result.includeZero = includeZero ? true : false;\r\n                        result.hasDataRange = ValueUtil.hasValue(dataMin) && ValueUtil.hasValue(dataMax);\r\n                        result.hasFixedMin = ValueUtil.hasValue(fixedMin);\r\n                        result.hasFixedMax = ValueUtil.hasValue(fixedMax);\r\n                        dataMin = Double.ensureInRange(dataMin, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\r\n                        dataMax = Double.ensureInRange(dataMax, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\r\n                        // Calculate the range using the min, max, dataRange\r\n                        if (result.hasFixedMin && result.hasFixedMax) {\r\n                            result.min = fixedMin;\r\n                            result.max = fixedMax;\r\n                        }\r\n                        else if (result.hasFixedMin) {\r\n                            result.min = fixedMin;\r\n                            result.max = dataMax > fixedMin ? dataMax : fixedMin;\r\n                        }\r\n                        else if (result.hasFixedMax) {\r\n                            result.min = dataMin < fixedMax ? dataMin : fixedMax;\r\n                            result.max = fixedMax;\r\n                        }\r\n                        else if (result.hasDataRange) {\r\n                            result.min = dataMin;\r\n                            result.max = dataMax;\r\n                        }\r\n                        else {\r\n                            result.min = 0;\r\n                            result.max = 0;\r\n                        }\r\n                        result._ensureIncludeZero();\r\n                        result._ensureNotEmpty();\r\n                        result._ensureDirection();\r\n                        if (result.min === 0) {\r\n                            result.hasFixedMin = true; // If the range starts from zero we should prevent extending the intervals into the negative range\r\n                        }\r\n                        else if (result.max === 0) {\r\n                            result.hasFixedMax = true; // If the range ends at zero we should prevent extending the intervals into the positive range\r\n                        }\r\n                        return result;\r\n                    };\r\n                    NumericSequenceRange.calculateDataRange = function (dataMin, dataMax, includeZero) {\r\n                        if (!ValueUtil.hasValue(dataMin) || !ValueUtil.hasValue(dataMax)) {\r\n                            return NumericSequenceRange.calculateFixedRange(0, NumericSequenceRange.DEFAULT_MAX);\r\n                        }\r\n                        else {\r\n                            return NumericSequenceRange.calculate(dataMin, dataMax, null, null, includeZero);\r\n                        }\r\n                    };\r\n                    NumericSequenceRange.calculateFixedRange = function (fixedMin, fixedMax, includeZero) {\r\n                        var result = new NumericSequenceRange();\r\n                        result.hasDataRange = false;\r\n                        result.includeZero = includeZero;\r\n                        result.min = fixedMin;\r\n                        result.max = fixedMax;\r\n                        result._ensureIncludeZero();\r\n                        result._ensureNotEmpty();\r\n                        result._ensureDirection();\r\n                        result.hasFixedMin = true;\r\n                        result.hasFixedMax = true;\r\n                        return result;\r\n                    };\r\n                    return NumericSequenceRange;\r\n                }());\r\n                NumericSequenceRange.DEFAULT_MAX = 10;\r\n                NumericSequenceRange.MIN_SUPPORTED_DOUBLE = -1E307;\r\n                NumericSequenceRange.MAX_SUPPORTED_DOUBLE = 1E307;\r\n                type.NumericSequenceRange = NumericSequenceRange;\r\n                /** Note: Exported for testability */\r\n                var ValueUtil;\r\n                (function (ValueUtil) {\r\n                    function hasValue(value) {\r\n                        return value !== undefined && value !== null;\r\n                    }\r\n                    ValueUtil.hasValue = hasValue;\r\n                })(ValueUtil = type.ValueUtil || (type.ValueUtil = {}));\r\n            })(type = utils.type || (utils.type = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var type;\r\n            (function (type) {\r\n                var Double = powerbi.extensibility.utils.type.Double;\r\n                var NumericSequenceRange = powerbi.extensibility.utils.type.NumericSequenceRange;\r\n                var NumericSequence = (function () {\r\n                    function NumericSequence() {\r\n                    }\r\n                    NumericSequence.calculate = function (range, expectedCount, maxAllowedMargin, minPower, useZeroRefPoint, steps) {\r\n                        var result = new NumericSequence();\r\n                        if (expectedCount === undefined)\r\n                            expectedCount = 10;\r\n                        else\r\n                            expectedCount = Double.ensureInRange(expectedCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\r\n                        if (minPower === undefined)\r\n                            minPower = Double.MIN_EXP;\r\n                        if (useZeroRefPoint === undefined)\r\n                            useZeroRefPoint = false;\r\n                        if (maxAllowedMargin === undefined)\r\n                            maxAllowedMargin = 1;\r\n                        if (steps === undefined)\r\n                            steps = [1, 2, 5];\r\n                        // Handle single stop case\r\n                        if (range.forcedSingleStop) {\r\n                            result.interval = range.getSize();\r\n                            result.intervalOffset = result.interval - (range.forcedSingleStop - range.min);\r\n                            result.min = range.min;\r\n                            result.max = range.max;\r\n                            result.sequence = [range.forcedSingleStop];\r\n                            return result;\r\n                        }\r\n                        var interval = 0;\r\n                        var min = 0;\r\n                        var max = 9;\r\n                        var canExtendMin = maxAllowedMargin > 0 && !range.hasFixedMin;\r\n                        var canExtendMax = maxAllowedMargin > 0 && !range.hasFixedMax;\r\n                        var size = range.getSize();\r\n                        var exp = Double.log10(size);\r\n                        // Account for Exp of steps\r\n                        var stepExp = Double.log10(steps[0]);\r\n                        exp = exp - stepExp;\r\n                        // Account for MaxCount\r\n                        var expectedCountExp = Double.log10(expectedCount);\r\n                        exp = exp - expectedCountExp;\r\n                        // Account for MinPower\r\n                        exp = Math.max(exp, minPower - stepExp + 1);\r\n                        var count = undefined;\r\n                        // Create array of \"good looking\" numbers\r\n                        if (interval !== 0) {\r\n                            // If explicit interval is defined - use it instead of the steps array.\r\n                            var power = Double.pow10(exp);\r\n                            var roundMin = Double.floorToPrecision(range.min, power);\r\n                            var roundMax = Double.ceilToPrecision(range.max, power);\r\n                            var roundRange = NumericSequenceRange.calculateFixedRange(roundMin, roundMax);\r\n                            roundRange.shrinkByStep(range, interval);\r\n                            min = roundRange.min;\r\n                            max = roundRange.max;\r\n                            count = Math.floor(roundRange.getSize() / interval);\r\n                        }\r\n                        else {\r\n                            // No interval defined -> find optimal interval\r\n                            var dexp = void 0;\r\n                            for (dexp = 0; dexp < 3; dexp++) {\r\n                                var e = exp + dexp;\r\n                                var power = Double.pow10(e);\r\n                                var roundMin = Double.floorToPrecision(range.min, power);\r\n                                var roundMax = Double.ceilToPrecision(range.max, power);\r\n                                // Go throught the steps array looking for the smallest step that produces the right interval count.\r\n                                var stepsCount = steps.length;\r\n                                var stepPower = Double.pow10(e - 1);\r\n                                for (var i = 0; i < stepsCount; i++) {\r\n                                    var step = steps[i] * stepPower;\r\n                                    var roundRange = NumericSequenceRange.calculateFixedRange(roundMin, roundMax, useZeroRefPoint);\r\n                                    roundRange.shrinkByStep(range, step);\r\n                                    // If the range is based on Data we might need to extend it to provide nice data margins.\r\n                                    if (canExtendMin && range.min === roundRange.min && maxAllowedMargin >= 1)\r\n                                        roundRange.min -= step;\r\n                                    if (canExtendMax && range.max === roundRange.max && maxAllowedMargin >= 1)\r\n                                        roundRange.max += step;\r\n                                    // Count the intervals\r\n                                    count = Double.ceilWithPrecision(roundRange.getSize() / step, Double.DEFAULT_PRECISION);\r\n                                    if (count <= expectedCount || (dexp === 2 && i === stepsCount - 1) || (expectedCount === 1 && count === 2 && (step > range.getSize() || (range.min < 0 && range.max > 0 && step * 2 >= range.getSize())))) {\r\n                                        interval = step;\r\n                                        min = roundRange.min;\r\n                                        max = roundRange.max;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                // Increase the scale power until the interval is found\r\n                                if (interval !== 0)\r\n                                    break;\r\n                            }\r\n                        }\r\n                        // Avoid extreme count cases (>1000 ticks)\r\n                        if (count > expectedCount * 32 || count > NumericSequence.MAX_COUNT) {\r\n                            count = Math.min(expectedCount * 32, NumericSequence.MAX_COUNT);\r\n                            interval = (max - min) / count;\r\n                        }\r\n                        result.min = min;\r\n                        result.max = max;\r\n                        result.interval = interval;\r\n                        result.intervalOffset = min - range.min;\r\n                        result.maxAllowedMargin = maxAllowedMargin;\r\n                        result.canExtendMin = canExtendMin;\r\n                        result.canExtendMax = canExtendMax;\r\n                        // Fill in the Sequence\r\n                        var precision = Double.getPrecision(interval, 0);\r\n                        result.precision = precision;\r\n                        var sequence = [];\r\n                        var x = Double.roundToPrecision(min, precision);\r\n                        sequence.push(x);\r\n                        for (var i = 0; i < count; i++) {\r\n                            x = Double.roundToPrecision(x + interval, precision);\r\n                            sequence.push(x);\r\n                        }\r\n                        result.sequence = sequence;\r\n                        result.trimMinMax(range.min, range.max);\r\n                        return result;\r\n                    };\r\n                    /**\r\n                     * Calculates the sequence of int numbers which are mapped to the multiples of the units grid.\r\n                     * @min - The minimum of the range.\r\n                     * @max - The maximum of the range.\r\n                     * @maxCount - The max count of intervals.\r\n                     * @steps - array of intervals.\r\n                     */\r\n                    NumericSequence.calculateUnits = function (min, max, maxCount, steps) {\r\n                        // Initialization actions\r\n                        maxCount = Double.ensureInRange(maxCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\r\n                        if (min === max) {\r\n                            max = min + 1;\r\n                        }\r\n                        var stepCount = 0;\r\n                        var step = 0;\r\n                        // Calculate step\r\n                        for (var i = 0; i < steps.length; i++) {\r\n                            step = steps[i];\r\n                            var maxStepCount = Double.ceilWithPrecision(max / step);\r\n                            var minStepCount = Double.floorWithPrecision(min / step);\r\n                            stepCount = maxStepCount - minStepCount;\r\n                            if (stepCount <= maxCount) {\r\n                                break;\r\n                            }\r\n                        }\r\n                        // Calculate the offset\r\n                        var offset = -min;\r\n                        offset = offset % step;\r\n                        // Create sequence\r\n                        var result = new NumericSequence();\r\n                        result.sequence = [];\r\n                        for (var x = min + offset;; x += step) {\r\n                            result.sequence.push(x);\r\n                            if (x >= max)\r\n                                break;\r\n                        }\r\n                        result.interval = step;\r\n                        result.intervalOffset = offset;\r\n                        result.min = result.sequence[0];\r\n                        result.max = result.sequence[result.sequence.length - 1];\r\n                        return result;\r\n                    };\r\n                    NumericSequence.prototype.trimMinMax = function (min, max) {\r\n                        var minMargin = (min - this.min) / this.interval;\r\n                        var maxMargin = (this.max - max) / this.interval;\r\n                        var marginPrecision = 0.001;\r\n                        if (!this.canExtendMin || (minMargin > this.maxAllowedMargin && minMargin > marginPrecision)) {\r\n                            this.min = min;\r\n                        }\r\n                        if (!this.canExtendMax || (maxMargin > this.maxAllowedMargin && maxMargin > marginPrecision)) {\r\n                            this.max = max;\r\n                        }\r\n                    };\r\n                    return NumericSequence;\r\n                }());\r\n                NumericSequence.MIN_COUNT = 1;\r\n                NumericSequence.MAX_COUNT = 1000;\r\n                type.NumericSequence = NumericSequence;\r\n            })(type = utils.type || (utils.type = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var type;\r\n            (function (type) {\r\n                var PixelConverter;\r\n                (function (PixelConverter) {\r\n                    var PxPtRatio = 4 / 3;\r\n                    var PixelString = \"px\";\r\n                    /**\r\n                     * Appends 'px' to the end of number value for use as pixel string in styles\r\n                     */\r\n                    function toString(px) {\r\n                        return px + PixelString;\r\n                    }\r\n                    PixelConverter.toString = toString;\r\n                    /**\r\n                     * Converts point value (pt) to pixels\r\n                     * Returns a string for font-size property\r\n                     * e.g. fromPoint(8) => '24px'\r\n                     */\r\n                    function fromPoint(pt) {\r\n                        return toString(fromPointToPixel(pt));\r\n                    }\r\n                    PixelConverter.fromPoint = fromPoint;\r\n                    /**\r\n                     * Converts point value (pt) to pixels\r\n                     * Returns a number for font-size property\r\n                     * e.g. fromPoint(8) => 24px\r\n                     */\r\n                    function fromPointToPixel(pt) {\r\n                        return (PxPtRatio * pt);\r\n                    }\r\n                    PixelConverter.fromPointToPixel = fromPointToPixel;\r\n                    /**\r\n                     * Converts pixel value (px) to pt\r\n                     * e.g. toPoint(24) => 8\r\n                     */\r\n                    function toPoint(px) {\r\n                        return px / PxPtRatio;\r\n                    }\r\n                    PixelConverter.toPoint = toPoint;\r\n                })(PixelConverter = type.PixelConverter || (type.PixelConverter = {}));\r\n            })(type = utils.type || (utils.type = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var type;\r\n            (function (type) {\r\n                // NOTE: this file includes standalone utilities that should have no dependencies on external libraries, including jQuery.\r\n                var RegExpExtensions;\r\n                (function (RegExpExtensions) {\r\n                    /**\r\n                     * Runs exec on regex starting from 0 index\r\n                     * This is the expected behavior but RegExp actually remember\r\n                     * the last index they stopped at (found match at) and will\r\n                     * return unexpected results when run in sequence.\r\n                     * @param regex - regular expression object\r\n                     * @param value - string to search wiht regex\r\n                     * @param start - index within value to start regex\r\n                     */\r\n                    function run(regex, value, start) {\r\n                        regex.lastIndex = start || 0;\r\n                        return regex.exec(value);\r\n                    }\r\n                    RegExpExtensions.run = run;\r\n                })(RegExpExtensions = type.RegExpExtensions || (type.RegExpExtensions = {}));\r\n            })(type = utils.type || (utils.type = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var type;\r\n            (function (type) {\r\n                /**\r\n                 * Extensions to String class.\r\n                 */\r\n                var StringExtensions;\r\n                (function (StringExtensions) {\r\n                    /**\r\n                     * Checks if a string ends with a sub-string.\r\n                     */\r\n                    function endsWith(str, suffix) {\r\n                        return str.indexOf(suffix, str.length - suffix.length) !== -1;\r\n                    }\r\n                    StringExtensions.endsWith = endsWith;\r\n                })(StringExtensions = type.StringExtensions || (type.StringExtensions = {}));\r\n            })(type = utils.type || (utils.type = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var type;\r\n            (function (type) {\r\n                // NOTE: this file includes standalone utilities that should have no dependencies on external libraries, including jQuery.\r\n                var LogicExtensions;\r\n                (function (LogicExtensions) {\r\n                    function XOR(a, b) {\r\n                        return (a || b) && !(a && b);\r\n                    }\r\n                    LogicExtensions.XOR = XOR;\r\n                })(LogicExtensions = type.LogicExtensions || (type.LogicExtensions = {}));\r\n            })(type = utils.type || (utils.type = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var type;\r\n            (function (type) {\r\n                // NOTE: this file includes standalone utilities that should have no dependencies on external libraries, including jQuery.\r\n                var JsonComparer;\r\n                (function (JsonComparer) {\r\n                    /**\r\n                     * Performs JSON-style comparison of two objects.\r\n                     */\r\n                    function equals(x, y) {\r\n                        if (x === y)\r\n                            return true;\r\n                        return JSON.stringify(x) === JSON.stringify(y);\r\n                    }\r\n                    JsonComparer.equals = equals;\r\n                })(JsonComparer = type.JsonComparer || (type.JsonComparer = {}));\r\n            })(type = utils.type || (utils.type = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var type;\r\n            (function (type) {\r\n                // NOTE: this file includes standalone utilities that should have no dependencies on external libraries, including jQuery.\r\n                /**\r\n                 * Values are in terms of 'pt'\r\n                 * Convert to pixels using PixelConverter.fromPoint\r\n                 */\r\n                var TextSizeDefaults;\r\n                (function (TextSizeDefaults) {\r\n                    /**\r\n                     * Stored in terms of 'pt'\r\n                     * Convert to pixels using PixelConverter.fromPoint\r\n                     */\r\n                    TextSizeDefaults.TextSizeMin = 8;\r\n                    /**\r\n                     * Stored in terms of 'pt'\r\n                     * Convert to pixels using PixelConverter.fromPoint\r\n                     */\r\n                    TextSizeDefaults.TextSizeMax = 40;\r\n                    var TextSizeRange = TextSizeDefaults.TextSizeMax - TextSizeDefaults.TextSizeMin;\r\n                    /**\r\n                     * Returns the percentage of this value relative to the TextSizeMax\r\n                     * @param textSize - should be given in terms of 'pt'\r\n                     */\r\n                    function getScale(textSize) {\r\n                        return (textSize - TextSizeDefaults.TextSizeMin) / TextSizeRange;\r\n                    }\r\n                    TextSizeDefaults.getScale = getScale;\r\n                })(TextSizeDefaults = type.TextSizeDefaults || (type.TextSizeDefaults = {}));\r\n            })(type = utils.type || (utils.type = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var type;\r\n            (function (type) {\r\n                // powerbi.extensibility.utils.type\r\n                var EnumExtensions = powerbi.extensibility.utils.type.EnumExtensions;\r\n                /** Describes a data value type, including a primitive type and extended type if any (derived from data category). */\r\n                var ValueType = (function () {\r\n                    /** Do not call the ValueType constructor directly. Use the ValueType.fromXXX methods. */\r\n                    function ValueType(underlyingType, category, enumType, variantTypes) {\r\n                        this.underlyingType = underlyingType;\r\n                        this.category = category;\r\n                        if (EnumExtensions.hasFlag(underlyingType, ExtendedType.Temporal)) {\r\n                            this.temporalType = new TemporalType(underlyingType);\r\n                        }\r\n                        if (EnumExtensions.hasFlag(underlyingType, ExtendedType.Geography)) {\r\n                            this.geographyType = new GeographyType(underlyingType);\r\n                        }\r\n                        if (EnumExtensions.hasFlag(underlyingType, ExtendedType.Miscellaneous)) {\r\n                            this.miscType = new MiscellaneousType(underlyingType);\r\n                        }\r\n                        if (EnumExtensions.hasFlag(underlyingType, ExtendedType.Formatting)) {\r\n                            this.formattingType = new FormattingType(underlyingType);\r\n                        }\r\n                        if (EnumExtensions.hasFlag(underlyingType, ExtendedType.Enumeration)) {\r\n                            this.enumType = enumType;\r\n                        }\r\n                        if (EnumExtensions.hasFlag(underlyingType, ExtendedType.Scripting)) {\r\n                            this.scriptingType = new ScriptType(underlyingType);\r\n                        }\r\n                        if (EnumExtensions.hasFlag(underlyingType, ExtendedType.Variant)) {\r\n                            this.variationTypes = variantTypes;\r\n                        }\r\n                    }\r\n                    /** Creates or retrieves a ValueType object based on the specified ValueTypeDescriptor. */\r\n                    ValueType.fromDescriptor = function (descriptor) {\r\n                        descriptor = descriptor || {};\r\n                        // Simplified primitive types\r\n                        if (descriptor.text)\r\n                            return ValueType.fromExtendedType(ExtendedType.Text);\r\n                        if (descriptor.integer)\r\n                            return ValueType.fromExtendedType(ExtendedType.Integer);\r\n                        if (descriptor.numeric)\r\n                            return ValueType.fromExtendedType(ExtendedType.Double);\r\n                        if (descriptor.bool)\r\n                            return ValueType.fromExtendedType(ExtendedType.Boolean);\r\n                        if (descriptor.dateTime)\r\n                            return ValueType.fromExtendedType(ExtendedType.DateTime);\r\n                        if (descriptor.duration)\r\n                            return ValueType.fromExtendedType(ExtendedType.Duration);\r\n                        if (descriptor.binary)\r\n                            return ValueType.fromExtendedType(ExtendedType.Binary);\r\n                        if (descriptor.none)\r\n                            return ValueType.fromExtendedType(ExtendedType.None);\r\n                        // Extended types\r\n                        if (descriptor.scripting) {\r\n                            if (descriptor.scripting.source)\r\n                                return ValueType.fromExtendedType(ExtendedType.ScriptSource);\r\n                        }\r\n                        if (descriptor.enumeration)\r\n                            return ValueType.fromEnum(descriptor.enumeration);\r\n                        if (descriptor.temporal) {\r\n                            if (descriptor.temporal.year)\r\n                                return ValueType.fromExtendedType(ExtendedType.Years_Integer);\r\n                            if (descriptor.temporal.quarter)\r\n                                return ValueType.fromExtendedType(ExtendedType.Quarters_Integer);\r\n                            if (descriptor.temporal.month)\r\n                                return ValueType.fromExtendedType(ExtendedType.Months_Integer);\r\n                            if (descriptor.temporal.day)\r\n                                return ValueType.fromExtendedType(ExtendedType.DayOfMonth_Integer);\r\n                            if (descriptor.temporal.paddedDateTableDate)\r\n                                return ValueType.fromExtendedType(ExtendedType.PaddedDateTableDates);\r\n                        }\r\n                        if (descriptor.geography) {\r\n                            if (descriptor.geography.address)\r\n                                return ValueType.fromExtendedType(ExtendedType.Address);\r\n                            if (descriptor.geography.city)\r\n                                return ValueType.fromExtendedType(ExtendedType.City);\r\n                            if (descriptor.geography.continent)\r\n                                return ValueType.fromExtendedType(ExtendedType.Continent);\r\n                            if (descriptor.geography.country)\r\n                                return ValueType.fromExtendedType(ExtendedType.Country);\r\n                            if (descriptor.geography.county)\r\n                                return ValueType.fromExtendedType(ExtendedType.County);\r\n                            if (descriptor.geography.region)\r\n                                return ValueType.fromExtendedType(ExtendedType.Region);\r\n                            if (descriptor.geography.postalCode)\r\n                                return ValueType.fromExtendedType(ExtendedType.PostalCode_Text);\r\n                            if (descriptor.geography.stateOrProvince)\r\n                                return ValueType.fromExtendedType(ExtendedType.StateOrProvince);\r\n                            if (descriptor.geography.place)\r\n                                return ValueType.fromExtendedType(ExtendedType.Place);\r\n                            if (descriptor.geography.latitude)\r\n                                return ValueType.fromExtendedType(ExtendedType.Latitude_Double);\r\n                            if (descriptor.geography.longitude)\r\n                                return ValueType.fromExtendedType(ExtendedType.Longitude_Double);\r\n                        }\r\n                        if (descriptor.misc) {\r\n                            if (descriptor.misc.image)\r\n                                return ValueType.fromExtendedType(ExtendedType.Image);\r\n                            if (descriptor.misc.imageUrl)\r\n                                return ValueType.fromExtendedType(ExtendedType.ImageUrl);\r\n                            if (descriptor.misc.webUrl)\r\n                                return ValueType.fromExtendedType(ExtendedType.WebUrl);\r\n                            if (descriptor.misc.barcode)\r\n                                return ValueType.fromExtendedType(ExtendedType.Barcode_Text);\r\n                        }\r\n                        if (descriptor.formatting) {\r\n                            if (descriptor.formatting.color)\r\n                                return ValueType.fromExtendedType(ExtendedType.Color);\r\n                            if (descriptor.formatting.formatString)\r\n                                return ValueType.fromExtendedType(ExtendedType.FormatString);\r\n                            if (descriptor.formatting.alignment)\r\n                                return ValueType.fromExtendedType(ExtendedType.Alignment);\r\n                            if (descriptor.formatting.labelDisplayUnits)\r\n                                return ValueType.fromExtendedType(ExtendedType.LabelDisplayUnits);\r\n                            if (descriptor.formatting.fontSize)\r\n                                return ValueType.fromExtendedType(ExtendedType.FontSize);\r\n                            if (descriptor.formatting.labelDensity)\r\n                                return ValueType.fromExtendedType(ExtendedType.LabelDensity);\r\n                        }\r\n                        if (descriptor.extendedType) {\r\n                            return ValueType.fromExtendedType(descriptor.extendedType);\r\n                        }\r\n                        if (descriptor.operations) {\r\n                            if (descriptor.operations.searchEnabled)\r\n                                return ValueType.fromExtendedType(ExtendedType.SearchEnabled);\r\n                        }\r\n                        if (descriptor.variant) {\r\n                            var variantTypes = descriptor.variant.map(function (variantType) { return ValueType.fromDescriptor(variantType); });\r\n                            return ValueType.fromVariant(variantTypes);\r\n                        }\r\n                        return ValueType.fromExtendedType(ExtendedType.Null);\r\n                    };\r\n                    /** Advanced: Generally use fromDescriptor instead. Creates or retrieves a ValueType object for the specified ExtendedType. */\r\n                    ValueType.fromExtendedType = function (extendedType) {\r\n                        extendedType = extendedType || ExtendedType.Null;\r\n                        var primitiveType = getPrimitiveType(extendedType), category = getCategoryFromExtendedType(extendedType);\r\n                        return ValueType.fromPrimitiveTypeAndCategory(primitiveType, category);\r\n                    };\r\n                    /** Creates or retrieves a ValueType object for the specified PrimitiveType and data category. */\r\n                    ValueType.fromPrimitiveTypeAndCategory = function (primitiveType, category) {\r\n                        primitiveType = primitiveType || PrimitiveType.Null;\r\n                        category = category || null;\r\n                        var id = primitiveType.toString();\r\n                        if (category)\r\n                            id += \"|\" + category;\r\n                        return ValueType.typeCache[id] || (ValueType.typeCache[id] = new ValueType(toExtendedType(primitiveType, category), category));\r\n                    };\r\n                    /** Creates a ValueType to describe the given IEnumType. */\r\n                    ValueType.fromEnum = function (enumType) {\r\n                        return new ValueType(ExtendedType.Enumeration, null, enumType);\r\n                    };\r\n                    /** Creates a ValueType to describe the given Variant type. */\r\n                    ValueType.fromVariant = function (variantTypes) {\r\n                        return new ValueType(ExtendedType.Variant, /* category */ null, /* enumType */ null, variantTypes);\r\n                    };\r\n                    /** Determines if the specified type is compatible from at least one of the otherTypes. */\r\n                    ValueType.isCompatibleTo = function (typeDescriptor, otherTypes) {\r\n                        var valueType = ValueType.fromDescriptor(typeDescriptor);\r\n                        for (var _i = 0, otherTypes_1 = otherTypes; _i < otherTypes_1.length; _i++) {\r\n                            var otherType = otherTypes_1[_i];\r\n                            var otherValueType = ValueType.fromDescriptor(otherType);\r\n                            if (otherValueType.isCompatibleFrom(valueType))\r\n                                return true;\r\n                        }\r\n                        return false;\r\n                    };\r\n                    /** Determines if the instance ValueType is convertable from the 'other' ValueType. */\r\n                    ValueType.prototype.isCompatibleFrom = function (other) {\r\n                        var otherPrimitiveType = other.primitiveType;\r\n                        if (this === other ||\r\n                            this.primitiveType === otherPrimitiveType ||\r\n                            otherPrimitiveType === PrimitiveType.Null ||\r\n                            // Return true if both types are numbers\r\n                            (this.numeric && other.numeric))\r\n                            return true;\r\n                        return false;\r\n                    };\r\n                    /**\r\n                     * Determines if the instance ValueType is equal to the 'other' ValueType\r\n                     * @param {ValueType} other the other ValueType to check equality against\r\n                     * @returns True if the instance ValueType is equal to the 'other' ValueType\r\n                     */\r\n                    ValueType.prototype.equals = function (other) {\r\n                        return type.JsonComparer.equals(this, other);\r\n                    };\r\n                    Object.defineProperty(ValueType.prototype, \"primitiveType\", {\r\n                        /** Gets the exact primitive type of this ValueType. */\r\n                        get: function () {\r\n                            return getPrimitiveType(this.underlyingType);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(ValueType.prototype, \"extendedType\", {\r\n                        /** Gets the exact extended type of this ValueType. */\r\n                        get: function () {\r\n                            return this.underlyingType;\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(ValueType.prototype, \"categoryString\", {\r\n                        /** Gets the data category string (if any) for this ValueType. */\r\n                        get: function () {\r\n                            return this.category;\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(ValueType.prototype, \"text\", {\r\n                        // Simplified primitive types\r\n                        /** Indicates whether the type represents text values. */\r\n                        get: function () {\r\n                            return this.primitiveType === PrimitiveType.Text;\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(ValueType.prototype, \"numeric\", {\r\n                        /** Indicates whether the type represents any numeric value. */\r\n                        get: function () {\r\n                            return EnumExtensions.hasFlag(this.underlyingType, ExtendedType.Numeric);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(ValueType.prototype, \"integer\", {\r\n                        /** Indicates whether the type represents integer numeric values. */\r\n                        get: function () {\r\n                            return this.primitiveType === PrimitiveType.Integer;\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(ValueType.prototype, \"bool\", {\r\n                        /** Indicates whether the type represents Boolean values. */\r\n                        get: function () {\r\n                            return this.primitiveType === PrimitiveType.Boolean;\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(ValueType.prototype, \"dateTime\", {\r\n                        /** Indicates whether the type represents any date/time values. */\r\n                        get: function () {\r\n                            return this.primitiveType === PrimitiveType.DateTime ||\r\n                                this.primitiveType === PrimitiveType.Date ||\r\n                                this.primitiveType === PrimitiveType.Time;\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(ValueType.prototype, \"duration\", {\r\n                        /** Indicates whether the type represents duration values. */\r\n                        get: function () {\r\n                            return this.primitiveType === PrimitiveType.Duration;\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(ValueType.prototype, \"binary\", {\r\n                        /** Indicates whether the type represents binary values. */\r\n                        get: function () {\r\n                            return this.primitiveType === PrimitiveType.Binary;\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(ValueType.prototype, \"none\", {\r\n                        /** Indicates whether the type represents none values. */\r\n                        get: function () {\r\n                            return this.primitiveType === PrimitiveType.None;\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(ValueType.prototype, \"temporal\", {\r\n                        // Extended types\r\n                        /** Returns an object describing temporal values represented by the type, if it represents a temporal type. */\r\n                        get: function () {\r\n                            return this.temporalType;\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(ValueType.prototype, \"geography\", {\r\n                        /** Returns an object describing geographic values represented by the type, if it represents a geographic type. */\r\n                        get: function () {\r\n                            return this.geographyType;\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(ValueType.prototype, \"misc\", {\r\n                        /** Returns an object describing the specific values represented by the type, if it represents a miscellaneous extended type. */\r\n                        get: function () {\r\n                            return this.miscType;\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(ValueType.prototype, \"formatting\", {\r\n                        /** Returns an object describing the formatting values represented by the type, if it represents a formatting type. */\r\n                        get: function () {\r\n                            return this.formattingType;\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(ValueType.prototype, \"enumeration\", {\r\n                        /** Returns an object describing the enum values represented by the type, if it represents an enumeration type. */\r\n                        get: function () {\r\n                            return this.enumType;\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(ValueType.prototype, \"scripting\", {\r\n                        get: function () {\r\n                            return this.scriptingType;\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(ValueType.prototype, \"variant\", {\r\n                        /** Returns an array describing the variant values represented by the type, if it represents an Variant type. */\r\n                        get: function () {\r\n                            return this.variationTypes;\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    return ValueType;\r\n                }());\r\n                ValueType.typeCache = {};\r\n                type.ValueType = ValueType;\r\n                var ScriptType = (function () {\r\n                    function ScriptType(underlyingType) {\r\n                        this.underlyingType = underlyingType;\r\n                    }\r\n                    Object.defineProperty(ScriptType.prototype, \"source\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ScriptSource);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    return ScriptType;\r\n                }());\r\n                type.ScriptType = ScriptType;\r\n                var TemporalType = (function () {\r\n                    function TemporalType(underlyingType) {\r\n                        this.underlyingType = underlyingType;\r\n                    }\r\n                    Object.defineProperty(TemporalType.prototype, \"year\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Years);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(TemporalType.prototype, \"quarter\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Quarters);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(TemporalType.prototype, \"month\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Months);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(TemporalType.prototype, \"day\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.DayOfMonth);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(TemporalType.prototype, \"paddedDateTableDate\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.PaddedDateTableDates);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    return TemporalType;\r\n                }());\r\n                type.TemporalType = TemporalType;\r\n                var GeographyType = (function () {\r\n                    function GeographyType(underlyingType) {\r\n                        this.underlyingType = underlyingType;\r\n                    }\r\n                    Object.defineProperty(GeographyType.prototype, \"address\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Address);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(GeographyType.prototype, \"city\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.City);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(GeographyType.prototype, \"continent\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Continent);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(GeographyType.prototype, \"country\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Country);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(GeographyType.prototype, \"county\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.County);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(GeographyType.prototype, \"region\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Region);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(GeographyType.prototype, \"postalCode\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.PostalCode);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(GeographyType.prototype, \"stateOrProvince\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.StateOrProvince);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(GeographyType.prototype, \"place\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Place);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(GeographyType.prototype, \"latitude\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Latitude);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(GeographyType.prototype, \"longitude\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Longitude);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    return GeographyType;\r\n                }());\r\n                type.GeographyType = GeographyType;\r\n                var MiscellaneousType = (function () {\r\n                    function MiscellaneousType(underlyingType) {\r\n                        this.underlyingType = underlyingType;\r\n                    }\r\n                    Object.defineProperty(MiscellaneousType.prototype, \"image\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Image);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(MiscellaneousType.prototype, \"imageUrl\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ImageUrl);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(MiscellaneousType.prototype, \"webUrl\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.WebUrl);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(MiscellaneousType.prototype, \"barcode\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Barcode);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    return MiscellaneousType;\r\n                }());\r\n                type.MiscellaneousType = MiscellaneousType;\r\n                var FormattingType = (function () {\r\n                    function FormattingType(underlyingType) {\r\n                        this.underlyingType = underlyingType;\r\n                    }\r\n                    Object.defineProperty(FormattingType.prototype, \"color\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Color);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(FormattingType.prototype, \"formatString\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FormatString);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(FormattingType.prototype, \"alignment\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Alignment);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(FormattingType.prototype, \"labelDisplayUnits\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDisplayUnits);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(FormattingType.prototype, \"fontSize\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FontSize);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(FormattingType.prototype, \"labelDensity\", {\r\n                        get: function () {\r\n                            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDensity);\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    return FormattingType;\r\n                }());\r\n                type.FormattingType = FormattingType;\r\n                /** Defines primitive value types. Must be consistent with types defined by server conceptual schema. */\r\n                var PrimitiveType;\r\n                (function (PrimitiveType) {\r\n                    PrimitiveType[PrimitiveType[\"Null\"] = 0] = \"Null\";\r\n                    PrimitiveType[PrimitiveType[\"Text\"] = 1] = \"Text\";\r\n                    PrimitiveType[PrimitiveType[\"Decimal\"] = 2] = \"Decimal\";\r\n                    PrimitiveType[PrimitiveType[\"Double\"] = 3] = \"Double\";\r\n                    PrimitiveType[PrimitiveType[\"Integer\"] = 4] = \"Integer\";\r\n                    PrimitiveType[PrimitiveType[\"Boolean\"] = 5] = \"Boolean\";\r\n                    PrimitiveType[PrimitiveType[\"Date\"] = 6] = \"Date\";\r\n                    PrimitiveType[PrimitiveType[\"DateTime\"] = 7] = \"DateTime\";\r\n                    PrimitiveType[PrimitiveType[\"DateTimeZone\"] = 8] = \"DateTimeZone\";\r\n                    PrimitiveType[PrimitiveType[\"Time\"] = 9] = \"Time\";\r\n                    PrimitiveType[PrimitiveType[\"Duration\"] = 10] = \"Duration\";\r\n                    PrimitiveType[PrimitiveType[\"Binary\"] = 11] = \"Binary\";\r\n                    PrimitiveType[PrimitiveType[\"None\"] = 12] = \"None\";\r\n                    PrimitiveType[PrimitiveType[\"Variant\"] = 13] = \"Variant\";\r\n                })(PrimitiveType = type.PrimitiveType || (type.PrimitiveType = {}));\r\n                var PrimitiveTypeStrings;\r\n                (function (PrimitiveTypeStrings) {\r\n                    PrimitiveTypeStrings[PrimitiveTypeStrings[\"Null\"] = 0] = \"Null\";\r\n                    PrimitiveTypeStrings[PrimitiveTypeStrings[\"Text\"] = 1] = \"Text\";\r\n                    PrimitiveTypeStrings[PrimitiveTypeStrings[\"Decimal\"] = 2] = \"Decimal\";\r\n                    PrimitiveTypeStrings[PrimitiveTypeStrings[\"Double\"] = 3] = \"Double\";\r\n                    PrimitiveTypeStrings[PrimitiveTypeStrings[\"Integer\"] = 4] = \"Integer\";\r\n                    PrimitiveTypeStrings[PrimitiveTypeStrings[\"Boolean\"] = 5] = \"Boolean\";\r\n                    PrimitiveTypeStrings[PrimitiveTypeStrings[\"Date\"] = 6] = \"Date\";\r\n                    PrimitiveTypeStrings[PrimitiveTypeStrings[\"DateTime\"] = 7] = \"DateTime\";\r\n                    PrimitiveTypeStrings[PrimitiveTypeStrings[\"DateTimeZone\"] = 8] = \"DateTimeZone\";\r\n                    PrimitiveTypeStrings[PrimitiveTypeStrings[\"Time\"] = 9] = \"Time\";\r\n                    PrimitiveTypeStrings[PrimitiveTypeStrings[\"Duration\"] = 10] = \"Duration\";\r\n                    PrimitiveTypeStrings[PrimitiveTypeStrings[\"Binary\"] = 11] = \"Binary\";\r\n                    PrimitiveTypeStrings[PrimitiveTypeStrings[\"None\"] = 12] = \"None\";\r\n                    PrimitiveTypeStrings[PrimitiveTypeStrings[\"Variant\"] = 13] = \"Variant\";\r\n                })(PrimitiveTypeStrings || (PrimitiveTypeStrings = {}));\r\n                /** Defines extended value types, which include primitive types and known data categories constrained to expected primitive types. */\r\n                var ExtendedType;\r\n                (function (ExtendedType) {\r\n                    // Flags (1 << 8-15 range [0xFF00])\r\n                    // Important: Enum members must be declared before they are used in TypeScript.\r\n                    ExtendedType[ExtendedType[\"Numeric\"] = 256] = \"Numeric\";\r\n                    ExtendedType[ExtendedType[\"Temporal\"] = 512] = \"Temporal\";\r\n                    ExtendedType[ExtendedType[\"Geography\"] = 1024] = \"Geography\";\r\n                    ExtendedType[ExtendedType[\"Miscellaneous\"] = 2048] = \"Miscellaneous\";\r\n                    ExtendedType[ExtendedType[\"Formatting\"] = 4096] = \"Formatting\";\r\n                    ExtendedType[ExtendedType[\"Scripting\"] = 8192] = \"Scripting\";\r\n                    // Primitive types (0-255 range [0xFF] | flags)\r\n                    // The member names and base values must match those in PrimitiveType.\r\n                    ExtendedType[ExtendedType[\"Null\"] = 0] = \"Null\";\r\n                    ExtendedType[ExtendedType[\"Text\"] = 1] = \"Text\";\r\n                    ExtendedType[ExtendedType[\"Decimal\"] = 258] = \"Decimal\";\r\n                    ExtendedType[ExtendedType[\"Double\"] = 259] = \"Double\";\r\n                    ExtendedType[ExtendedType[\"Integer\"] = 260] = \"Integer\";\r\n                    ExtendedType[ExtendedType[\"Boolean\"] = 5] = \"Boolean\";\r\n                    ExtendedType[ExtendedType[\"Date\"] = 518] = \"Date\";\r\n                    ExtendedType[ExtendedType[\"DateTime\"] = 519] = \"DateTime\";\r\n                    ExtendedType[ExtendedType[\"DateTimeZone\"] = 520] = \"DateTimeZone\";\r\n                    ExtendedType[ExtendedType[\"Time\"] = 521] = \"Time\";\r\n                    ExtendedType[ExtendedType[\"Duration\"] = 10] = \"Duration\";\r\n                    ExtendedType[ExtendedType[\"Binary\"] = 11] = \"Binary\";\r\n                    ExtendedType[ExtendedType[\"None\"] = 12] = \"None\";\r\n                    ExtendedType[ExtendedType[\"Variant\"] = 13] = \"Variant\";\r\n                    // Extended types (0-32767 << 16 range [0xFFFF0000] | corresponding primitive type | flags)\r\n                    // Temporal\r\n                    ExtendedType[ExtendedType[\"Years\"] = 66048] = \"Years\";\r\n                    ExtendedType[ExtendedType[\"Years_Text\"] = 66049] = \"Years_Text\";\r\n                    ExtendedType[ExtendedType[\"Years_Integer\"] = 66308] = \"Years_Integer\";\r\n                    ExtendedType[ExtendedType[\"Years_Date\"] = 66054] = \"Years_Date\";\r\n                    ExtendedType[ExtendedType[\"Years_DateTime\"] = 66055] = \"Years_DateTime\";\r\n                    ExtendedType[ExtendedType[\"Months\"] = 131584] = \"Months\";\r\n                    ExtendedType[ExtendedType[\"Months_Text\"] = 131585] = \"Months_Text\";\r\n                    ExtendedType[ExtendedType[\"Months_Integer\"] = 131844] = \"Months_Integer\";\r\n                    ExtendedType[ExtendedType[\"Months_Date\"] = 131590] = \"Months_Date\";\r\n                    ExtendedType[ExtendedType[\"Months_DateTime\"] = 131591] = \"Months_DateTime\";\r\n                    ExtendedType[ExtendedType[\"PaddedDateTableDates\"] = 197127] = \"PaddedDateTableDates\";\r\n                    ExtendedType[ExtendedType[\"Quarters\"] = 262656] = \"Quarters\";\r\n                    ExtendedType[ExtendedType[\"Quarters_Text\"] = 262657] = \"Quarters_Text\";\r\n                    ExtendedType[ExtendedType[\"Quarters_Integer\"] = 262916] = \"Quarters_Integer\";\r\n                    ExtendedType[ExtendedType[\"Quarters_Date\"] = 262662] = \"Quarters_Date\";\r\n                    ExtendedType[ExtendedType[\"Quarters_DateTime\"] = 262663] = \"Quarters_DateTime\";\r\n                    ExtendedType[ExtendedType[\"DayOfMonth\"] = 328192] = \"DayOfMonth\";\r\n                    ExtendedType[ExtendedType[\"DayOfMonth_Text\"] = 328193] = \"DayOfMonth_Text\";\r\n                    ExtendedType[ExtendedType[\"DayOfMonth_Integer\"] = 328452] = \"DayOfMonth_Integer\";\r\n                    ExtendedType[ExtendedType[\"DayOfMonth_Date\"] = 328198] = \"DayOfMonth_Date\";\r\n                    ExtendedType[ExtendedType[\"DayOfMonth_DateTime\"] = 328199] = \"DayOfMonth_DateTime\";\r\n                    // Geography\r\n                    ExtendedType[ExtendedType[\"Address\"] = 6554625] = \"Address\";\r\n                    ExtendedType[ExtendedType[\"City\"] = 6620161] = \"City\";\r\n                    ExtendedType[ExtendedType[\"Continent\"] = 6685697] = \"Continent\";\r\n                    ExtendedType[ExtendedType[\"Country\"] = 6751233] = \"Country\";\r\n                    ExtendedType[ExtendedType[\"County\"] = 6816769] = \"County\";\r\n                    ExtendedType[ExtendedType[\"Region\"] = 6882305] = \"Region\";\r\n                    ExtendedType[ExtendedType[\"PostalCode\"] = 6947840] = \"PostalCode\";\r\n                    ExtendedType[ExtendedType[\"PostalCode_Text\"] = 6947841] = \"PostalCode_Text\";\r\n                    ExtendedType[ExtendedType[\"PostalCode_Integer\"] = 6948100] = \"PostalCode_Integer\";\r\n                    ExtendedType[ExtendedType[\"StateOrProvince\"] = 7013377] = \"StateOrProvince\";\r\n                    ExtendedType[ExtendedType[\"Place\"] = 7078913] = \"Place\";\r\n                    ExtendedType[ExtendedType[\"Latitude\"] = 7144448] = \"Latitude\";\r\n                    ExtendedType[ExtendedType[\"Latitude_Decimal\"] = 7144706] = \"Latitude_Decimal\";\r\n                    ExtendedType[ExtendedType[\"Latitude_Double\"] = 7144707] = \"Latitude_Double\";\r\n                    ExtendedType[ExtendedType[\"Longitude\"] = 7209984] = \"Longitude\";\r\n                    ExtendedType[ExtendedType[\"Longitude_Decimal\"] = 7210242] = \"Longitude_Decimal\";\r\n                    ExtendedType[ExtendedType[\"Longitude_Double\"] = 7210243] = \"Longitude_Double\";\r\n                    // Miscellaneous\r\n                    ExtendedType[ExtendedType[\"Image\"] = 13109259] = \"Image\";\r\n                    ExtendedType[ExtendedType[\"ImageUrl\"] = 13174785] = \"ImageUrl\";\r\n                    ExtendedType[ExtendedType[\"WebUrl\"] = 13240321] = \"WebUrl\";\r\n                    ExtendedType[ExtendedType[\"Barcode\"] = 13305856] = \"Barcode\";\r\n                    ExtendedType[ExtendedType[\"Barcode_Text\"] = 13305857] = \"Barcode_Text\";\r\n                    ExtendedType[ExtendedType[\"Barcode_Integer\"] = 13306116] = \"Barcode_Integer\";\r\n                    // Formatting\r\n                    ExtendedType[ExtendedType[\"Color\"] = 19664897] = \"Color\";\r\n                    ExtendedType[ExtendedType[\"FormatString\"] = 19730433] = \"FormatString\";\r\n                    ExtendedType[ExtendedType[\"Alignment\"] = 20058113] = \"Alignment\";\r\n                    ExtendedType[ExtendedType[\"LabelDisplayUnits\"] = 20123649] = \"LabelDisplayUnits\";\r\n                    ExtendedType[ExtendedType[\"FontSize\"] = 20189443] = \"FontSize\";\r\n                    ExtendedType[ExtendedType[\"LabelDensity\"] = 20254979] = \"LabelDensity\";\r\n                    // Enumeration\r\n                    ExtendedType[ExtendedType[\"Enumeration\"] = 26214401] = \"Enumeration\";\r\n                    // Scripting\r\n                    ExtendedType[ExtendedType[\"ScriptSource\"] = 32776193] = \"ScriptSource\";\r\n                    // NOTE: To avoid confusion, underscores should be used only to delimit primitive type variants of an extended type\r\n                    // (e.g. Year_Integer or Latitude_Double above)\r\n                    // Operations\r\n                    ExtendedType[ExtendedType[\"SearchEnabled\"] = 65541] = \"SearchEnabled\";\r\n                })(ExtendedType = type.ExtendedType || (type.ExtendedType = {}));\r\n                var ExtendedTypeStrings;\r\n                (function (ExtendedTypeStrings) {\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Numeric\"] = 256] = \"Numeric\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Temporal\"] = 512] = \"Temporal\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Geography\"] = 1024] = \"Geography\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Miscellaneous\"] = 2048] = \"Miscellaneous\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Formatting\"] = 4096] = \"Formatting\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Scripting\"] = 8192] = \"Scripting\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Null\"] = 0] = \"Null\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Text\"] = 1] = \"Text\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Decimal\"] = 258] = \"Decimal\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Double\"] = 259] = \"Double\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Integer\"] = 260] = \"Integer\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Boolean\"] = 5] = \"Boolean\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Date\"] = 518] = \"Date\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"DateTime\"] = 519] = \"DateTime\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"DateTimeZone\"] = 520] = \"DateTimeZone\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Time\"] = 521] = \"Time\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Duration\"] = 10] = \"Duration\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Binary\"] = 11] = \"Binary\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"None\"] = 12] = \"None\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Variant\"] = 13] = \"Variant\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Years\"] = 66048] = \"Years\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Years_Text\"] = 66049] = \"Years_Text\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Years_Integer\"] = 66308] = \"Years_Integer\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Years_Date\"] = 66054] = \"Years_Date\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Years_DateTime\"] = 66055] = \"Years_DateTime\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Months\"] = 131584] = \"Months\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Months_Text\"] = 131585] = \"Months_Text\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Months_Integer\"] = 131844] = \"Months_Integer\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Months_Date\"] = 131590] = \"Months_Date\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Months_DateTime\"] = 131591] = \"Months_DateTime\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"PaddedDateTableDates\"] = 197127] = \"PaddedDateTableDates\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Quarters\"] = 262656] = \"Quarters\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Quarters_Text\"] = 262657] = \"Quarters_Text\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Quarters_Integer\"] = 262916] = \"Quarters_Integer\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Quarters_Date\"] = 262662] = \"Quarters_Date\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Quarters_DateTime\"] = 262663] = \"Quarters_DateTime\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"DayOfMonth\"] = 328192] = \"DayOfMonth\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"DayOfMonth_Text\"] = 328193] = \"DayOfMonth_Text\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"DayOfMonth_Integer\"] = 328452] = \"DayOfMonth_Integer\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"DayOfMonth_Date\"] = 328198] = \"DayOfMonth_Date\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"DayOfMonth_DateTime\"] = 328199] = \"DayOfMonth_DateTime\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Address\"] = 6554625] = \"Address\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"City\"] = 6620161] = \"City\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Continent\"] = 6685697] = \"Continent\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Country\"] = 6751233] = \"Country\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"County\"] = 6816769] = \"County\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Region\"] = 6882305] = \"Region\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"PostalCode\"] = 6947840] = \"PostalCode\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"PostalCode_Text\"] = 6947841] = \"PostalCode_Text\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"PostalCode_Integer\"] = 6948100] = \"PostalCode_Integer\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"StateOrProvince\"] = 7013377] = \"StateOrProvince\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Place\"] = 7078913] = \"Place\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Latitude\"] = 7144448] = \"Latitude\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Latitude_Decimal\"] = 7144706] = \"Latitude_Decimal\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Latitude_Double\"] = 7144707] = \"Latitude_Double\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Longitude\"] = 7209984] = \"Longitude\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Longitude_Decimal\"] = 7210242] = \"Longitude_Decimal\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Longitude_Double\"] = 7210243] = \"Longitude_Double\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Image\"] = 13109259] = \"Image\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"ImageUrl\"] = 13174785] = \"ImageUrl\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"WebUrl\"] = 13240321] = \"WebUrl\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Barcode\"] = 13305856] = \"Barcode\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Barcode_Text\"] = 13305857] = \"Barcode_Text\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Barcode_Integer\"] = 13306116] = \"Barcode_Integer\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Color\"] = 19664897] = \"Color\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"FormatString\"] = 19730433] = \"FormatString\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Alignment\"] = 20058113] = \"Alignment\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"LabelDisplayUnits\"] = 20123649] = \"LabelDisplayUnits\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"FontSize\"] = 20189443] = \"FontSize\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"LabelDensity\"] = 20254979] = \"LabelDensity\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"Enumeration\"] = 26214401] = \"Enumeration\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"ScriptSource\"] = 32776193] = \"ScriptSource\";\r\n                    ExtendedTypeStrings[ExtendedTypeStrings[\"SearchEnabled\"] = 65541] = \"SearchEnabled\";\r\n                })(ExtendedTypeStrings || (ExtendedTypeStrings = {}));\r\n                var PrimitiveTypeMask = 0xFF;\r\n                var PrimitiveTypeWithFlagsMask = 0xFFFF;\r\n                var PrimitiveTypeFlagsExcludedMask = 0xFFFF0000;\r\n                function getPrimitiveType(extendedType) {\r\n                    return extendedType & PrimitiveTypeMask;\r\n                }\r\n                function isPrimitiveType(extendedType) {\r\n                    return (extendedType & PrimitiveTypeWithFlagsMask) === extendedType;\r\n                }\r\n                function getCategoryFromExtendedType(extendedType) {\r\n                    if (isPrimitiveType(extendedType))\r\n                        return null;\r\n                    var category = ExtendedTypeStrings[extendedType];\r\n                    if (category) {\r\n                        // Check for ExtendedType declaration without a primitive type.\r\n                        // If exists, use it as category (e.g. Longitude rather than Longitude_Double)\r\n                        // Otherwise use the ExtendedType declaration with a primitive type (e.g. Address)\r\n                        var delimIdx = category.lastIndexOf(\"_\");\r\n                        if (delimIdx > 0) {\r\n                            var baseCategory = category.slice(0, delimIdx);\r\n                            if (ExtendedTypeStrings[baseCategory]) {\r\n                                category = baseCategory;\r\n                            }\r\n                        }\r\n                    }\r\n                    return category || null;\r\n                }\r\n                function toExtendedType(primitiveType, category) {\r\n                    var primitiveString = PrimitiveTypeStrings[primitiveType];\r\n                    var t = ExtendedTypeStrings[primitiveString];\r\n                    if (t == null) {\r\n                        t = ExtendedType.Null;\r\n                    }\r\n                    if (primitiveType && category) {\r\n                        var categoryType = ExtendedTypeStrings[category];\r\n                        if (categoryType) {\r\n                            var categoryPrimitiveType = getPrimitiveType(categoryType);\r\n                            if (categoryPrimitiveType === PrimitiveType.Null) {\r\n                                // Category supports multiple primitive types, check if requested primitive type is supported\r\n                                // (note: important to use t here rather than primitiveType as it may include primitive type flags)\r\n                                categoryType = t | categoryType;\r\n                                if (ExtendedTypeStrings[categoryType]) {\r\n                                    t = categoryType;\r\n                                }\r\n                            }\r\n                            else if (categoryPrimitiveType === primitiveType) {\r\n                                // Primitive type matches the single supported type for the category\r\n                                t = categoryType;\r\n                            }\r\n                        }\r\n                    }\r\n                    return t;\r\n                }\r\n                function matchesExtendedTypeWithAnyPrimitive(a, b) {\r\n                    return (a & PrimitiveTypeFlagsExcludedMask) === (b & PrimitiveTypeFlagsExcludedMask);\r\n                }\r\n            })(type = utils.type || (utils.type = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var dataview;\r\n            (function (dataview) {\r\n                // TODO: refactor & focus DataViewTransform into a service with well-defined dependencies.\r\n                var DataViewTransform;\r\n                (function (DataViewTransform) {\r\n                    // TODO: refactor this, setGrouped, and groupValues to a test helper to stop using it in the product\r\n                    function createValueColumns(values, valueIdentityFields, source) {\r\n                        if (values === void 0) { values = []; }\r\n                        var result = values;\r\n                        setGrouped(result);\r\n                        if (valueIdentityFields) {\r\n                            result.identityFields = valueIdentityFields;\r\n                        }\r\n                        if (source) {\r\n                            result.source = source;\r\n                        }\r\n                        return result;\r\n                    }\r\n                    DataViewTransform.createValueColumns = createValueColumns;\r\n                    function setGrouped(values, groupedResult) {\r\n                        values.grouped = groupedResult\r\n                            ? function () { return groupedResult; }\r\n                            : function () { return groupValues(values); };\r\n                    }\r\n                    DataViewTransform.setGrouped = setGrouped;\r\n                    /** Group together the values with a common identity. */\r\n                    function groupValues(values) {\r\n                        var groups = [], currentGroup;\r\n                        for (var i = 0, len = values.length; i < len; i++) {\r\n                            var value = values[i];\r\n                            if (!currentGroup || currentGroup.identity !== value.identity) {\r\n                                currentGroup = {\r\n                                    values: []\r\n                                };\r\n                                if (value.identity) {\r\n                                    currentGroup.identity = value.identity;\r\n                                    var source = value.source;\r\n                                    // allow null, which will be formatted as (Blank).\r\n                                    if (source.groupName !== undefined) {\r\n                                        currentGroup.name = source.groupName;\r\n                                    }\r\n                                    else if (source.displayName) {\r\n                                        currentGroup.name = source.displayName;\r\n                                    }\r\n                                }\r\n                                groups.push(currentGroup);\r\n                            }\r\n                            currentGroup.values.push(value);\r\n                        }\r\n                        return groups;\r\n                    }\r\n                    DataViewTransform.groupValues = groupValues;\r\n                })(DataViewTransform = dataview.DataViewTransform || (dataview.DataViewTransform = {}));\r\n            })(dataview = utils.dataview || (utils.dataview = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var dataview;\r\n            (function (dataview) {\r\n                var DataRoleHelper;\r\n                (function (DataRoleHelper) {\r\n                    function getMeasureIndexOfRole(grouped, roleName) {\r\n                        if (!grouped || !grouped.length) {\r\n                            return -1;\r\n                        }\r\n                        var firstGroup = grouped[0];\r\n                        if (firstGroup.values && firstGroup.values.length > 0) {\r\n                            for (var i = 0, len = firstGroup.values.length; i < len; ++i) {\r\n                                var value = firstGroup.values[i];\r\n                                if (value && value.source) {\r\n                                    if (hasRole(value.source, roleName)) {\r\n                                        return i;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        return -1;\r\n                    }\r\n                    DataRoleHelper.getMeasureIndexOfRole = getMeasureIndexOfRole;\r\n                    function getCategoryIndexOfRole(categories, roleName) {\r\n                        if (categories && categories.length) {\r\n                            for (var i = 0, ilen = categories.length; i < ilen; i++) {\r\n                                if (hasRole(categories[i].source, roleName)) {\r\n                                    return i;\r\n                                }\r\n                            }\r\n                        }\r\n                        return -1;\r\n                    }\r\n                    DataRoleHelper.getCategoryIndexOfRole = getCategoryIndexOfRole;\r\n                    function hasRole(column, name) {\r\n                        var roles = column.roles;\r\n                        return roles && roles[name];\r\n                    }\r\n                    DataRoleHelper.hasRole = hasRole;\r\n                    function hasRoleInDataView(dataView, name) {\r\n                        return dataView != null\r\n                            && dataView.metadata != null\r\n                            && dataView.metadata.columns\r\n                            && dataView.metadata.columns.some(function (c) { return c.roles && c.roles[name] !== undefined; }); // any is an alias of some\r\n                    }\r\n                    DataRoleHelper.hasRoleInDataView = hasRoleInDataView;\r\n                    function hasRoleInValueColumn(valueColumn, name) {\r\n                        return valueColumn\r\n                            && valueColumn.source\r\n                            && valueColumn.source.roles\r\n                            && (valueColumn.source.roles[name] === true);\r\n                    }\r\n                    DataRoleHelper.hasRoleInValueColumn = hasRoleInValueColumn;\r\n                })(DataRoleHelper = dataview.DataRoleHelper || (dataview.DataRoleHelper = {}));\r\n            })(dataview = utils.dataview || (utils.dataview = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var dataview;\r\n            (function (dataview) {\r\n                var DataViewObject;\r\n                (function (DataViewObject) {\r\n                    function getValue(object, propertyName, defaultValue) {\r\n                        if (!object) {\r\n                            return defaultValue;\r\n                        }\r\n                        var propertyValue = object[propertyName];\r\n                        if (propertyValue === undefined) {\r\n                            return defaultValue;\r\n                        }\r\n                        return propertyValue;\r\n                    }\r\n                    DataViewObject.getValue = getValue;\r\n                    /** Gets the solid color from a fill property using only a propertyName */\r\n                    function getFillColorByPropertyName(object, propertyName, defaultColor) {\r\n                        var value = getValue(object, propertyName);\r\n                        if (!value || !value.solid) {\r\n                            return defaultColor;\r\n                        }\r\n                        return value.solid.color;\r\n                    }\r\n                    DataViewObject.getFillColorByPropertyName = getFillColorByPropertyName;\r\n                })(DataViewObject = dataview.DataViewObject || (dataview.DataViewObject = {}));\r\n            })(dataview = utils.dataview || (utils.dataview = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var dataview;\r\n            (function (dataview) {\r\n                var DataViewObjects;\r\n                (function (DataViewObjects) {\r\n                    /** Gets the value of the given object/property pair. */\r\n                    function getValue(objects, propertyId, defaultValue) {\r\n                        if (!objects) {\r\n                            return defaultValue;\r\n                        }\r\n                        return dataview.DataViewObject.getValue(objects[propertyId.objectName], propertyId.propertyName, defaultValue);\r\n                    }\r\n                    DataViewObjects.getValue = getValue;\r\n                    /** Gets an object from objects. */\r\n                    function getObject(objects, objectName, defaultValue) {\r\n                        if (objects && objects[objectName]) {\r\n                            return objects[objectName];\r\n                        }\r\n                        return defaultValue;\r\n                    }\r\n                    DataViewObjects.getObject = getObject;\r\n                    /** Gets the solid color from a fill property. */\r\n                    function getFillColor(objects, propertyId, defaultColor) {\r\n                        var value = getValue(objects, propertyId);\r\n                        if (!value || !value.solid) {\r\n                            return defaultColor;\r\n                        }\r\n                        return value.solid.color;\r\n                    }\r\n                    DataViewObjects.getFillColor = getFillColor;\r\n                    function getCommonValue(objects, propertyId, defaultValue) {\r\n                        var value = getValue(objects, propertyId, defaultValue);\r\n                        if (value && value.solid) {\r\n                            return value.solid.color;\r\n                        }\r\n                        if (value === undefined\r\n                            || value === null\r\n                            || (typeof value === \"object\" && !value.solid)) {\r\n                            return defaultValue;\r\n                        }\r\n                        return value;\r\n                    }\r\n                    DataViewObjects.getCommonValue = getCommonValue;\r\n                })(DataViewObjects = dataview.DataViewObjects || (dataview.DataViewObjects = {}));\r\n            })(dataview = utils.dataview || (utils.dataview = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var dataview;\r\n            (function (dataview) {\r\n                // powerbi.extensibility.utils.dataview\r\n                var DataRoleHelper = powerbi.extensibility.utils.dataview.DataRoleHelper;\r\n                var converterHelper;\r\n                (function (converterHelper) {\r\n                    function categoryIsAlsoSeriesRole(dataView, seriesRoleName, categoryRoleName) {\r\n                        if (dataView.categories && dataView.categories.length > 0) {\r\n                            // Need to pivot data if our category soure is a series role\r\n                            var category = dataView.categories[0];\r\n                            return category.source &&\r\n                                DataRoleHelper.hasRole(category.source, seriesRoleName) &&\r\n                                DataRoleHelper.hasRole(category.source, categoryRoleName);\r\n                        }\r\n                        return false;\r\n                    }\r\n                    converterHelper.categoryIsAlsoSeriesRole = categoryIsAlsoSeriesRole;\r\n                    function getSeriesName(source) {\r\n                        return (source.groupName !== undefined)\r\n                            ? source.groupName\r\n                            : source.queryName;\r\n                    }\r\n                    converterHelper.getSeriesName = getSeriesName;\r\n                    function isImageUrlColumn(column) {\r\n                        var misc = getMiscellaneousTypeDescriptor(column);\r\n                        return misc != null && misc.imageUrl === true;\r\n                    }\r\n                    converterHelper.isImageUrlColumn = isImageUrlColumn;\r\n                    function isWebUrlColumn(column) {\r\n                        var misc = getMiscellaneousTypeDescriptor(column);\r\n                        return misc != null && misc.webUrl === true;\r\n                    }\r\n                    converterHelper.isWebUrlColumn = isWebUrlColumn;\r\n                    function getMiscellaneousTypeDescriptor(column) {\r\n                        return column\r\n                            && column.type\r\n                            && column.type.misc;\r\n                    }\r\n                    converterHelper.getMiscellaneousTypeDescriptor = getMiscellaneousTypeDescriptor;\r\n                    function hasImageUrlColumn(dataView) {\r\n                        if (!dataView || !dataView.metadata || !dataView.metadata.columns || !dataView.metadata.columns.length) {\r\n                            return false;\r\n                        }\r\n                        return dataView.metadata.columns.some(function (column) { return isImageUrlColumn(column) === true; });\r\n                    }\r\n                    converterHelper.hasImageUrlColumn = hasImageUrlColumn;\r\n                })(converterHelper = dataview.converterHelper || (dataview.converterHelper = {}));\r\n            })(dataview = utils.dataview || (utils.dataview = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var dataview;\r\n            (function (dataview) {\r\n                var DataViewObjectsParser = (function () {\r\n                    function DataViewObjectsParser() {\r\n                    }\r\n                    DataViewObjectsParser.getDefault = function () {\r\n                        return new this();\r\n                    };\r\n                    DataViewObjectsParser.createPropertyIdentifier = function (objectName, propertyName) {\r\n                        return {\r\n                            objectName: objectName,\r\n                            propertyName: propertyName\r\n                        };\r\n                    };\r\n                    DataViewObjectsParser.parse = function (dataView) {\r\n                        var dataViewObjectParser = this.getDefault(), properties;\r\n                        if (!dataView || !dataView.metadata || !dataView.metadata.objects) {\r\n                            return dataViewObjectParser;\r\n                        }\r\n                        properties = dataViewObjectParser.getProperties();\r\n                        for (var objectName in properties) {\r\n                            for (var propertyName in properties[objectName]) {\r\n                                var defaultValue = dataViewObjectParser[objectName][propertyName];\r\n                                dataViewObjectParser[objectName][propertyName] = dataview.DataViewObjects.getCommonValue(dataView.metadata.objects, properties[objectName][propertyName], defaultValue);\r\n                            }\r\n                        }\r\n                        return dataViewObjectParser;\r\n                    };\r\n                    DataViewObjectsParser.isPropertyEnumerable = function (propertyName) {\r\n                        return !DataViewObjectsParser.InnumerablePropertyPrefix.test(propertyName);\r\n                    };\r\n                    DataViewObjectsParser.enumerateObjectInstances = function (dataViewObjectParser, options) {\r\n                        var dataViewProperties = dataViewObjectParser && dataViewObjectParser[options.objectName];\r\n                        if (!dataViewProperties) {\r\n                            return [];\r\n                        }\r\n                        var instance = {\r\n                            objectName: options.objectName,\r\n                            selector: null,\r\n                            properties: {}\r\n                        };\r\n                        for (var key in dataViewProperties) {\r\n                            if (dataViewProperties.hasOwnProperty(key)) {\r\n                                instance.properties[key] = dataViewProperties[key];\r\n                            }\r\n                        }\r\n                        return {\r\n                            instances: [instance]\r\n                        };\r\n                    };\r\n                    DataViewObjectsParser.prototype.getProperties = function () {\r\n                        var _this = this;\r\n                        var properties = {}, objectNames = Object.keys(this);\r\n                        objectNames.forEach(function (objectName) {\r\n                            if (DataViewObjectsParser.isPropertyEnumerable(objectName)) {\r\n                                var propertyNames = Object.keys(_this[objectName]);\r\n                                properties[objectName] = {};\r\n                                propertyNames.forEach(function (propertyName) {\r\n                                    if (DataViewObjectsParser.isPropertyEnumerable(objectName)) {\r\n                                        properties[objectName][propertyName] =\r\n                                            DataViewObjectsParser.createPropertyIdentifier(objectName, propertyName);\r\n                                    }\r\n                                });\r\n                            }\r\n                        });\r\n                        return properties;\r\n                    };\r\n                    return DataViewObjectsParser;\r\n                }());\r\n                DataViewObjectsParser.InnumerablePropertyPrefix = /^_/;\r\n                dataview.DataViewObjectsParser = DataViewObjectsParser;\r\n            })(dataview = utils.dataview || (utils.dataview = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\n// Custom implementation of Globalize from PowerView team\r\n// The public implementation from https://github.com/borisyankov/DefinitelyTyped/tree/master/globalize doesn't work\r\n\"use strict\";\r\n/* tslint:disable:no-var-keyword */\r\nvar Globalize = Globalize || window[\"Globalize\"];\r\n/* tslint:enable */\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\"use strict\";\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\"use strict\";\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var formatting;\r\n            (function (formatting) {\r\n                var LocalStorageService = (function () {\r\n                    function LocalStorageService() {\r\n                    }\r\n                    LocalStorageService.prototype.getData = function (key) {\r\n                        try {\r\n                            if (localStorage) {\r\n                                var value = localStorage[key];\r\n                                if (value) {\r\n                                    return JSON.parse(value);\r\n                                }\r\n                            }\r\n                        }\r\n                        catch (exception) { }\r\n                        return null;\r\n                    };\r\n                    LocalStorageService.prototype.setData = function (key, data) {\r\n                        try {\r\n                            if (localStorage) {\r\n                                localStorage[key] = JSON.stringify(data);\r\n                            }\r\n                        }\r\n                        catch (e) { }\r\n                    };\r\n                    return LocalStorageService;\r\n                }());\r\n                formatting.LocalStorageService = LocalStorageService;\r\n            })(formatting = utils.formatting || (utils.formatting = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\"use strict\";\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var formatting;\r\n            (function (formatting) {\r\n                var EphemeralStorageService = (function () {\r\n                    function EphemeralStorageService(clearCacheInterval) {\r\n                        this.cache = {};\r\n                        this.clearCacheInterval = (clearCacheInterval != null)\r\n                            ? clearCacheInterval\r\n                            : EphemeralStorageService.defaultClearCacheInterval;\r\n                        this.clearCache();\r\n                    }\r\n                    EphemeralStorageService.prototype.getData = function (key) {\r\n                        return this.cache[key];\r\n                    };\r\n                    EphemeralStorageService.prototype.setData = function (key, data) {\r\n                        var _this = this;\r\n                        this.cache[key] = data;\r\n                        if (this.clearCacheTimerId == null) {\r\n                            this.clearCacheTimerId = setTimeout(function () { return _this.clearCache(); }, this.clearCacheInterval);\r\n                        }\r\n                    };\r\n                    EphemeralStorageService.prototype.clearCache = function () {\r\n                        this.cache = {};\r\n                        this.clearCacheTimerId = undefined;\r\n                    };\r\n                    return EphemeralStorageService;\r\n                }());\r\n                EphemeralStorageService.defaultClearCacheInterval = (1000 * 60 * 60 * 24); // 1 day\r\n                formatting.EphemeralStorageService = EphemeralStorageService;\r\n                formatting.ephemeralStorageService = new EphemeralStorageService();\r\n            })(formatting = utils.formatting || (utils.formatting = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\"use strict\";\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var formatting;\r\n            (function (formatting) {\r\n                /**\r\n                 * Extensions to String class.\r\n                 */\r\n                var stringExtensions;\r\n                (function (stringExtensions) {\r\n                    var HtmlTagRegex = new RegExp(\"[<>]\", \"g\");\r\n                    /**\r\n                     * Checks if a string ends with a sub-string.\r\n                     */\r\n                    function endsWith(str, suffix) {\r\n                        return str.indexOf(suffix, str.length - suffix.length) !== -1;\r\n                    }\r\n                    stringExtensions.endsWith = endsWith;\r\n                    function format() {\r\n                        var args = [];\r\n                        for (var _i = 0; _i < arguments.length; _i++) {\r\n                            args[_i] = arguments[_i];\r\n                        }\r\n                        var s = args[0];\r\n                        if (isNullOrUndefinedOrWhiteSpaceString(s))\r\n                            return s;\r\n                        for (var i = 0; i < args.length - 1; i++) {\r\n                            var reg = new RegExp(\"\\\\{\" + i + \"\\\\}\", \"gm\");\r\n                            s = s.replace(reg, args[i + 1]);\r\n                        }\r\n                        return s;\r\n                    }\r\n                    stringExtensions.format = format;\r\n                    /**\r\n                     * Compares two strings for equality, ignoring case.\r\n                     */\r\n                    function equalIgnoreCase(a, b) {\r\n                        return stringExtensions.normalizeCase(a) === stringExtensions.normalizeCase(b);\r\n                    }\r\n                    stringExtensions.equalIgnoreCase = equalIgnoreCase;\r\n                    function startsWithIgnoreCase(a, b) {\r\n                        var normalizedSearchString = stringExtensions.normalizeCase(b);\r\n                        return stringExtensions.normalizeCase(a).indexOf(normalizedSearchString) === 0;\r\n                    }\r\n                    stringExtensions.startsWithIgnoreCase = startsWithIgnoreCase;\r\n                    function startsWith(a, b) {\r\n                        return a.indexOf(b) === 0;\r\n                    }\r\n                    stringExtensions.startsWith = startsWith;\r\n                    /** Determines whether a string contains a specified substring (by case-sensitive comparison). */\r\n                    function contains(source, substring) {\r\n                        if (source == null)\r\n                            return false;\r\n                        return source.indexOf(substring) !== -1;\r\n                    }\r\n                    stringExtensions.contains = contains;\r\n                    /** Determines whether a string contains a specified substring (while ignoring case). */\r\n                    function containsIgnoreCase(source, substring) {\r\n                        if (source == null)\r\n                            return false;\r\n                        return contains(normalizeCase(source), normalizeCase(substring));\r\n                    }\r\n                    stringExtensions.containsIgnoreCase = containsIgnoreCase;\r\n                    /**\r\n                     * Normalizes case for a string.\r\n                     * Used by equalIgnoreCase method.\r\n                     */\r\n                    function normalizeCase(value) {\r\n                        return value.toUpperCase();\r\n                    }\r\n                    stringExtensions.normalizeCase = normalizeCase;\r\n                    /**\r\n                     * Receives a string and returns an ArrayBuffer of its characters.\r\n                     * @return An ArrayBuffer of the string's characters.\r\n                     * If the string is empty or null or undefined - returns null.\r\n                     */\r\n                    function stringToArrayBuffer(str) {\r\n                        if (isNullOrEmpty(str)) {\r\n                            return null;\r\n                        }\r\n                        var buffer = new ArrayBuffer(str.length);\r\n                        var bufferView = new Uint8Array(buffer);\r\n                        for (var i = 0, strLen = str.length; i < strLen; i++) {\r\n                            bufferView[i] = str.charCodeAt(i);\r\n                        }\r\n                        return bufferView;\r\n                    }\r\n                    stringExtensions.stringToArrayBuffer = stringToArrayBuffer;\r\n                    /**\r\n                     * Is string null or empty or undefined?\r\n                     * @return True if the value is null or undefined or empty string,\r\n                     * otherwise false.\r\n                     */\r\n                    function isNullOrEmpty(value) {\r\n                        return (value == null) || (value.length === 0);\r\n                    }\r\n                    stringExtensions.isNullOrEmpty = isNullOrEmpty;\r\n                    /**\r\n                     * Returns true if the string is null, undefined, empty, or only includes white spaces.\r\n                     * @return True if the str is null, undefined, empty, or only includes white spaces,\r\n                     * otherwise false.\r\n                     */\r\n                    function isNullOrUndefinedOrWhiteSpaceString(str) {\r\n                        return stringExtensions.isNullOrEmpty(str) || stringExtensions.isNullOrEmpty(str.trim());\r\n                    }\r\n                    stringExtensions.isNullOrUndefinedOrWhiteSpaceString = isNullOrUndefinedOrWhiteSpaceString;\r\n                    /**\r\n                     * Returns a value indicating whether the str contains any whitespace.\r\n                     */\r\n                    function containsWhitespace(str) {\r\n                        var expr = /\\s/;\r\n                        return expr.test(str);\r\n                    }\r\n                    stringExtensions.containsWhitespace = containsWhitespace;\r\n                    /**\r\n                     * Returns a value indicating whether the str is a whitespace string.\r\n                     */\r\n                    function isWhitespace(str) {\r\n                        return str.trim() === \"\";\r\n                    }\r\n                    stringExtensions.isWhitespace = isWhitespace;\r\n                    /**\r\n                     * Returns the string with any trailing whitespace from str removed.\r\n                     */\r\n                    function trimTrailingWhitespace(str) {\r\n                        return str.replace(/\\s+$/, \"\");\r\n                    }\r\n                    stringExtensions.trimTrailingWhitespace = trimTrailingWhitespace;\r\n                    /**\r\n                     * Returns the string with any leading and trailing whitespace from str removed.\r\n                     */\r\n                    function trimWhitespace(str) {\r\n                        return str.replace(/^\\s+/, \"\").replace(/\\s+$/, \"\");\r\n                    }\r\n                    stringExtensions.trimWhitespace = trimWhitespace;\r\n                    /**\r\n                     * Returns length difference between the two provided strings.\r\n                     */\r\n                    function getLengthDifference(left, right) {\r\n                        return Math.abs(left.length - right.length);\r\n                    }\r\n                    stringExtensions.getLengthDifference = getLengthDifference;\r\n                    /**\r\n                     * Repeat char or string several times.\r\n                     * @param char The string to repeat.\r\n                     * @param count How many times to repeat the string.\r\n                     */\r\n                    function repeat(char, count) {\r\n                        var result = \"\";\r\n                        for (var i = 0; i < count; i++) {\r\n                            result += char;\r\n                        }\r\n                        return result;\r\n                    }\r\n                    stringExtensions.repeat = repeat;\r\n                    /**\r\n                     * Replace all the occurrences of the textToFind in the text with the textToReplace.\r\n                     * @param text The original string.\r\n                     * @param textToFind Text to find in the original string.\r\n                     * @param textToReplace New text replacing the textToFind.\r\n                     */\r\n                    function replaceAll(text, textToFind, textToReplace) {\r\n                        if (!textToFind)\r\n                            return text;\r\n                        var pattern = escapeStringForRegex(textToFind);\r\n                        return text.replace(new RegExp(pattern, \"gi\"), textToReplace);\r\n                    }\r\n                    stringExtensions.replaceAll = replaceAll;\r\n                    function ensureUniqueNames(names) {\r\n                        var usedNames = {};\r\n                        // Make sure we are giving fair chance for all columns to stay with their original name\r\n                        // First we fill the used names map to contain all the original unique names from the list.\r\n                        for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {\r\n                            var name_1 = names_1[_i];\r\n                            usedNames[name_1] = false;\r\n                        }\r\n                        var uniqueNames = [];\r\n                        // Now we go over all names and find a unique name for each\r\n                        for (var _a = 0, names_2 = names; _a < names_2.length; _a++) {\r\n                            var name_2 = names_2[_a];\r\n                            var uniqueName = name_2;\r\n                            // If the (original) column name is already taken lets try to find another name\r\n                            if (usedNames[uniqueName]) {\r\n                                var counter = 0;\r\n                                // Find a name that is not already in the map\r\n                                while (usedNames[uniqueName] !== undefined) {\r\n                                    uniqueName = name_2 + \".\" + (++counter);\r\n                                }\r\n                            }\r\n                            uniqueNames.push(uniqueName);\r\n                            usedNames[uniqueName] = true;\r\n                        }\r\n                        return uniqueNames;\r\n                    }\r\n                    stringExtensions.ensureUniqueNames = ensureUniqueNames;\r\n                    /**\r\n                     * Returns a name that is not specified in the values.\r\n                     */\r\n                    function findUniqueName(usedNames, baseName) {\r\n                        // Find a unique name\r\n                        var i = 0, uniqueName = baseName;\r\n                        while (usedNames[uniqueName]) {\r\n                            uniqueName = baseName + (++i);\r\n                        }\r\n                        return uniqueName;\r\n                    }\r\n                    stringExtensions.findUniqueName = findUniqueName;\r\n                    function constructNameFromList(list, separator, maxCharacter) {\r\n                        var labels = [];\r\n                        var exceeded;\r\n                        var length = 0;\r\n                        for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {\r\n                            var item = list_1[_i];\r\n                            if (length + item.length > maxCharacter && labels.length > 0) {\r\n                                exceeded = true;\r\n                                break;\r\n                            }\r\n                            labels.push(item);\r\n                            length += item.length;\r\n                        }\r\n                        var separatorWithSpace = \" \" + separator + \" \";\r\n                        var name = labels.join(separatorWithSpace);\r\n                        if (exceeded)\r\n                            name += separatorWithSpace + \"...\";\r\n                        return name;\r\n                    }\r\n                    stringExtensions.constructNameFromList = constructNameFromList;\r\n                    function escapeStringForRegex(s) {\r\n                        return s.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, \"\\\\$1\");\r\n                    }\r\n                    stringExtensions.escapeStringForRegex = escapeStringForRegex;\r\n                    /**\r\n                     * Remove file name reserved characters <>:\"/\\|?* from input string.\r\n                     */\r\n                    function normalizeFileName(fileName) {\r\n                        return fileName.replace(/[\\<\\>\\:\"\\/\\\\\\|\\?*]/g, \"\");\r\n                    }\r\n                    stringExtensions.normalizeFileName = normalizeFileName;\r\n                    /**\r\n                     * Similar to JSON.stringify, but strips away escape sequences so that the resulting\r\n                     * string is human-readable (and parsable by JSON formatting/validating tools).\r\n                     */\r\n                    function stringifyAsPrettyJSON(object) {\r\n                        // let specialCharacterRemover = (key: string, value: string) => value.replace(/[^\\w\\s]/gi, \"\");\r\n                        return JSON.stringify(object /*, specialCharacterRemover*/);\r\n                    }\r\n                    stringExtensions.stringifyAsPrettyJSON = stringifyAsPrettyJSON;\r\n                    /**\r\n                     * Derive a CLS-compliant name from a specified string.  If no allowed characters are present, return a fallback string instead.\r\n                     * TODO (6708134): this should have a fully Unicode-aware implementation\r\n                     */\r\n                    function deriveClsCompliantName(input, fallback) {\r\n                        var result = input.replace(/^[^A-Za-z]*/g, \"\").replace(/[ :\\.\\/\\\\\\-\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000]/g, \"_\").replace(/[\\W]/g, \"\");\r\n                        return result.length > 0 ? result : fallback;\r\n                    }\r\n                    stringExtensions.deriveClsCompliantName = deriveClsCompliantName;\r\n                    /** Performs cheap sanitization by stripping away HTML tag (<>) characters. */\r\n                    function stripTagDelimiters(s) {\r\n                        return s.replace(HtmlTagRegex, \"\");\r\n                    }\r\n                    stringExtensions.stripTagDelimiters = stripTagDelimiters;\r\n                })(stringExtensions = formatting.stringExtensions || (formatting.stringExtensions = {}));\r\n            })(formatting = utils.formatting || (utils.formatting = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\"use strict\";\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var formatting;\r\n            (function (formatting) {\r\n                var wordBreaker;\r\n                (function (wordBreaker) {\r\n                    var SPACE = \" \";\r\n                    var BREAKERS_REGEX = /[\\s\\n]+/g;\r\n                    function search(index, content, backward) {\r\n                        if (backward) {\r\n                            for (var i = index - 1; i > -1; i--) {\r\n                                if (hasBreakers(content[i]))\r\n                                    return i + 1;\r\n                            }\r\n                        }\r\n                        else {\r\n                            for (var i = index, ilen = content.length; i < ilen; i++) {\r\n                                if (hasBreakers(content[i]))\r\n                                    return i;\r\n                            }\r\n                        }\r\n                        return backward ? 0 : content.length;\r\n                    }\r\n                    /**\r\n                     * Find the word nearest the cursor specified within content\r\n                     * @param index - point within content to search forward/backward from\r\n                     * @param content - string to search\r\n                    */\r\n                    function find(index, content) {\r\n                        var result = { start: 0, end: 0 };\r\n                        if (content.length === 0) {\r\n                            return result;\r\n                        }\r\n                        result.start = search(index, content, true);\r\n                        result.end = search(index, content, false);\r\n                        return result;\r\n                    }\r\n                    wordBreaker.find = find;\r\n                    /**\r\n                     * Test for presence of breakers within content\r\n                     * @param content - string to test\r\n                    */\r\n                    function hasBreakers(content) {\r\n                        BREAKERS_REGEX.lastIndex = 0;\r\n                        return BREAKERS_REGEX.test(content);\r\n                    }\r\n                    wordBreaker.hasBreakers = hasBreakers;\r\n                    /**\r\n                     * Count the number of pieces when broken by BREAKERS_REGEX\r\n                     * ~2.7x faster than WordBreaker.split(content).length\r\n                     * @param content - string to break and count\r\n                    */\r\n                    function wordCount(content) {\r\n                        var count = 1;\r\n                        BREAKERS_REGEX.lastIndex = 0;\r\n                        BREAKERS_REGEX.exec(content);\r\n                        while (BREAKERS_REGEX.lastIndex !== 0) {\r\n                            count++;\r\n                            BREAKERS_REGEX.exec(content);\r\n                        }\r\n                        return count;\r\n                    }\r\n                    wordBreaker.wordCount = wordCount;\r\n                    function getMaxWordWidth(content, textWidthMeasurer, properties) {\r\n                        var words = split(content);\r\n                        var maxWidth = 0;\r\n                        for (var _i = 0, words_1 = words; _i < words_1.length; _i++) {\r\n                            var w = words_1[_i];\r\n                            properties.text = w;\r\n                            maxWidth = Math.max(maxWidth, textWidthMeasurer(properties));\r\n                        }\r\n                        return maxWidth;\r\n                    }\r\n                    wordBreaker.getMaxWordWidth = getMaxWordWidth;\r\n                    function split(content) {\r\n                        return content.split(BREAKERS_REGEX);\r\n                    }\r\n                    function getWidth(content, properties, textWidthMeasurer) {\r\n                        properties.text = content;\r\n                        return textWidthMeasurer(properties);\r\n                    }\r\n                    function truncate(content, properties, truncator, maxWidth) {\r\n                        properties.text = content;\r\n                        return truncator(properties, maxWidth);\r\n                    }\r\n                    /**\r\n                     * Split content by breakers (words) and greedy fit as many words\r\n                     * into each index in the result based on max width and number of lines\r\n                     * e.g. Each index in result corresponds to a line of content\r\n                     *      when used by AxisHelper.LabelLayoutStrategy.wordBreak\r\n                     * @param content - string to split\r\n                     * @param properties - text properties to be used by @param:textWidthMeasurer\r\n                     * @param textWidthMeasurer - function to calculate width of given text content\r\n                     * @param maxWidth - maximum allowed width of text content in each result\r\n                     * @param maxNumLines - maximum number of results we will allow, valid values must be greater than 0\r\n                     * @param truncator - (optional) if specified, used as a function to truncate content to a given width\r\n                    */\r\n                    function splitByWidth(content, properties, textWidthMeasurer, maxWidth, maxNumLines, truncator) {\r\n                        // Default truncator returns string as-is\r\n                        truncator = truncator ? truncator : function (properties, maxWidth) { return properties.text; };\r\n                        var result = [];\r\n                        var words = split(content);\r\n                        var usedWidth = 0;\r\n                        var wordsInLine = [];\r\n                        for (var _i = 0, words_2 = words; _i < words_2.length; _i++) {\r\n                            var word = words_2[_i];\r\n                            // Last line? Just add whatever is left\r\n                            if ((maxNumLines > 0) && (result.length >= maxNumLines - 1)) {\r\n                                wordsInLine.push(word);\r\n                                continue;\r\n                            }\r\n                            // Determine width if we add this word\r\n                            // Account for SPACE we will add when joining...\r\n                            var wordWidth = wordsInLine.length === 0\r\n                                ? getWidth(word, properties, textWidthMeasurer)\r\n                                : getWidth(SPACE + word, properties, textWidthMeasurer);\r\n                            // If width would exceed max width,\r\n                            // then push used words and start new split result\r\n                            if (usedWidth + wordWidth > maxWidth) {\r\n                                // Word alone exceeds max width, just add it.\r\n                                if (wordsInLine.length === 0) {\r\n                                    result.push(truncate(word, properties, truncator, maxWidth));\r\n                                    usedWidth = 0;\r\n                                    wordsInLine = [];\r\n                                    continue;\r\n                                }\r\n                                result.push(truncate(wordsInLine.join(SPACE), properties, truncator, maxWidth));\r\n                                usedWidth = 0;\r\n                                wordsInLine = [];\r\n                            }\r\n                            // ...otherwise, add word and continue\r\n                            wordsInLine.push(word);\r\n                            usedWidth += wordWidth;\r\n                        }\r\n                        // Push remaining words onto result (if any)\r\n                        if (wordsInLine && wordsInLine.length) {\r\n                            result.push(truncate(wordsInLine.join(SPACE), properties, truncator, maxWidth));\r\n                        }\r\n                        return result;\r\n                    }\r\n                    wordBreaker.splitByWidth = splitByWidth;\r\n                })(wordBreaker = formatting.wordBreaker || (formatting.wordBreaker = {}));\r\n            })(formatting = utils.formatting || (utils.formatting = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\"use strict\";\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var formatting;\r\n            (function (formatting) {\r\n                /** Enumeration of DateTimeUnits */\r\n                var DateTimeUnit;\r\n                (function (DateTimeUnit) {\r\n                    DateTimeUnit[DateTimeUnit[\"Year\"] = 0] = \"Year\";\r\n                    DateTimeUnit[DateTimeUnit[\"Month\"] = 1] = \"Month\";\r\n                    DateTimeUnit[DateTimeUnit[\"Week\"] = 2] = \"Week\";\r\n                    DateTimeUnit[DateTimeUnit[\"Day\"] = 3] = \"Day\";\r\n                    DateTimeUnit[DateTimeUnit[\"Hour\"] = 4] = \"Hour\";\r\n                    DateTimeUnit[DateTimeUnit[\"Minute\"] = 5] = \"Minute\";\r\n                    DateTimeUnit[DateTimeUnit[\"Second\"] = 6] = \"Second\";\r\n                    DateTimeUnit[DateTimeUnit[\"Millisecond\"] = 7] = \"Millisecond\";\r\n                })(DateTimeUnit = formatting.DateTimeUnit || (formatting.DateTimeUnit = {}));\r\n            })(formatting = utils.formatting || (utils.formatting = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\"use strict\";\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var formatting;\r\n            (function (formatting) {\r\n                // powerbi.extensibility.utils.type\r\n                var PixelConverter = powerbi.extensibility.utils.type.PixelConverter;\r\n                var Prototype = powerbi.extensibility.utils.type.Prototype;\r\n                // powerbi.extensibility.utils.formatting\r\n                var wordBreaker = powerbi.extensibility.utils.formatting.wordBreaker;\r\n                var textMeasurementService;\r\n                (function (textMeasurementService) {\r\n                    var ellipsis = \"...\";\r\n                    var spanElement;\r\n                    var svgTextElement;\r\n                    var canvasCtx;\r\n                    var fallbackFontFamily;\r\n                    /**\r\n                     * Idempotent function for adding the elements to the DOM.\r\n                     */\r\n                    function ensureDOM() {\r\n                        if (spanElement) {\r\n                            return;\r\n                        }\r\n                        spanElement = document.createElement(\"span\");\r\n                        document.body.appendChild(spanElement);\r\n                        // The style hides the svg element from the canvas, preventing canvas from scrolling down to show svg black square.\r\n                        var svgElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\r\n                        svgElement.setAttribute(\"height\", \"0\");\r\n                        svgElement.setAttribute(\"width\", \"0\");\r\n                        svgElement.setAttribute(\"position\", \"absolute\");\r\n                        svgTextElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\r\n                        svgElement.appendChild(svgTextElement);\r\n                        document.body.appendChild(svgElement);\r\n                        var canvasElement = document.createElement(\"canvas\");\r\n                        canvasCtx = canvasElement.getContext(\"2d\");\r\n                        var style = window.getComputedStyle(svgTextElement);\r\n                        if (style) {\r\n                            fallbackFontFamily = style.fontFamily;\r\n                        }\r\n                        else {\r\n                            fallbackFontFamily = \"\";\r\n                        }\r\n                    }\r\n                    /**\r\n                     * Removes spanElement from DOM.\r\n                     */\r\n                    function removeSpanElement() {\r\n                        if (spanElement && spanElement.remove) {\r\n                            spanElement.remove();\r\n                        }\r\n                        spanElement = null;\r\n                    }\r\n                    textMeasurementService.removeSpanElement = removeSpanElement;\r\n                    /**\r\n                     * This method measures the width of the text with the given SVG text properties.\r\n                     * @param textProperties The text properties to use for text measurement.\r\n                     * @param text The text to measure.\r\n                     */\r\n                    function measureSvgTextWidth(textProperties, text) {\r\n                        ensureDOM();\r\n                        canvasCtx.font =\r\n                            (textProperties.fontStyle || \"\") + \" \" +\r\n                                (textProperties.fontVariant || \"\") + \" \" +\r\n                                (textProperties.fontWeight || \"\") + \" \" +\r\n                                textProperties.fontSize + \" \" +\r\n                                (textProperties.fontFamily || fallbackFontFamily);\r\n                        return canvasCtx.measureText(text || textProperties.text).width;\r\n                    }\r\n                    textMeasurementService.measureSvgTextWidth = measureSvgTextWidth;\r\n                    /**\r\n                     * This method return the rect with the given SVG text properties.\r\n                     * @param textProperties The text properties to use for text measurement.\r\n                     * @param text The text to measure.\r\n                     */\r\n                    function measureSvgTextRect(textProperties, text) {\r\n                        ensureDOM();\r\n                        svgTextElement.setAttribute(\"style\", null);\r\n                        svgTextElement.style.visibility = \"hidden\";\r\n                        svgTextElement.style.fontFamily = textProperties.fontFamily || fallbackFontFamily;\r\n                        svgTextElement.style.fontVariant = textProperties.fontVariant;\r\n                        svgTextElement.style.fontSize = textProperties.fontSize;\r\n                        svgTextElement.style.fontWeight = textProperties.fontWeight;\r\n                        svgTextElement.style.fontStyle = textProperties.fontStyle;\r\n                        svgTextElement.style.whiteSpace = textProperties.whiteSpace || \"nowrap\";\r\n                        svgTextElement.appendChild(document.createTextNode(text || textProperties.text));\r\n                        // We're expecting the browser to give a synchronous measurement here\r\n                        // We're using SVGTextElement because it works across all browsers\r\n                        return svgTextElement.getBBox();\r\n                    }\r\n                    textMeasurementService.measureSvgTextRect = measureSvgTextRect;\r\n                    /**\r\n                     * This method measures the height of the text with the given SVG text properties.\r\n                     * @param textProperties The text properties to use for text measurement.\r\n                     * @param text The text to measure.\r\n                     */\r\n                    function measureSvgTextHeight(textProperties, text) {\r\n                        return measureSvgTextRect(textProperties, text).height;\r\n                    }\r\n                    textMeasurementService.measureSvgTextHeight = measureSvgTextHeight;\r\n                    /**\r\n                     * This method returns the text Rect with the given SVG text properties.\r\n                     * Does NOT return text width; obliterates text value\r\n                     * @param {TextProperties} textProperties - The text properties to use for text measurement\r\n                     */\r\n                    function estimateSvgTextRect(textProperties) {\r\n                        var propertiesKey = textProperties.fontFamily + textProperties.fontSize;\r\n                        var rect = formatting.ephemeralStorageService.getData(propertiesKey);\r\n                        if (rect == null) {\r\n                            // To estimate we check the height of a particular character, once it is cached, subsequent\r\n                            // calls should always get the height from the cache (regardless of the text).\r\n                            var estimatedTextProperties = {\r\n                                fontFamily: textProperties.fontFamily,\r\n                                fontSize: textProperties.fontSize,\r\n                                text: \"M\",\r\n                            };\r\n                            rect = textMeasurementService.measureSvgTextRect(estimatedTextProperties);\r\n                            // NOTE: In some cases (disconnected/hidden DOM) we may provide incorrect measurement results (zero sized bounding-box), so\r\n                            // we only store values in the cache if we are confident they are correct.\r\n                            if (rect.height > 0)\r\n                                formatting.ephemeralStorageService.setData(propertiesKey, rect);\r\n                        }\r\n                        return rect;\r\n                    }\r\n                    /**\r\n                     * This method returns the text Rect with the given SVG text properties.\r\n                     * @param {TextProperties} textProperties - The text properties to use for text measurement\r\n                     */\r\n                    function estimateSvgTextBaselineDelta(textProperties) {\r\n                        var rect = estimateSvgTextRect(textProperties);\r\n                        return rect.y + rect.height;\r\n                    }\r\n                    textMeasurementService.estimateSvgTextBaselineDelta = estimateSvgTextBaselineDelta;\r\n                    /**\r\n                     * This method estimates the height of the text with the given SVG text properties.\r\n                     * @param {TextProperties} textProperties - The text properties to use for text measurement\r\n                     */\r\n                    function estimateSvgTextHeight(textProperties, tightFightForNumeric) {\r\n                        if (tightFightForNumeric === void 0) { tightFightForNumeric = false; }\r\n                        var height = estimateSvgTextRect(textProperties).height;\r\n                        // TODO: replace it with new baseline calculation\r\n                        if (tightFightForNumeric)\r\n                            height *= 0.7;\r\n                        return height;\r\n                    }\r\n                    textMeasurementService.estimateSvgTextHeight = estimateSvgTextHeight;\r\n                    /**\r\n                     * This method measures the width of the svgElement.\r\n                     * @param svgElement The SVGTextElement to be measured.\r\n                     */\r\n                    function measureSvgTextElementWidth(svgElement) {\r\n                        return measureSvgTextWidth(getSvgMeasurementProperties(svgElement));\r\n                    }\r\n                    textMeasurementService.measureSvgTextElementWidth = measureSvgTextElementWidth;\r\n                    /**\r\n                     * This method fetches the text measurement properties of the given DOM element.\r\n                     * @param element The selector for the DOM Element.\r\n                     */\r\n                    function getMeasurementProperties(element) {\r\n                        var style = window.getComputedStyle(element);\r\n                        return {\r\n                            text: element.value || element.textContent,\r\n                            fontFamily: style.fontFamily,\r\n                            fontSize: style.fontSize,\r\n                            fontWeight: style.fontWeight,\r\n                            fontStyle: style.fontStyle,\r\n                            fontVariant: style.fontVariant,\r\n                            whiteSpace: style.whiteSpace\r\n                        };\r\n                    }\r\n                    textMeasurementService.getMeasurementProperties = getMeasurementProperties;\r\n                    /**\r\n                     * This method fetches the text measurement properties of the given SVG text element.\r\n                     * @param element The SVGTextElement to be measured.\r\n                     */\r\n                    function getSvgMeasurementProperties(element) {\r\n                        var style = window.getComputedStyle(element);\r\n                        if (style) {\r\n                            return {\r\n                                text: element.textContent,\r\n                                fontFamily: style.fontFamily,\r\n                                fontSize: style.fontSize,\r\n                                fontWeight: style.fontWeight,\r\n                                fontStyle: style.fontStyle,\r\n                                fontVariant: style.fontVariant,\r\n                                whiteSpace: style.whiteSpace\r\n                            };\r\n                        }\r\n                        else {\r\n                            return {\r\n                                text: element.textContent,\r\n                                fontFamily: \"\",\r\n                                fontSize: \"0\",\r\n                            };\r\n                        }\r\n                    }\r\n                    textMeasurementService.getSvgMeasurementProperties = getSvgMeasurementProperties;\r\n                    /**\r\n                     * This method returns the width of a div element.\r\n                     * @param element The div element.\r\n                     */\r\n                    function getDivElementWidth(element) {\r\n                        var style = window.getComputedStyle(element);\r\n                        if (style)\r\n                            return style.width;\r\n                        else\r\n                            return \"0\";\r\n                    }\r\n                    textMeasurementService.getDivElementWidth = getDivElementWidth;\r\n                    /**\r\n                     * Compares labels text size to the available size and renders ellipses when the available size is smaller.\r\n                     * @param textProperties The text properties (including text content) to use for text measurement.\r\n                     * @param maxWidth The maximum width available for rendering the text.\r\n                     */\r\n                    function getTailoredTextOrDefault(textProperties, maxWidth) {\r\n                        ensureDOM();\r\n                        var strLength = textProperties.text.length;\r\n                        if (strLength === 0) {\r\n                            return textProperties.text;\r\n                        }\r\n                        var width = measureSvgTextWidth(textProperties);\r\n                        if (width < maxWidth) {\r\n                            return textProperties.text;\r\n                        }\r\n                        // Create a copy of the textProperties so we don't modify the one that's passed in.\r\n                        var copiedTextProperties = Prototype.inherit(textProperties);\r\n                        // Take the properties and apply them to svgTextElement\r\n                        // Then, do the binary search to figure out the substring we want\r\n                        // Set the substring on textElement argument\r\n                        var text = copiedTextProperties.text = ellipsis + copiedTextProperties.text;\r\n                        var min = 1;\r\n                        var max = text.length;\r\n                        var i = ellipsis.length;\r\n                        while (min <= max) {\r\n                            // num | 0 prefered to Math.floor(num) for performance benefits\r\n                            i = (min + max) / 2 | 0;\r\n                            copiedTextProperties.text = text.substr(0, i);\r\n                            width = measureSvgTextWidth(copiedTextProperties);\r\n                            if (maxWidth > width) {\r\n                                min = i + 1;\r\n                            }\r\n                            else if (maxWidth < width) {\r\n                                max = i - 1;\r\n                            }\r\n                            else {\r\n                                break;\r\n                            }\r\n                        }\r\n                        // Since the search algorithm almost never finds an exact match,\r\n                        // it will pick one of the closest two, which could result in a\r\n                        // value bigger with than 'maxWidth' thus we need to go back by\r\n                        // one to guarantee a smaller width than 'maxWidth'.\r\n                        copiedTextProperties.text = text.substr(0, i);\r\n                        width = measureSvgTextWidth(copiedTextProperties);\r\n                        if (width > maxWidth) {\r\n                            i--;\r\n                        }\r\n                        return text.substr(ellipsis.length, i - ellipsis.length) + ellipsis;\r\n                    }\r\n                    textMeasurementService.getTailoredTextOrDefault = getTailoredTextOrDefault;\r\n                    /**\r\n                     * Compares labels text size to the available size and renders ellipses when the available size is smaller.\r\n                     * @param textElement The SVGTextElement containing the text to render.\r\n                     * @param maxWidth The maximum width available for rendering the text.\r\n                     */\r\n                    function svgEllipsis(textElement, maxWidth) {\r\n                        var properties = getSvgMeasurementProperties(textElement);\r\n                        var originalText = properties.text;\r\n                        var tailoredText = getTailoredTextOrDefault(properties, maxWidth);\r\n                        if (originalText !== tailoredText) {\r\n                            textElement.textContent = tailoredText;\r\n                        }\r\n                    }\r\n                    textMeasurementService.svgEllipsis = svgEllipsis;\r\n                    /**\r\n                     * Word break textContent of <text> SVG element into <tspan>s\r\n                     * Each tspan will be the height of a single line of text\r\n                     * @param textElement - the SVGTextElement containing the text to wrap\r\n                     * @param maxWidth - the maximum width available\r\n                     * @param maxHeight - the maximum height available (defaults to single line)\r\n                     * @param linePadding - (optional) padding to add to line height\r\n                     */\r\n                    function wordBreak(textElement, maxWidth, maxHeight, linePadding) {\r\n                        if (linePadding === void 0) { linePadding = 0; }\r\n                        var properties = getSvgMeasurementProperties(textElement);\r\n                        var height = estimateSvgTextHeight(properties) + linePadding;\r\n                        var maxNumLines = Math.max(1, Math.floor(maxHeight / height));\r\n                        // Save y of parent textElement to apply as first tspan dy\r\n                        var firstDY = textElement ? textElement.getAttribute(\"y\") : null;\r\n                        // Store and clear text content\r\n                        var labelText = textElement ? textElement.textContent : null;\r\n                        textElement.textContent = null;\r\n                        // Append a tspan for each word broken section\r\n                        var words = wordBreaker.splitByWidth(labelText, properties, measureSvgTextWidth, maxWidth, maxNumLines);\r\n                        var fragment = document.createDocumentFragment();\r\n                        for (var i = 0, ilen = words.length; i < ilen; i++) {\r\n                            var dy = i === 0 ? firstDY : height;\r\n                            properties.text = words[i];\r\n                            var textElement_1 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"tspan\");\r\n                            textElement_1.setAttribute(\"x\", \"0\");\r\n                            textElement_1.setAttribute(\"dy\", dy ? dy.toString() : null);\r\n                            textElement_1.appendChild(document.createTextNode(getTailoredTextOrDefault(properties, maxWidth)));\r\n                            fragment.appendChild(textElement_1);\r\n                        }\r\n                        textElement.appendChild(fragment);\r\n                    }\r\n                    textMeasurementService.wordBreak = wordBreak;\r\n                    /**\r\n                     * Word break textContent of span element into <span>s\r\n                     * Each span will be the height of a single line of text\r\n                     * @param textElement - the element containing the text to wrap\r\n                     * @param maxWidth - the maximum width available\r\n                     * @param maxHeight - the maximum height available (defaults to single line)\r\n                     * @param linePadding - (optional) padding to add to line height\r\n                     */\r\n                    function wordBreakOverflowingText(textElement, maxWidth, maxHeight, linePadding) {\r\n                        if (linePadding === void 0) { linePadding = 0; }\r\n                        var properties = getSvgMeasurementProperties(textElement);\r\n                        var height = estimateSvgTextHeight(properties) + linePadding;\r\n                        var maxNumLines = Math.max(1, Math.floor(maxHeight / height));\r\n                        // Store and clear text content\r\n                        var labelText = textElement.textContent;\r\n                        textElement.textContent = null;\r\n                        // Append a span for each word broken section\r\n                        var words = wordBreaker.splitByWidth(labelText, properties, measureSvgTextWidth, maxWidth, maxNumLines);\r\n                        var fragment = document.createDocumentFragment();\r\n                        for (var i = 0; i < words.length; i++) {\r\n                            var span = document.createElement(\"span\");\r\n                            span.classList.add(\"overflowingText\");\r\n                            span.style.width = PixelConverter.toString(maxWidth);\r\n                            span.appendChild(document.createTextNode(words[i]));\r\n                            span.appendChild(document.createTextNode(getTailoredTextOrDefault(properties, maxWidth)));\r\n                            fragment.appendChild(span);\r\n                        }\r\n                        textElement.appendChild(fragment);\r\n                    }\r\n                    textMeasurementService.wordBreakOverflowingText = wordBreakOverflowingText;\r\n                })(textMeasurementService = formatting.textMeasurementService || (formatting.textMeasurementService = {}));\r\n            })(formatting = utils.formatting || (utils.formatting = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\"use strict\";\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var formatting;\r\n            (function (formatting) {\r\n                /** dateUtils module provides DateTimeSequence with set of additional date manipulation routines */\r\n                var dateUtils;\r\n                (function (dateUtils) {\r\n                    var MonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\r\n                    var MonthDaysLeap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\r\n                    /**\r\n                     * Returns bool indicating weither the provided year is a leap year.\r\n                     * @param year - year value\r\n                     */\r\n                    function isLeap(year) {\r\n                        return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);\r\n                    }\r\n                    /**\r\n                     * Returns number of days in the provided year/month.\r\n                     * @param year - year value\r\n                     * @param month - month value\r\n                     */\r\n                    function getMonthDays(year, month) {\r\n                        return isLeap(year) ? MonthDaysLeap[month] : MonthDays[month];\r\n                    }\r\n                    /**\r\n                     * Adds a specified number of years to the provided date.\r\n                     * @param date - date value\r\n                     * @param yearDelta - number of years to add\r\n                     */\r\n                    function addYears(date, yearDelta) {\r\n                        var year = date.getFullYear();\r\n                        var month = date.getMonth();\r\n                        var day = date.getDate();\r\n                        var isLeapDay = month === 2 && day === 29;\r\n                        var result = new Date(date.getTime());\r\n                        year = year + yearDelta;\r\n                        if (isLeapDay && !isLeap(year)) {\r\n                            day = 28;\r\n                        }\r\n                        result.setFullYear(year, month, day);\r\n                        return result;\r\n                    }\r\n                    dateUtils.addYears = addYears;\r\n                    /**\r\n                     * Adds a specified number of months to the provided date.\r\n                     * @param date - date value\r\n                     * @param monthDelta - number of months to add\r\n                     */\r\n                    function addMonths(date, monthDelta) {\r\n                        var year = date.getFullYear();\r\n                        var month = date.getMonth();\r\n                        var day = date.getDate();\r\n                        var result = new Date(date.getTime());\r\n                        year += (monthDelta - (monthDelta % 12)) / 12;\r\n                        month += monthDelta % 12;\r\n                        // VSTS 1325771: Certain column charts don't display any data\r\n                        // Wrap arround the month if is after december (value 11)\r\n                        if (month > 11) {\r\n                            month = month % 12;\r\n                            year++;\r\n                        }\r\n                        day = Math.min(day, getMonthDays(year, month));\r\n                        result.setFullYear(year, month, day);\r\n                        return result;\r\n                    }\r\n                    dateUtils.addMonths = addMonths;\r\n                    /**\r\n                     * Adds a specified number of weeks to the provided date.\r\n                     * @param date - date value\r\n                     * @param weeks - number of weeks to add\r\n                     */\r\n                    function addWeeks(date, weeks) {\r\n                        return addDays(date, weeks * 7);\r\n                    }\r\n                    dateUtils.addWeeks = addWeeks;\r\n                    /**\r\n                     * Adds a specified number of days to the provided date.\r\n                     * @param date - date value\r\n                     * @param days - number of days to add\r\n                     */\r\n                    function addDays(date, days) {\r\n                        var year = date.getFullYear();\r\n                        var month = date.getMonth();\r\n                        var day = date.getDate();\r\n                        var result = new Date(date.getTime());\r\n                        result.setFullYear(year, month, day + days);\r\n                        return result;\r\n                    }\r\n                    dateUtils.addDays = addDays;\r\n                    /**\r\n                     * Adds a specified number of hours to the provided date.\r\n                     * @param date - date value\r\n                     * @param hours - number of hours to add\r\n                     */\r\n                    function addHours(date, hours) {\r\n                        return new Date(date.getTime() + hours * 3600000);\r\n                    }\r\n                    dateUtils.addHours = addHours;\r\n                    /**\r\n                     * Adds a specified number of minutes to the provided date.\r\n                     * @param date - date value\r\n                     * @param minutes - number of minutes to add\r\n                     */\r\n                    function addMinutes(date, minutes) {\r\n                        return new Date(date.getTime() + minutes * 60000);\r\n                    }\r\n                    dateUtils.addMinutes = addMinutes;\r\n                    /**\r\n                     * Adds a specified number of seconds to the provided date.\r\n                     * @param date - date value\r\n                     * @param seconds - number of seconds to add\r\n                     */\r\n                    function addSeconds(date, seconds) {\r\n                        return new Date(date.getTime() + seconds * 1000);\r\n                    }\r\n                    dateUtils.addSeconds = addSeconds;\r\n                    /**\r\n                     * Adds a specified number of milliseconds to the provided date.\r\n                     * @param date - date value\r\n                     * @param milliseconds - number of milliseconds to add\r\n                     */\r\n                    function addMilliseconds(date, milliseconds) {\r\n                        return new Date(date.getTime() + milliseconds);\r\n                    }\r\n                    dateUtils.addMilliseconds = addMilliseconds;\r\n                })(dateUtils = formatting.dateUtils || (formatting.dateUtils = {}));\r\n            })(formatting = utils.formatting || (utils.formatting = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\"use strict\";\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var formatting;\r\n            (function (formatting) {\r\n                // powerbi.extensibility.utils.type\r\n                var NumericSequenceRange = powerbi.extensibility.utils.type.NumericSequenceRange;\r\n                var NumericSequence = powerbi.extensibility.utils.type.NumericSequence;\r\n                var Double = powerbi.extensibility.utils.type.Double;\r\n                // powerbi.extensibility.utils.formatting\r\n                var DateTimeUnit = powerbi.extensibility.utils.formatting.DateTimeUnit;\r\n                /** Repreasents the sequence of the dates/times */\r\n                var DateTimeSequence = (function () {\r\n                    // Constructors\r\n                    /** Creates new instance of the DateTimeSequence */\r\n                    function DateTimeSequence(unit) {\r\n                        this.unit = unit;\r\n                        this.sequence = [];\r\n                        this.min = new Date(\"9999-12-31T23:59:59.999\");\r\n                        this.max = new Date(\"0001-01-01T00:00:00.000\");\r\n                    }\r\n                    // Methods\r\n                    /**\r\n                     * Add a new Date to a sequence.\r\n                     * @param date - date to add\r\n                     */\r\n                    DateTimeSequence.prototype.add = function (date) {\r\n                        if (date < this.min) {\r\n                            this.min = date;\r\n                        }\r\n                        if (date > this.max) {\r\n                            this.max = date;\r\n                        }\r\n                        this.sequence.push(date);\r\n                    };\r\n                    // Methods\r\n                    /**\r\n                     * Extends the sequence to cover new date range\r\n                     * @param min - new min to be covered by sequence\r\n                     * @param max - new max to be covered by sequence\r\n                     */\r\n                    DateTimeSequence.prototype.extendToCover = function (min, max) {\r\n                        var x = this.min;\r\n                        while (min < x) {\r\n                            x = DateTimeSequence.addInterval(x, -this.interval, this.unit);\r\n                            this.sequence.splice(0, 0, x);\r\n                        }\r\n                        this.min = x;\r\n                        x = this.max;\r\n                        while (x < max) {\r\n                            x = DateTimeSequence.addInterval(x, this.interval, this.unit);\r\n                            this.sequence.push(x);\r\n                        }\r\n                        this.max = x;\r\n                    };\r\n                    /**\r\n                     * Move the sequence to cover new date range\r\n                     * @param min - new min to be covered by sequence\r\n                     * @param max - new max to be covered by sequence\r\n                     */\r\n                    DateTimeSequence.prototype.moveToCover = function (min, max) {\r\n                        var delta = DateTimeSequence.getDelta(min, max, this.unit);\r\n                        var count = Math.floor(delta / this.interval);\r\n                        this.min = DateTimeSequence.addInterval(this.min, count * this.interval, this.unit);\r\n                        this.sequence = [];\r\n                        this.sequence.push(this.min);\r\n                        this.max = this.min;\r\n                        while (this.max < max) {\r\n                            this.max = DateTimeSequence.addInterval(this.max, this.interval, this.unit);\r\n                            this.sequence.push(this.max);\r\n                        }\r\n                    };\r\n                    // Static\r\n                    /**\r\n                     * Calculate a new DateTimeSequence\r\n                     * @param dataMin - Date representing min of the data range\r\n                     * @param dataMax - Date representing max of the data range\r\n                     * @param expectedCount - expected number of intervals in the sequence\r\n                     * @param unit - of the intervals in the sequence\r\n                     */\r\n                    DateTimeSequence.calculate = function (dataMin, dataMax, expectedCount, unit) {\r\n                        if (!unit) {\r\n                            unit = DateTimeSequence.getIntervalUnit(dataMin, dataMax, expectedCount);\r\n                        }\r\n                        switch (unit) {\r\n                            case DateTimeUnit.Year:\r\n                                return DateTimeSequence.calculateYears(dataMin, dataMax, expectedCount);\r\n                            case DateTimeUnit.Month:\r\n                                return DateTimeSequence.calculateMonths(dataMin, dataMax, expectedCount);\r\n                            case DateTimeUnit.Week:\r\n                                return DateTimeSequence.calculateWeeks(dataMin, dataMax, expectedCount);\r\n                            case DateTimeUnit.Day:\r\n                                return DateTimeSequence.calculateDays(dataMin, dataMax, expectedCount);\r\n                            case DateTimeUnit.Hour:\r\n                                return DateTimeSequence.calculateHours(dataMin, dataMax, expectedCount);\r\n                            case DateTimeUnit.Minute:\r\n                                return DateTimeSequence.calculateMinutes(dataMin, dataMax, expectedCount);\r\n                            case DateTimeUnit.Second:\r\n                                return DateTimeSequence.calculateSeconds(dataMin, dataMax, expectedCount);\r\n                            case DateTimeUnit.Millisecond:\r\n                                return DateTimeSequence.calculateMilliseconds(dataMin, dataMax, expectedCount);\r\n                        }\r\n                    };\r\n                    DateTimeSequence.calculateYears = function (dataMin, dataMax, expectedCount) {\r\n                        // Calculate range and sequence\r\n                        var yearsRange = NumericSequenceRange.calculateDataRange(dataMin.getFullYear(), dataMax.getFullYear(), false);\r\n                        // Calculate year sequence\r\n                        var sequence = NumericSequence.calculate(NumericSequenceRange.calculate(0, yearsRange.max - yearsRange.min), expectedCount, 0, null, null, [1, 2, 5]);\r\n                        var newMinYear = Math.floor(yearsRange.min / sequence.interval) * sequence.interval;\r\n                        var date = new Date(newMinYear, 0, 1);\r\n                        // Convert to date sequence\r\n                        var result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Year);\r\n                        return result;\r\n                    };\r\n                    DateTimeSequence.calculateMonths = function (dataMin, dataMax, expectedCount) {\r\n                        // Calculate range\r\n                        var minYear = dataMin.getFullYear();\r\n                        var maxYear = dataMax.getFullYear();\r\n                        var minMonth = dataMin.getMonth();\r\n                        var maxMonth = (maxYear - minYear) * 12 + dataMax.getMonth();\r\n                        var date = new Date(minYear, 0, 1);\r\n                        // Calculate month sequence\r\n                        var sequence = NumericSequence.calculateUnits(minMonth, maxMonth, expectedCount, [1, 2, 3, 6, 12]);\r\n                        // Convert to date sequence\r\n                        var result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Month);\r\n                        return result;\r\n                    };\r\n                    DateTimeSequence.calculateWeeks = function (dataMin, dataMax, expectedCount) {\r\n                        var firstDayOfWeek = 0;\r\n                        var minDayOfWeek = dataMin.getDay();\r\n                        var dayOffset = (minDayOfWeek - firstDayOfWeek + 7) % 7;\r\n                        var minDay = dataMin.getDate() - dayOffset;\r\n                        // Calculate range\r\n                        var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), minDay);\r\n                        var min = 0;\r\n                        var max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Week));\r\n                        // Calculate week sequence\r\n                        var sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 4, 8]);\r\n                        // Convert to date sequence\r\n                        var result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Week);\r\n                        return result;\r\n                    };\r\n                    DateTimeSequence.calculateDays = function (dataMin, dataMax, expectedCount) {\r\n                        // Calculate range\r\n                        var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\r\n                        var min = 0;\r\n                        var max = Double.ceilWithPrecision(DateTimeSequence.getDelta(dataMin, dataMax, DateTimeUnit.Day));\r\n                        // Calculate day sequence\r\n                        var sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 7, 14]);\r\n                        // Convert to date sequence\r\n                        var result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Day);\r\n                        return result;\r\n                    };\r\n                    DateTimeSequence.calculateHours = function (dataMin, dataMax, expectedCount) {\r\n                        // Calculate range\r\n                        var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\r\n                        var min = Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Hour));\r\n                        var max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Hour));\r\n                        // Calculate hour sequence\r\n                        var sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 3, 6, 12, 24]);\r\n                        // Convert to date sequence\r\n                        var result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Hour);\r\n                        return result;\r\n                    };\r\n                    DateTimeSequence.calculateMinutes = function (dataMin, dataMax, expectedCount) {\r\n                        // Calculate range\r\n                        var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours());\r\n                        var min = Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Minute));\r\n                        var max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Minute));\r\n                        // Calculate minutes numeric sequence\r\n                        var sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 3, 60 * 6, 60 * 12, 60 * 24]);\r\n                        // Convert to date sequence\r\n                        var result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Minute);\r\n                        return result;\r\n                    };\r\n                    DateTimeSequence.calculateSeconds = function (dataMin, dataMax, expectedCount) {\r\n                        // Calculate range\r\n                        var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes());\r\n                        var min = Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Second));\r\n                        var max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Second));\r\n                        // Calculate minutes numeric sequence\r\n                        var sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 5, 60 * 10, 60 * 15, 60 * 30, 60 * 60]);\r\n                        // Convert to date sequence\r\n                        var result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Second);\r\n                        return result;\r\n                    };\r\n                    DateTimeSequence.calculateMilliseconds = function (dataMin, dataMax, expectedCount) {\r\n                        // Calculate range\r\n                        var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes(), dataMin.getSeconds());\r\n                        var min = DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Millisecond);\r\n                        var max = DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Millisecond);\r\n                        // Calculate milliseconds numeric sequence\r\n                        var sequence = NumericSequence.calculate(NumericSequenceRange.calculate(min, max), expectedCount, 0);\r\n                        // Convert to date sequence\r\n                        var result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Millisecond);\r\n                        return result;\r\n                    };\r\n                    DateTimeSequence.addInterval = function (value, interval, unit) {\r\n                        interval = Math.round(interval);\r\n                        switch (unit) {\r\n                            case DateTimeUnit.Year:\r\n                                return formatting.dateUtils.addYears(value, interval);\r\n                            case DateTimeUnit.Month:\r\n                                return formatting.dateUtils.addMonths(value, interval);\r\n                            case DateTimeUnit.Week:\r\n                                return formatting.dateUtils.addWeeks(value, interval);\r\n                            case DateTimeUnit.Day:\r\n                                return formatting.dateUtils.addDays(value, interval);\r\n                            case DateTimeUnit.Hour:\r\n                                return formatting.dateUtils.addHours(value, interval);\r\n                            case DateTimeUnit.Minute:\r\n                                return formatting.dateUtils.addMinutes(value, interval);\r\n                            case DateTimeUnit.Second:\r\n                                return formatting.dateUtils.addSeconds(value, interval);\r\n                            case DateTimeUnit.Millisecond:\r\n                                return formatting.dateUtils.addMilliseconds(value, interval);\r\n                        }\r\n                    };\r\n                    DateTimeSequence.fromNumericSequence = function (date, sequence, unit) {\r\n                        var result = new DateTimeSequence(unit);\r\n                        for (var i = 0; i < sequence.sequence.length; i++) {\r\n                            var x = sequence.sequence[i];\r\n                            var d = DateTimeSequence.addInterval(date, x, unit);\r\n                            result.add(d);\r\n                        }\r\n                        result.interval = sequence.interval;\r\n                        result.intervalOffset = sequence.intervalOffset;\r\n                        return result;\r\n                    };\r\n                    DateTimeSequence.getDelta = function (min, max, unit) {\r\n                        var delta = 0;\r\n                        switch (unit) {\r\n                            case DateTimeUnit.Year:\r\n                                delta = max.getFullYear() - min.getFullYear();\r\n                                break;\r\n                            case DateTimeUnit.Month:\r\n                                delta = (max.getFullYear() - min.getFullYear()) * 12 + max.getMonth() - min.getMonth();\r\n                                break;\r\n                            case DateTimeUnit.Week:\r\n                                delta = (max.getTime() - min.getTime()) / (7 * 24 * 3600000);\r\n                                break;\r\n                            case DateTimeUnit.Day:\r\n                                delta = (max.getTime() - min.getTime()) / (24 * 3600000);\r\n                                break;\r\n                            case DateTimeUnit.Hour:\r\n                                delta = (max.getTime() - min.getTime()) / 3600000;\r\n                                break;\r\n                            case DateTimeUnit.Minute:\r\n                                delta = (max.getTime() - min.getTime()) / 60000;\r\n                                break;\r\n                            case DateTimeUnit.Second:\r\n                                delta = (max.getTime() - min.getTime()) / 1000;\r\n                                break;\r\n                            case DateTimeUnit.Millisecond:\r\n                                delta = max.getTime() - min.getTime();\r\n                                break;\r\n                        }\r\n                        return delta;\r\n                    };\r\n                    DateTimeSequence.getIntervalUnit = function (min, max, maxCount) {\r\n                        maxCount = Math.max(maxCount, 2);\r\n                        var totalDays = DateTimeSequence.getDelta(min, max, DateTimeUnit.Day);\r\n                        if (totalDays > 356 && totalDays >= 30 * 6 * maxCount)\r\n                            return DateTimeUnit.Year;\r\n                        if (totalDays > 60 && totalDays > 7 * maxCount)\r\n                            return DateTimeUnit.Month;\r\n                        if (totalDays > 14 && totalDays > 2 * maxCount)\r\n                            return DateTimeUnit.Week;\r\n                        var totalHours = DateTimeSequence.getDelta(min, max, DateTimeUnit.Hour);\r\n                        if (totalDays > 2 && totalHours > 12 * maxCount)\r\n                            return DateTimeUnit.Day;\r\n                        if (totalHours >= 24 && totalHours >= maxCount)\r\n                            return DateTimeUnit.Hour;\r\n                        var totalMinutes = DateTimeSequence.getDelta(min, max, DateTimeUnit.Minute);\r\n                        if (totalMinutes > 2 && totalMinutes >= maxCount)\r\n                            return DateTimeUnit.Minute;\r\n                        var totalSeconds = DateTimeSequence.getDelta(min, max, DateTimeUnit.Second);\r\n                        if (totalSeconds > 2 && totalSeconds >= 0.8 * maxCount)\r\n                            return DateTimeUnit.Second;\r\n                        var totalMilliseconds = DateTimeSequence.getDelta(min, max, DateTimeUnit.Millisecond);\r\n                        if (totalMilliseconds > 0)\r\n                            return DateTimeUnit.Millisecond;\r\n                        // If the size of the range is 0 we need to guess the unit based on the date's non-zero values starting with milliseconds\r\n                        var date = min;\r\n                        if (date.getMilliseconds() !== 0)\r\n                            return DateTimeUnit.Millisecond;\r\n                        if (date.getSeconds() !== 0)\r\n                            return DateTimeUnit.Second;\r\n                        if (date.getMinutes() !== 0)\r\n                            return DateTimeUnit.Minute;\r\n                        if (date.getHours() !== 0)\r\n                            return DateTimeUnit.Hour;\r\n                        if (date.getDate() !== 1)\r\n                            return DateTimeUnit.Day;\r\n                        if (date.getMonth() !== 0)\r\n                            return DateTimeUnit.Month;\r\n                        return DateTimeUnit.Year;\r\n                    };\r\n                    return DateTimeSequence;\r\n                }());\r\n                // Constants\r\n                DateTimeSequence.MIN_COUNT = 1;\r\n                DateTimeSequence.MAX_COUNT = 1000;\r\n                formatting.DateTimeSequence = DateTimeSequence;\r\n            })(formatting = utils.formatting || (utils.formatting = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\"use strict\";\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var formatting;\r\n            (function (formatting) {\r\n                var regexCache;\r\n                /**\r\n                 * Translate .NET format into something supported by jQuery.Globalize.\r\n                 */\r\n                function findDateFormat(value, format, cultureName) {\r\n                    switch (format) {\r\n                        case \"m\":\r\n                            // Month + day\r\n                            format = \"M\";\r\n                            break;\r\n                        case \"O\":\r\n                        case \"o\":\r\n                            // Roundtrip\r\n                            format = \"yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fff'0000'\";\r\n                            break;\r\n                        case \"R\":\r\n                        case \"r\":\r\n                            // RFC1123 pattern - - time must be converted to UTC before formatting\r\n                            value = new Date(value.getUTCFullYear(), value.getUTCMonth(), value.getUTCDate(), value.getUTCHours(), value.getUTCMinutes(), value.getUTCSeconds(), value.getUTCMilliseconds());\r\n                            format = \"ddd, dd MMM yyyy HH':'mm':'ss 'GMT'\";\r\n                            break;\r\n                        case \"s\":\r\n                            // Sortable - should use invariant culture\r\n                            format = \"S\";\r\n                            break;\r\n                        case \"u\":\r\n                            // Universal sortable - should convert to UTC before applying the \"yyyy'-'MM'-'dd HH':'mm':'ss'Z' format.\r\n                            value = new Date(value.getUTCFullYear(), value.getUTCMonth(), value.getUTCDate(), value.getUTCHours(), value.getUTCMinutes(), value.getUTCSeconds(), value.getUTCMilliseconds());\r\n                            format = \"yyyy'-'MM'-'dd HH':'mm':'ss'Z'\";\r\n                            break;\r\n                        case \"U\":\r\n                            // Universal full - the pattern is same as F but the time must be converted to UTC before formatting\r\n                            value = new Date(value.getUTCFullYear(), value.getUTCMonth(), value.getUTCDate(), value.getUTCHours(), value.getUTCMinutes(), value.getUTCSeconds(), value.getUTCMilliseconds());\r\n                            format = \"F\";\r\n                            break;\r\n                        case \"y\":\r\n                        case \"Y\":\r\n                            // Year and month\r\n                            switch (cultureName) {\r\n                                case \"default\":\r\n                                case \"en\":\r\n                                case \"en-US\":\r\n                                    format = \"MMMM, yyyy\"; // Fix the default year-month pattern for english\r\n                                    break;\r\n                                default:\r\n                                    format = \"Y\"; // For other cultures - use the localized pattern\r\n                            }\r\n                            break;\r\n                    }\r\n                    return { value: value, format: format };\r\n                }\r\n                formatting.findDateFormat = findDateFormat;\r\n                /**\r\n                 * Translates unsupported .NET custom format expressions to the custom expressions supported by JQuery.Globalize.\r\n                 */\r\n                function fixDateTimeFormat(format) {\r\n                    // Fix for the \"K\" format (timezone):\r\n                    // T he js dates don't have a kind property so we'll support only local kind which is equavalent to zzz format.\r\n                    format = format.replace(/%K/g, \"zzz\");\r\n                    format = format.replace(/K/g, \"zzz\");\r\n                    format = format.replace(/fffffff/g, \"fff0000\");\r\n                    format = format.replace(/ffffff/g, \"fff000\");\r\n                    format = format.replace(/fffff/g, \"fff00\");\r\n                    format = format.replace(/ffff/g, \"fff0\");\r\n                    // Fix for the 5 digit year: \"yyyyy\" format.\r\n                    // The Globalize doesn't support dates greater than 9999 so we replace the \"yyyyy\" with \"0yyyy\".\r\n                    format = format.replace(/yyyyy/g, \"0yyyy\");\r\n                    // Fix for the 3 digit year: \"yyy\" format.\r\n                    // The Globalize doesn't support this formatting so we need to replace it with the 4 digit year \"yyyy\" format.\r\n                    format = format.replace(/(^y|^)yyy(^y|$)/g, \"yyyy\");\r\n                    if (!regexCache) {\r\n                        // Creating Regexes for cases \"Using single format specifier\"\r\n                        // - http://msdn.microsoft.com/en-us/library/8kb3ddd4.aspx#UsingSingleSpecifiers\r\n                        // This is not supported from The Globalize.\r\n                        // The case covers all single \"%\" lead specifier (like \"%d\" but not %dd)\r\n                        // The cases as single \"%d\" are filtered in if the bellow.\r\n                        // (?!S) where S is the specifier make sure that we only one symbol for specifier.\r\n                        regexCache = [\"d\", \"f\", \"F\", \"g\", \"h\", \"H\", \"K\", \"m\", \"M\", \"s\", \"t\", \"y\", \"z\", \":\", \"/\"].map(function (s) {\r\n                            return { r: new RegExp(\"\\%\" + s + \"(?!\" + s + \")\", \"g\"), s: s };\r\n                        });\r\n                    }\r\n                    if (format.indexOf(\"%\") !== -1 && format.length > 2) {\r\n                        for (var i = 0; i < regexCache.length; i++) {\r\n                            format = format.replace(regexCache[i].r, regexCache[i].s);\r\n                        }\r\n                    }\r\n                    return format;\r\n                }\r\n                formatting.fixDateTimeFormat = fixDateTimeFormat;\r\n            })(formatting = utils.formatting || (utils.formatting = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\"use strict\";\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var formatting;\r\n            (function (formatting) {\r\n                var font;\r\n                (function (font_1) {\r\n                    var FamilyInfo = (function () {\r\n                        function FamilyInfo(families) {\r\n                            this.families = families;\r\n                        }\r\n                        Object.defineProperty(FamilyInfo.prototype, \"family\", {\r\n                            /**\r\n                             * Gets the first font \"wf_\" font family since it will always be loaded.\r\n                             */\r\n                            get: function () {\r\n                                return this.getFamily();\r\n                            },\r\n                            enumerable: true,\r\n                            configurable: true\r\n                        });\r\n                        /**\r\n                        * Gets the first font family that matches regex (if provided).\r\n                        * Default regex looks for \"wf_\" fonts which are always loaded.\r\n                        */\r\n                        FamilyInfo.prototype.getFamily = function (regex) {\r\n                            if (regex === void 0) { regex = /^wf_/; }\r\n                            if (!this.families) {\r\n                                return null;\r\n                            }\r\n                            if (regex) {\r\n                                for (var _i = 0, _a = this.families; _i < _a.length; _i++) {\r\n                                    var fontFamily = _a[_i];\r\n                                    if (regex.test(fontFamily)) {\r\n                                        return fontFamily;\r\n                                    }\r\n                                }\r\n                            }\r\n                            return this.families[0];\r\n                        };\r\n                        Object.defineProperty(FamilyInfo.prototype, \"css\", {\r\n                            /**\r\n                             * Gets the CSS string for the \"font-family\" CSS attribute.\r\n                             */\r\n                            get: function () {\r\n                                return this.getCSS();\r\n                            },\r\n                            enumerable: true,\r\n                            configurable: true\r\n                        });\r\n                        /**\r\n                         * Gets the CSS string for the \"font-family\" CSS attribute.\r\n                         */\r\n                        FamilyInfo.prototype.getCSS = function () {\r\n                            return this.families ? this.families.map((function (font) { return font.indexOf(\" \") > 0 ? \"'\" + font + \"'\" : font; })).join(\", \") : null;\r\n                        };\r\n                        return FamilyInfo;\r\n                    }());\r\n                    font_1.FamilyInfo = FamilyInfo;\r\n                })(font = formatting.font || (formatting.font = {}));\r\n            })(formatting = utils.formatting || (utils.formatting = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\"use strict\";\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var formatting;\r\n            (function (formatting) {\r\n                var font;\r\n                (function (font) {\r\n                    font.fallbackFonts = [\"helvetica\", \"arial\", \"sans-serif\"];\r\n                    font.Family = {\r\n                        light: new font.FamilyInfo(font.fallbackFonts),\r\n                        semilight: new font.FamilyInfo(font.fallbackFonts),\r\n                        regular: new font.FamilyInfo(font.fallbackFonts),\r\n                        semibold: new font.FamilyInfo(font.fallbackFonts),\r\n                        bold: new font.FamilyInfo(font.fallbackFonts),\r\n                        lightSecondary: new font.FamilyInfo(font.fallbackFonts),\r\n                        regularSecondary: new font.FamilyInfo(font.fallbackFonts),\r\n                        boldSecondary: new font.FamilyInfo(font.fallbackFonts)\r\n                    };\r\n                })(font = formatting.font || (formatting.font = {}));\r\n            })(formatting = utils.formatting || (utils.formatting = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\"use strict\";\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var formatting;\r\n            (function (formatting) {\r\n                // powerbi.extensibility.utils.type\r\n                var Double = powerbi.extensibility.utils.type.Double;\r\n                var RegExpExtensions = powerbi.extensibility.utils.type.RegExpExtensions;\r\n                // powerbi.extensibility.utils.formatting\r\n                var stringExtensions = powerbi.extensibility.utils.formatting.stringExtensions;\r\n                var findDateFormat = powerbi.extensibility.utils.formatting.findDateFormat;\r\n                var fixDateTimeFormat = powerbi.extensibility.utils.formatting.fixDateTimeFormat;\r\n                var DateTimeUnit = powerbi.extensibility.utils.formatting.DateTimeUnit;\r\n                /** Formatting Encoder */\r\n                var formattingEncoder;\r\n                (function (formattingEncoder) {\r\n                    // quoted and escaped literal patterns\r\n                    // NOTE: the final three cases match .NET behavior\r\n                    var literalPatterns = [\r\n                        \"'[^']*'\",\r\n                        \"\\\"[^\\\"]*\\\"\",\r\n                        \"\\\\\\\\.\",\r\n                        \"'[^']*$\",\r\n                        \"\\\"[^\\\"]*$\",\r\n                        \"\\\\\\\\$\",\r\n                    ];\r\n                    var literalMatcher = new RegExp(literalPatterns.join(\"|\"), \"g\");\r\n                    // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\r\n                    function removeLiterals(format) {\r\n                        literalMatcher.lastIndex = 0;\r\n                        // just in case consecutive non-literals have some meaning\r\n                        return format.replace(literalMatcher, \"\\uE100\");\r\n                    }\r\n                    formattingEncoder.removeLiterals = removeLiterals;\r\n                    function preserveLiterals(format, literals) {\r\n                        literalMatcher.lastIndex = 0;\r\n                        for (;;) {\r\n                            var match = literalMatcher.exec(format);\r\n                            if (!match)\r\n                                break;\r\n                            var literal = match[0];\r\n                            var literalOffset = literalMatcher.lastIndex - literal.length;\r\n                            var token = String.fromCharCode(0xE100 + literals.length);\r\n                            literals.push(literal);\r\n                            format = format.substr(0, literalOffset) + token + format.substr(literalMatcher.lastIndex);\r\n                            // back to avoid skipping due to removed literal substring\r\n                            literalMatcher.lastIndex = literalOffset + 1;\r\n                        }\r\n                        return format;\r\n                    }\r\n                    formattingEncoder.preserveLiterals = preserveLiterals;\r\n                    function restoreLiterals(format, literals, quoted) {\r\n                        if (quoted === void 0) { quoted = true; }\r\n                        var count = literals.length;\r\n                        for (var i = 0; i < count; i++) {\r\n                            var token = String.fromCharCode(0xE100 + i);\r\n                            var literal = literals[i];\r\n                            if (!quoted) {\r\n                                // caller wants literals to be re-inserted without escaping\r\n                                var firstChar = literal[0];\r\n                                if (firstChar === \"\\\\\" || literal.length === 1 || literal[literal.length - 1] !== firstChar) {\r\n                                    // either escaped literal OR quoted literal that's missing the trailing quote\r\n                                    // in either case we only remove the leading character\r\n                                    literal = literal.substring(1);\r\n                                }\r\n                                else {\r\n                                    // so must be a quoted literal with both starting and ending quote\r\n                                    literal = literal.substring(1, literal.length - 1);\r\n                                }\r\n                            }\r\n                            format = format.replace(token, literal);\r\n                        }\r\n                        return format;\r\n                    }\r\n                    formattingEncoder.restoreLiterals = restoreLiterals;\r\n                })(formattingEncoder || (formattingEncoder = {}));\r\n                var IndexedTokensRegex = /({{)|(}})|{(\\d+[^}]*)}/g;\r\n                var ZeroPlaceholder = \"0\";\r\n                var DigitPlaceholder = \"#\";\r\n                var ExponentialFormatChar = \"E\";\r\n                var NumericPlaceholders = [ZeroPlaceholder, DigitPlaceholder];\r\n                var NumericPlaceholderRegex = new RegExp(NumericPlaceholders.join(\"|\"), \"g\");\r\n                /** Formatting Service */\r\n                var FormattingService = (function () {\r\n                    function FormattingService() {\r\n                    }\r\n                    FormattingService.prototype.formatValue = function (value, format, cultureSelector) {\r\n                        // Handle special cases\r\n                        if (value === undefined || value === null) {\r\n                            return \"\";\r\n                        }\r\n                        var gculture = this.getCulture(cultureSelector);\r\n                        if (dateTimeFormat.canFormat(value)) {\r\n                            // Dates\r\n                            return dateTimeFormat.format(value, format, gculture);\r\n                        }\r\n                        else if (numberFormat.canFormat(value)) {\r\n                            // Numbers\r\n                            return numberFormat.format(value, format, gculture);\r\n                        }\r\n                        // Other data types - return as string\r\n                        return value.toString();\r\n                    };\r\n                    FormattingService.prototype.format = function (formatWithIndexedTokens, args, culture) {\r\n                        var _this = this;\r\n                        if (!formatWithIndexedTokens) {\r\n                            return \"\";\r\n                        }\r\n                        var result = formatWithIndexedTokens.replace(IndexedTokensRegex, function (match, left, right, argToken) {\r\n                            if (left) {\r\n                                return \"{\";\r\n                            }\r\n                            else if (right) {\r\n                                return \"}\";\r\n                            }\r\n                            else {\r\n                                var parts = argToken.split(\":\");\r\n                                var argIndex = parseInt(parts[0], 10);\r\n                                var argFormat = parts[1];\r\n                                return _this.formatValue(args[argIndex], argFormat, culture);\r\n                            }\r\n                        });\r\n                        return result;\r\n                    };\r\n                    FormattingService.prototype.isStandardNumberFormat = function (format) {\r\n                        return numberFormat.isStandardFormat(format);\r\n                    };\r\n                    FormattingService.prototype.formatNumberWithCustomOverride = function (value, format, nonScientificOverrideFormat, culture) {\r\n                        var gculture = this.getCulture(culture);\r\n                        return numberFormat.formatWithCustomOverride(value, format, nonScientificOverrideFormat, gculture);\r\n                    };\r\n                    FormattingService.prototype.dateFormatString = function (unit) {\r\n                        if (!this._dateTimeScaleFormatInfo)\r\n                            this.initialize();\r\n                        return this._dateTimeScaleFormatInfo.getFormatString(unit);\r\n                    };\r\n                    /**\r\n                     * Sets the current localization culture\r\n                     * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\r\n                     */\r\n                    FormattingService.prototype.setCurrentCulture = function (cultureSelector) {\r\n                        if (this._currentCultureSelector !== cultureSelector) {\r\n                            this._currentCulture = this.getCulture(cultureSelector);\r\n                            this._currentCultureSelector = cultureSelector;\r\n                            this._dateTimeScaleFormatInfo = new DateTimeScaleFormatInfo(this._currentCulture);\r\n                        }\r\n                    };\r\n                    /**\r\n                     * Gets the culture assotiated with the specified cultureSelector (\"en\", \"en-US\", \"fr-FR\" etc).\r\n                     * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\r\n                     * Exposing this function for testability of unsupported cultures\r\n                     */\r\n                    FormattingService.prototype.getCulture = function (cultureSelector) {\r\n                        if (cultureSelector == null) {\r\n                            if (this._currentCulture == null) {\r\n                                this.initialize();\r\n                            }\r\n                            return this._currentCulture;\r\n                        }\r\n                        else {\r\n                            var culture = Globalize.findClosestCulture(cultureSelector);\r\n                            if (!culture)\r\n                                culture = Globalize.culture(\"en-US\");\r\n                            return culture;\r\n                        }\r\n                    };\r\n                    /** By default the Globalization module initializes to the culture/calendar provided in the language/culture URL params */\r\n                    FormattingService.prototype.initialize = function () {\r\n                        var cultureName = this.getCurrentCulture();\r\n                        this.setCurrentCulture(cultureName);\r\n                        var calendarName = this.getUrlParam(\"calendar\");\r\n                        if (calendarName) {\r\n                            var culture = this._currentCulture;\r\n                            var c = culture.calendars[calendarName];\r\n                            if (c) {\r\n                                culture.calendar = c;\r\n                            }\r\n                        }\r\n                    };\r\n                    /**\r\n                     *  Exposing this function for testability\r\n                     */\r\n                    FormattingService.prototype.getCurrentCulture = function () {\r\n                        var urlParam = this.getUrlParam(\"language\");\r\n                        if (urlParam) {\r\n                            return urlParam;\r\n                        }\r\n                        if (powerbi && powerbi.common && powerbi.common.cultureInfo) {\r\n                            // Get cultureInfo set in powerbi\r\n                            return powerbi.common.cultureInfo;\r\n                        }\r\n                        return window.navigator.userLanguage || window.navigator[\"language\"] || Globalize.culture().name;\r\n                    };\r\n                    /**\r\n                     *  Exposing this function for testability\r\n                     *  @param name: queryString name\r\n                     */\r\n                    FormattingService.prototype.getUrlParam = function (name) {\r\n                        var param = window.location.search.match(RegExp(\"[?&]\" + name + \"=([^&]*)\"));\r\n                        return param ? param[1] : undefined;\r\n                    };\r\n                    return FormattingService;\r\n                }());\r\n                formatting.FormattingService = FormattingService;\r\n                /**\r\n                 * DateTimeFormat module contains the static methods for formatting the DateTimes.\r\n                 * It extends the JQuery.Globalize functionality to support complete set of .NET\r\n                 * formatting expressions for dates.\r\n                 */\r\n                var dateTimeFormat;\r\n                (function (dateTimeFormat) {\r\n                    var _currentCachedFormat;\r\n                    var _currentCachedProcessedFormat;\r\n                    /** Evaluates if the value can be formatted using the NumberFormat */\r\n                    function canFormat(value) {\r\n                        var result = value instanceof Date;\r\n                        return result;\r\n                    }\r\n                    dateTimeFormat.canFormat = canFormat;\r\n                    /** Formats the date using provided format and culture */\r\n                    function format(value, format, culture) {\r\n                        format = format || \"G\";\r\n                        var isStandard = format.length === 1;\r\n                        try {\r\n                            if (isStandard) {\r\n                                return formatDateStandard(value, format, culture);\r\n                            }\r\n                            else {\r\n                                return formatDateCustom(value, format, culture);\r\n                            }\r\n                        }\r\n                        catch (e) {\r\n                            return formatDateStandard(value, \"G\", culture);\r\n                        }\r\n                    }\r\n                    dateTimeFormat.format = format;\r\n                    /** Formats the date using standard format expression */\r\n                    function formatDateStandard(value, format, culture) {\r\n                        // In order to provide parity with .NET we have to support additional set of DateTime patterns.\r\n                        var patterns = culture.calendar.patterns;\r\n                        // Extend supported set of patterns\r\n                        ensurePatterns(culture.calendar);\r\n                        // Handle extended set of formats\r\n                        var output = findDateFormat(value, format, culture.name);\r\n                        if (output.format.length === 1)\r\n                            format = patterns[output.format];\r\n                        else\r\n                            format = output.format;\r\n                        // need to revisit when globalization is enabled\r\n                        if (!culture) {\r\n                            culture = Globalize.culture(\"en-US\");\r\n                        }\r\n                        return Globalize.format(output.value, format, culture);\r\n                    }\r\n                    /** Formats the date using custom format expression */\r\n                    function formatDateCustom(value, format, culture) {\r\n                        var result;\r\n                        var literals = [];\r\n                        format = formattingEncoder.preserveLiterals(format, literals);\r\n                        if (format.indexOf(\"F\") > -1) {\r\n                            // F is not supported so we need to replace the F with f based on the milliseconds\r\n                            // Replace all sequences of F longer than 3 with \"FFF\"\r\n                            format = stringExtensions.replaceAll(format, \"FFFF\", \"FFF\");\r\n                            // Based on milliseconds update the format to use fff\r\n                            var milliseconds = value.getMilliseconds();\r\n                            if (milliseconds % 10 >= 1) {\r\n                                format = stringExtensions.replaceAll(format, \"FFF\", \"fff\");\r\n                            }\r\n                            format = stringExtensions.replaceAll(format, \"FFF\", \"FF\");\r\n                            if ((milliseconds % 100) / 10 >= 1) {\r\n                                format = stringExtensions.replaceAll(format, \"FF\", \"ff\");\r\n                            }\r\n                            format = stringExtensions.replaceAll(format, \"FF\", \"F\");\r\n                            if ((milliseconds % 1000) / 100 >= 1) {\r\n                                format = stringExtensions.replaceAll(format, \"F\", \"f\");\r\n                            }\r\n                            format = stringExtensions.replaceAll(format, \"F\", \"\");\r\n                            if (format === \"\" || format === \"%\")\r\n                                return \"\";\r\n                        }\r\n                        format = processCustomDateTimeFormat(format);\r\n                        result = Globalize.format(value, format, culture);\r\n                        result = localize(result, culture.calendar);\r\n                        result = formattingEncoder.restoreLiterals(result, literals, false);\r\n                        return result;\r\n                    }\r\n                    /** Translates unsupported .NET custom format expressions to the custom expressions supported by JQuery.Globalize */\r\n                    function processCustomDateTimeFormat(format) {\r\n                        if (format === _currentCachedFormat) {\r\n                            return _currentCachedProcessedFormat;\r\n                        }\r\n                        _currentCachedFormat = format;\r\n                        format = fixDateTimeFormat(format);\r\n                        _currentCachedProcessedFormat = format;\r\n                        return format;\r\n                    }\r\n                    /** Localizes the time separator symbol */\r\n                    function localize(value, dictionary) {\r\n                        var timeSeparator = dictionary[\":\"];\r\n                        if (timeSeparator === \":\") {\r\n                            return value;\r\n                        }\r\n                        var result = \"\";\r\n                        var count = value.length;\r\n                        for (var i = 0; i < count; i++) {\r\n                            var char = value.charAt(i);\r\n                            switch (char) {\r\n                                case \":\":\r\n                                    result += timeSeparator;\r\n                                    break;\r\n                                default:\r\n                                    result += char;\r\n                                    break;\r\n                            }\r\n                        }\r\n                        return result;\r\n                    }\r\n                    function ensurePatterns(calendar) {\r\n                        var patterns = calendar.patterns;\r\n                        if (patterns[\"g\"] === undefined) {\r\n                            patterns[\"g\"] = patterns[\"f\"].replace(patterns[\"D\"], patterns[\"d\"]); // Generic: Short date, short time\r\n                            patterns[\"G\"] = patterns[\"F\"].replace(patterns[\"D\"], patterns[\"d\"]); // Generic: Short date, long time\r\n                        }\r\n                    }\r\n                })(dateTimeFormat || (dateTimeFormat = {}));\r\n                /**\r\n                 * NumberFormat module contains the static methods for formatting the numbers.\r\n                 * It extends the JQuery.Globalize functionality to support complete set of .NET\r\n                 * formatting expressions for numeric types including custom formats.\r\n                 */\r\n                var numberFormat;\r\n                (function (numberFormat) {\r\n                    var NonScientificFormatRegex = /^\\{.+\\}.*/;\r\n                    var NumericalPlaceHolderRegex = /\\{.+\\}/;\r\n                    var ScientificFormatRegex = /e[+-]*[0#]+/i;\r\n                    var StandardFormatRegex = /^[a-z]\\d{0,2}$/i; // a letter + up to 2 digits for precision specifier\r\n                    var TrailingZerosRegex = /0+$/;\r\n                    var DecimalFormatRegex = /\\.([0#]*)/g;\r\n                    var NumericFormatRegex = /[0#,\\.]+[0,#]*/g;\r\n                    // (?=...) is a positive lookahead assertion. The RE is asking for the last digit placeholder, [0#],\r\n                    // which is followed by non-digit placeholders and the end of string, [^0#]*$. But it only matches\r\n                    // the last digit placeholder, not anything that follows because the positive lookahead isn\"t included\r\n                    // in the match - it is only a condition.\r\n                    var LastNumericPlaceholderRegex = /([0#])(?=[^0#]*$)/;\r\n                    var DecimalFormatCharacter = \".\";\r\n                    numberFormat.NumberFormatComponentsDelimeter = \";\";\r\n                    function getNonScientificFormatWithPrecision(baseFormat, numericFormat) {\r\n                        if (!numericFormat || baseFormat === undefined)\r\n                            return baseFormat;\r\n                        var newFormat = \"{0:\" + numericFormat + \"}\";\r\n                        return baseFormat.replace(\"{0}\", newFormat);\r\n                    }\r\n                    function getNumericFormat(value, baseFormat) {\r\n                        if (baseFormat == null)\r\n                            return baseFormat;\r\n                        if (hasFormatComponents(baseFormat)) {\r\n                            var _a = numberFormat.getComponents(baseFormat), positive = _a.positive, negative = _a.negative, zero = _a.zero;\r\n                            if (value > 0)\r\n                                return getNumericFormatFromComponent(value, positive);\r\n                            else if (value === 0)\r\n                                return getNumericFormatFromComponent(value, zero);\r\n                            return getNumericFormatFromComponent(value, negative);\r\n                        }\r\n                        return getNumericFormatFromComponent(value, baseFormat);\r\n                    }\r\n                    numberFormat.getNumericFormat = getNumericFormat;\r\n                    function getNumericFormatFromComponent(value, format) {\r\n                        var match = RegExpExtensions.run(NumericFormatRegex, format);\r\n                        if (match)\r\n                            return match[0];\r\n                        return format;\r\n                    }\r\n                    function addDecimalsToFormat(baseFormat, decimals, trailingZeros) {\r\n                        if (decimals == null)\r\n                            return baseFormat;\r\n                        // Default format string\r\n                        if (baseFormat == null)\r\n                            baseFormat = ZeroPlaceholder;\r\n                        if (hasFormatComponents(baseFormat)) {\r\n                            var _a = numberFormat.getComponents(baseFormat), positive = _a.positive, negative = _a.negative, zero = _a.zero;\r\n                            var formats = [positive, negative, zero];\r\n                            for (var i = 0; i < formats.length; i++) {\r\n                                // Update format in formats array\r\n                                formats[i] = addDecimalsToFormatComponent(formats[i], decimals, trailingZeros);\r\n                            }\r\n                            return formats.join(numberFormat.NumberFormatComponentsDelimeter);\r\n                        }\r\n                        return addDecimalsToFormatComponent(baseFormat, decimals, trailingZeros);\r\n                    }\r\n                    numberFormat.addDecimalsToFormat = addDecimalsToFormat;\r\n                    function addDecimalsToFormatComponent(format, decimals, trailingZeros) {\r\n                        decimals = Math.abs(decimals);\r\n                        if (decimals >= 0) {\r\n                            var literals = [];\r\n                            format = formattingEncoder.preserveLiterals(format, literals);\r\n                            var placeholder = trailingZeros ? ZeroPlaceholder : DigitPlaceholder;\r\n                            var decimalPlaceholders = stringExtensions.repeat(placeholder, Math.abs(decimals));\r\n                            var match = RegExpExtensions.run(DecimalFormatRegex, format);\r\n                            if (match) {\r\n                                var beforeDecimal = format.substr(0, match.index);\r\n                                var formatDecimal = format.substr(match.index + 1, match[1].length);\r\n                                var afterDecimal = format.substr(match.index + match[0].length);\r\n                                if (trailingZeros)\r\n                                    // Use explicit decimals argument as placeholders\r\n                                    formatDecimal = decimalPlaceholders;\r\n                                else {\r\n                                    var decimalChange = decimalPlaceholders.length - formatDecimal.length;\r\n                                    if (decimalChange > 0)\r\n                                        // Append decimalPlaceholders to existing decimal portion of format string\r\n                                        formatDecimal = formatDecimal + decimalPlaceholders.slice(-decimalChange);\r\n                                    else if (decimalChange < 0)\r\n                                        // Remove decimals from formatDecimal\r\n                                        formatDecimal = formatDecimal.slice(0, decimalChange);\r\n                                }\r\n                                if (formatDecimal.length > 0)\r\n                                    formatDecimal = DecimalFormatCharacter + formatDecimal;\r\n                                format = beforeDecimal + formatDecimal + afterDecimal;\r\n                            }\r\n                            else if (decimalPlaceholders.length > 0) {\r\n                                // Replace last numeric placeholder with decimal portion\r\n                                format = format.replace(LastNumericPlaceholderRegex, \"$1\" + DecimalFormatCharacter + decimalPlaceholders);\r\n                            }\r\n                            if (literals.length !== 0)\r\n                                format = formattingEncoder.restoreLiterals(format, literals);\r\n                        }\r\n                        return format;\r\n                    }\r\n                    function hasFormatComponents(format) {\r\n                        return formattingEncoder.removeLiterals(format).indexOf(numberFormat.NumberFormatComponentsDelimeter) !== -1;\r\n                    }\r\n                    numberFormat.hasFormatComponents = hasFormatComponents;\r\n                    function getComponents(format) {\r\n                        var signFormat = {\r\n                            hasNegative: false,\r\n                            positive: format,\r\n                            negative: format,\r\n                            zero: format,\r\n                        };\r\n                        // escape literals so semi-colon in a literal isn't interpreted as a delimiter\r\n                        // NOTE: OK to use the literals extracted here for all three components before since the literals are indexed.\r\n                        // For example, \"'pos-lit';'neg-lit'\" will get preserved as \"\\uE000;\\uE001\" and the literal array will be\r\n                        // ['pos-lit', 'neg-lit']. When the negative components is restored, its \\uE001 will select the second\r\n                        // literal.\r\n                        var literals = [];\r\n                        format = formattingEncoder.preserveLiterals(format, literals);\r\n                        var signSpecificFormats = format.split(numberFormat.NumberFormatComponentsDelimeter);\r\n                        var formatCount = signSpecificFormats.length;\r\n                        if (formatCount > 1) {\r\n                            if (literals.length !== 0)\r\n                                signSpecificFormats = signSpecificFormats.map(function (signSpecificFormat) { return formattingEncoder.restoreLiterals(signSpecificFormat, literals); });\r\n                            signFormat.hasNegative = true;\r\n                            signFormat.positive = signFormat.zero = signSpecificFormats[0];\r\n                            signFormat.negative = signSpecificFormats[1];\r\n                            if (formatCount > 2)\r\n                                signFormat.zero = signSpecificFormats[2];\r\n                        }\r\n                        return signFormat;\r\n                    }\r\n                    numberFormat.getComponents = getComponents;\r\n                    var _lastCustomFormatMeta;\r\n                    /** Evaluates if the value can be formatted using the NumberFormat */\r\n                    function canFormat(value) {\r\n                        var result = typeof (value) === \"number\";\r\n                        return result;\r\n                    }\r\n                    numberFormat.canFormat = canFormat;\r\n                    function isStandardFormat(format) {\r\n                        return StandardFormatRegex.test(format);\r\n                    }\r\n                    numberFormat.isStandardFormat = isStandardFormat;\r\n                    /** Formats the number using specified format expression and culture */\r\n                    function format(value, format, culture) {\r\n                        format = format || \"G\";\r\n                        try {\r\n                            if (isStandardFormat(format))\r\n                                return formatNumberStandard(value, format, culture);\r\n                            return formatNumberCustom(value, format, culture);\r\n                        }\r\n                        catch (e) {\r\n                            return Globalize.format(value, undefined, culture);\r\n                        }\r\n                    }\r\n                    numberFormat.format = format;\r\n                    /** Performs a custom format with a value override.  Typically used for custom formats showing scaled values. */\r\n                    function formatWithCustomOverride(value, format, nonScientificOverrideFormat, culture) {\r\n                        return formatNumberCustom(value, format, culture, nonScientificOverrideFormat);\r\n                    }\r\n                    numberFormat.formatWithCustomOverride = formatWithCustomOverride;\r\n                    /** Formats the number using standard format expression */\r\n                    function formatNumberStandard(value, format, culture) {\r\n                        var result;\r\n                        var precision = (format.length > 1 ? parseInt(format.substr(1, format.length - 1), 10) : undefined);\r\n                        var numberFormatInfo = culture.numberFormat;\r\n                        var formatChar = format.charAt(0);\r\n                        switch (formatChar) {\r\n                            case \"e\":\r\n                            case \"E\":\r\n                                if (precision === undefined) {\r\n                                    precision = 6;\r\n                                }\r\n                                var mantissaDecimalDigits = stringExtensions.repeat(\"0\", precision);\r\n                                format = \"0.\" + mantissaDecimalDigits + formatChar + \"+000\";\r\n                                result = formatNumberCustom(value, format, culture);\r\n                                break;\r\n                            case \"f\":\r\n                            case \"F\":\r\n                                result = precision !== undefined ? value.toFixed(precision) : value.toFixed(numberFormatInfo.decimals);\r\n                                result = localize(result, numberFormatInfo);\r\n                                break;\r\n                            case \"g\":\r\n                            case \"G\":\r\n                                var abs = Math.abs(value);\r\n                                if (abs === 0 || (1E-4 <= abs && abs < 1E15)) {\r\n                                    // For the range of 0.0001 to 1,000,000,000,000,000 - use the normal form\r\n                                    result = precision !== undefined ? value.toPrecision(precision) : value.toString();\r\n                                }\r\n                                else {\r\n                                    // Otherwise use exponential\r\n                                    // Assert that value is a number and fall back on returning value if it is not\r\n                                    if (typeof (value) !== \"number\")\r\n                                        return String(value);\r\n                                    result = precision !== undefined ? value.toExponential(precision) : value.toExponential();\r\n                                    result = result.replace(\"e\", \"E\");\r\n                                }\r\n                                result = localize(result, numberFormatInfo);\r\n                                break;\r\n                            case \"r\":\r\n                            case \"R\":\r\n                                result = value.toString();\r\n                                result = localize(result, numberFormatInfo);\r\n                                break;\r\n                            case \"x\":\r\n                            case \"X\":\r\n                                result = value.toString(16);\r\n                                if (formatChar === \"X\") {\r\n                                    result = result.toUpperCase();\r\n                                }\r\n                                if (precision !== undefined) {\r\n                                    var actualPrecision = result.length;\r\n                                    var isNegative = value < 0;\r\n                                    if (isNegative) {\r\n                                        actualPrecision--;\r\n                                    }\r\n                                    var paddingZerosCount = precision - actualPrecision;\r\n                                    var paddingZeros = undefined;\r\n                                    if (paddingZerosCount > 0) {\r\n                                        paddingZeros = stringExtensions.repeat(\"0\", paddingZerosCount);\r\n                                    }\r\n                                    if (isNegative) {\r\n                                        result = \"-\" + paddingZeros + result.substr(1);\r\n                                    }\r\n                                    else {\r\n                                        result = paddingZeros + result;\r\n                                    }\r\n                                }\r\n                                result = localize(result, numberFormatInfo);\r\n                                break;\r\n                            default:\r\n                                result = Globalize.format(value, format, culture);\r\n                        }\r\n                        return result;\r\n                    }\r\n                    /** Formats the number using custom format expression */\r\n                    function formatNumberCustom(value, format, culture, nonScientificOverrideFormat) {\r\n                        var result;\r\n                        var numberFormatInfo = culture.numberFormat;\r\n                        if (isFinite(value)) {\r\n                            // Split format by positive[;negative;zero] pattern\r\n                            var formatComponents = getComponents(format);\r\n                            // Pick a format based on the sign of value\r\n                            if (value > 0) {\r\n                                format = formatComponents.positive;\r\n                            }\r\n                            else if (value === 0) {\r\n                                format = formatComponents.zero;\r\n                            }\r\n                            else {\r\n                                format = formatComponents.negative;\r\n                            }\r\n                            // Normalize value if we have an explicit negative format\r\n                            if (formatComponents.hasNegative)\r\n                                value = Math.abs(value);\r\n                            // Get format metadata\r\n                            var formatMeta = getCustomFormatMetadata(format, true /*calculatePrecision*/);\r\n                            // Preserve literals and escaped chars\r\n                            var literals = [];\r\n                            if (formatMeta.hasLiterals) {\r\n                                format = formattingEncoder.preserveLiterals(format, literals);\r\n                            }\r\n                            // Scientific format\r\n                            if (formatMeta.hasE && !nonScientificOverrideFormat) {\r\n                                var scientificMatch = RegExpExtensions.run(ScientificFormatRegex, format);\r\n                                if (scientificMatch) {\r\n                                    // Case 2.1. Scientific custom format\r\n                                    var formatM = format.substr(0, scientificMatch.index);\r\n                                    var formatE = format.substr(scientificMatch.index + 2); // E(+|-)\r\n                                    var precision = getCustomFormatPrecision(formatM, formatMeta);\r\n                                    var scale = getCustomFormatScale(formatM, formatMeta);\r\n                                    if (scale !== 1) {\r\n                                        value = value * scale;\r\n                                    }\r\n                                    // Assert that value is a number and fall back on returning value if it is not\r\n                                    if (typeof (value) !== \"number\")\r\n                                        return String(value);\r\n                                    var s = value.toExponential(precision);\r\n                                    var indexOfE = s.indexOf(\"e\");\r\n                                    var mantissa = s.substr(0, indexOfE);\r\n                                    var exp = s.substr(indexOfE + 1);\r\n                                    var resultM = fuseNumberWithCustomFormat(mantissa, formatM, numberFormatInfo);\r\n                                    var resultE = fuseNumberWithCustomFormat(exp, formatE, numberFormatInfo);\r\n                                    if (resultE.charAt(0) === \"+\" && scientificMatch[0].charAt(1) !== \"+\") {\r\n                                        resultE = resultE.substr(1);\r\n                                    }\r\n                                    var e = scientificMatch[0].charAt(0);\r\n                                    result = resultM + e + resultE;\r\n                                }\r\n                            }\r\n                            // Non scientific format\r\n                            if (result === undefined) {\r\n                                var valueFormatted = void 0;\r\n                                var isValueGlobalized = false;\r\n                                var precision = getCustomFormatPrecision(format, formatMeta);\r\n                                var scale = getCustomFormatScale(format, formatMeta);\r\n                                if (scale !== 1)\r\n                                    value = value * scale;\r\n                                // Rounding\r\n                                value = parseFloat(toNonScientific(value, precision));\r\n                                if (!isFinite(value)) {\r\n                                    // very large and small finite values can become infinite by parseFloat(toNonScientific())\r\n                                    return Globalize.format(value, undefined);\r\n                                }\r\n                                if (nonScientificOverrideFormat) {\r\n                                    // Get numeric format from format string\r\n                                    var numericFormat = numberFormat.getNumericFormat(value, format);\r\n                                    // Add separators and decimalFormat to nonScientificFormat\r\n                                    nonScientificOverrideFormat = getNonScientificFormatWithPrecision(nonScientificOverrideFormat, numericFormat);\r\n                                    // Format the value\r\n                                    valueFormatted = formatting.formattingService.format(nonScientificOverrideFormat, [value], culture.name);\r\n                                    isValueGlobalized = true;\r\n                                }\r\n                                else\r\n                                    valueFormatted = toNonScientific(value, precision);\r\n                                result = fuseNumberWithCustomFormat(valueFormatted, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized);\r\n                            }\r\n                            if (formatMeta.hasLiterals) {\r\n                                result = formattingEncoder.restoreLiterals(result, literals, false);\r\n                            }\r\n                            _lastCustomFormatMeta = formatMeta;\r\n                        }\r\n                        else {\r\n                            return Globalize.format(value, undefined);\r\n                        }\r\n                        return result;\r\n                    }\r\n                    /** Returns string with the fixed point respresentation of the number */\r\n                    function toNonScientific(value, precision) {\r\n                        var result = \"\";\r\n                        var precisionZeros = 0;\r\n                        // Double precision numbers support actual 15-16 decimal digits of precision.\r\n                        if (precision > 16) {\r\n                            precisionZeros = precision - 16;\r\n                            precision = 16;\r\n                        }\r\n                        var digitsBeforeDecimalPoint = Double.log10(Math.abs(value));\r\n                        if (digitsBeforeDecimalPoint < 16) {\r\n                            if (digitsBeforeDecimalPoint > 0) {\r\n                                var maxPrecision = 16 - digitsBeforeDecimalPoint;\r\n                                if (precision > maxPrecision) {\r\n                                    precisionZeros += precision - maxPrecision;\r\n                                    precision = maxPrecision;\r\n                                }\r\n                            }\r\n                            result = value.toFixed(precision);\r\n                        }\r\n                        else if (digitsBeforeDecimalPoint === 16) {\r\n                            result = value.toFixed(0);\r\n                            precisionZeros += precision;\r\n                            if (precisionZeros > 0) {\r\n                                result += \".\";\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Different browsers have different implementations of the toFixed().\r\n                            // In IE it returns fixed format no matter what's the number. In FF and Chrome the method returns exponential format for numbers greater than 1E21.\r\n                            // So we need to check for range and convert the to exponential with the max precision.\r\n                            // Then we convert exponential string to fixed by removing the dot and padding with \"power\" zeros.\r\n                            // Assert that value is a number and fall back on returning value if it is not\r\n                            if (typeof (value) !== \"number\")\r\n                                return String(value);\r\n                            result = value.toExponential(15);\r\n                            var indexOfE = result.indexOf(\"e\");\r\n                            if (indexOfE > 0) {\r\n                                var indexOfDot = result.indexOf(\".\");\r\n                                var mantissa = result.substr(0, indexOfE);\r\n                                var exp = result.substr(indexOfE + 1);\r\n                                var powerZeros = parseInt(exp, 10) - (mantissa.length - indexOfDot - 1);\r\n                                result = mantissa.replace(\".\", \"\") + stringExtensions.repeat(\"0\", powerZeros);\r\n                                if (precision > 0) {\r\n                                    result = result + \".\" + stringExtensions.repeat(\"0\", precision);\r\n                                }\r\n                            }\r\n                        }\r\n                        if (precisionZeros > 0) {\r\n                            result = result + stringExtensions.repeat(\"0\", precisionZeros);\r\n                        }\r\n                        return result;\r\n                    }\r\n                    /**\r\n                     * Returns the formatMetadata of the format\r\n                     * When calculating precision and scale, if format string of\r\n                     * positive[;negative;zero] => positive format will be used\r\n                     * @param (required) format - format string\r\n                     * @param (optional) calculatePrecision - calculate precision of positive format\r\n                     * @param (optional) calculateScale - calculate scale of positive format\r\n                     */\r\n                    function getCustomFormatMetadata(format, calculatePrecision, calculateScale, calculatePartsPerScale) {\r\n                        if (_lastCustomFormatMeta !== undefined && format === _lastCustomFormatMeta.format) {\r\n                            return _lastCustomFormatMeta;\r\n                        }\r\n                        var literals = [];\r\n                        var escaped = formattingEncoder.preserveLiterals(format, literals);\r\n                        var result = {\r\n                            format: format,\r\n                            hasLiterals: literals.length !== 0,\r\n                            hasE: false,\r\n                            hasCommas: false,\r\n                            hasDots: false,\r\n                            hasPercent: false,\r\n                            hasPermile: false,\r\n                            precision: undefined,\r\n                            scale: undefined,\r\n                            partsPerScale: undefined,\r\n                        };\r\n                        for (var i = 0, length_1 = escaped.length; i < length_1; i++) {\r\n                            var c = escaped.charAt(i);\r\n                            switch (c) {\r\n                                case \"e\":\r\n                                case \"E\":\r\n                                    result.hasE = true;\r\n                                    break;\r\n                                case \",\":\r\n                                    result.hasCommas = true;\r\n                                    break;\r\n                                case \".\":\r\n                                    result.hasDots = true;\r\n                                    break;\r\n                                case \"%\":\r\n                                    result.hasPercent = true;\r\n                                    break;\r\n                                case \"\\u2030\":\r\n                                    result.hasPermile = true;\r\n                                    break;\r\n                            }\r\n                        }\r\n                        // Use positive format for calculating these values\r\n                        var formatComponents = getComponents(format);\r\n                        if (calculatePrecision)\r\n                            result.precision = getCustomFormatPrecision(formatComponents.positive, result);\r\n                        if (calculatePartsPerScale)\r\n                            result.partsPerScale = getCustomFormatPartsPerScale(formatComponents.positive, result);\r\n                        if (calculateScale)\r\n                            result.scale = getCustomFormatScale(formatComponents.positive, result);\r\n                        return result;\r\n                    }\r\n                    numberFormat.getCustomFormatMetadata = getCustomFormatMetadata;\r\n                    /** Returns the decimal precision of format based on the number of # and 0 chars after the decimal point\r\n                      * Important: The input format string needs to be split to the appropriate pos/neg/zero portion to work correctly */\r\n                    function getCustomFormatPrecision(format, formatMeta) {\r\n                        if (formatMeta.precision > -1) {\r\n                            return formatMeta.precision;\r\n                        }\r\n                        var result = 0;\r\n                        if (formatMeta.hasDots) {\r\n                            if (formatMeta.hasLiterals) {\r\n                                format = formattingEncoder.removeLiterals(format);\r\n                            }\r\n                            var dotIndex = format.indexOf(\".\");\r\n                            if (dotIndex > -1) {\r\n                                var count = format.length;\r\n                                for (var i = dotIndex; i < count; i++) {\r\n                                    var char = format.charAt(i);\r\n                                    if (char.match(NumericPlaceholderRegex))\r\n                                        result++;\r\n                                    // 0.00E+0 :: Break before counting 0 in\r\n                                    // exponential portion of format string\r\n                                    if (char === ExponentialFormatChar)\r\n                                        break;\r\n                                }\r\n                                result = Math.min(19, result);\r\n                            }\r\n                        }\r\n                        formatMeta.precision = result;\r\n                        return result;\r\n                    }\r\n                    function getCustomFormatPartsPerScale(format, formatMeta) {\r\n                        if (formatMeta.partsPerScale != null)\r\n                            return formatMeta.partsPerScale;\r\n                        var result = 1;\r\n                        if (formatMeta.hasPercent && format.indexOf(\"%\") > -1) {\r\n                            result = result * 100;\r\n                        }\r\n                        if (formatMeta.hasPermile && format.indexOf(/* ‰ */ \"\\u2030\") > -1) {\r\n                            result = result * 1000;\r\n                        }\r\n                        formatMeta.partsPerScale = result;\r\n                        return result;\r\n                    }\r\n                    /** Returns the scale factor of the format based on the \"%\" and scaling \",\" chars in the format */\r\n                    function getCustomFormatScale(format, formatMeta) {\r\n                        if (formatMeta.scale > -1) {\r\n                            return formatMeta.scale;\r\n                        }\r\n                        var result = getCustomFormatPartsPerScale(format, formatMeta);\r\n                        if (formatMeta.hasCommas) {\r\n                            var dotIndex = format.indexOf(\".\");\r\n                            if (dotIndex === -1) {\r\n                                dotIndex = format.length;\r\n                            }\r\n                            for (var i = dotIndex - 1; i > -1; i--) {\r\n                                var char = format.charAt(i);\r\n                                if (char === \",\") {\r\n                                    result = result / 1000;\r\n                                }\r\n                                else {\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        formatMeta.scale = result;\r\n                        return result;\r\n                    }\r\n                    function fuseNumberWithCustomFormat(value, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized) {\r\n                        var suppressModifyValue = !!nonScientificOverrideFormat;\r\n                        var formatParts = format.split(\".\", 2);\r\n                        if (formatParts.length === 2) {\r\n                            var wholeFormat = formatParts[0];\r\n                            var fractionFormat = formatParts[1];\r\n                            var displayUnit = \"\";\r\n                            // Remove display unit from value before splitting on \".\" as localized display units sometimes end with \".\"\r\n                            if (nonScientificOverrideFormat) {\r\n                                displayUnit = nonScientificOverrideFormat.replace(NumericalPlaceHolderRegex, \"\");\r\n                                value = value.replace(displayUnit, \"\");\r\n                            }\r\n                            var globalizedDecimalSeparator = numberFormatInfo[\".\"];\r\n                            var decimalSeparator = isValueGlobalized ? globalizedDecimalSeparator : \".\";\r\n                            var valueParts = value.split(decimalSeparator, 2);\r\n                            var wholeValue = valueParts.length === 1 ? valueParts[0] + displayUnit : valueParts[0];\r\n                            var fractionValue = valueParts.length === 2 ? valueParts[1] + displayUnit : \"\";\r\n                            fractionValue = fractionValue.replace(TrailingZerosRegex, \"\");\r\n                            var wholeFormattedValue = fuseNumberWithCustomFormatLeft(wholeValue, wholeFormat, numberFormatInfo, suppressModifyValue);\r\n                            var fractionFormattedValue = fuseNumberWithCustomFormatRight(fractionValue, fractionFormat, suppressModifyValue);\r\n                            if (fractionFormattedValue.fmtOnly || fractionFormattedValue.value === \"\")\r\n                                return wholeFormattedValue + fractionFormattedValue.value;\r\n                            return wholeFormattedValue + globalizedDecimalSeparator + fractionFormattedValue.value;\r\n                        }\r\n                        return fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue);\r\n                    }\r\n                    function fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue) {\r\n                        var groupSymbolIndex = format.indexOf(\",\");\r\n                        var enableGroups = groupSymbolIndex > -1 && groupSymbolIndex < Math.max(format.lastIndexOf(\"0\"), format.lastIndexOf(\"#\")) && numberFormatInfo[\",\"];\r\n                        var groupDigitCount = 0;\r\n                        var groupIndex = 0;\r\n                        var groupSizes = numberFormatInfo.groupSizes || [3];\r\n                        var groupSize = groupSizes[0];\r\n                        var groupSeparator = numberFormatInfo[\",\"];\r\n                        var sign = \"\";\r\n                        var firstChar = value.charAt(0);\r\n                        if (firstChar === \"+\" || firstChar === \"-\") {\r\n                            sign = numberFormatInfo[firstChar];\r\n                            value = value.substr(1);\r\n                        }\r\n                        var isZero = value === \"0\";\r\n                        var result = \"\";\r\n                        var leftBuffer = \"\";\r\n                        var vi = value.length - 1;\r\n                        var fmtOnly = true;\r\n                        // Iterate through format chars and replace 0 and # with the digits from the value string\r\n                        for (var fi = format.length - 1; fi > -1; fi--) {\r\n                            var formatChar = format.charAt(fi);\r\n                            switch (formatChar) {\r\n                                case ZeroPlaceholder:\r\n                                case DigitPlaceholder:\r\n                                    fmtOnly = false;\r\n                                    if (leftBuffer !== \"\") {\r\n                                        result = leftBuffer + result;\r\n                                        leftBuffer = \"\";\r\n                                    }\r\n                                    if (!suppressModifyValue) {\r\n                                        if (vi > -1 || formatChar === ZeroPlaceholder) {\r\n                                            if (enableGroups) {\r\n                                                // If the groups are enabled we'll need to keep track of the current group index and periodically insert group separator,\r\n                                                if (groupDigitCount === groupSize) {\r\n                                                    result = groupSeparator + result;\r\n                                                    groupIndex++;\r\n                                                    if (groupIndex < groupSizes.length) {\r\n                                                        groupSize = groupSizes[groupIndex];\r\n                                                    }\r\n                                                    groupDigitCount = 1;\r\n                                                }\r\n                                                else {\r\n                                                    groupDigitCount++;\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                        if (vi > -1) {\r\n                                            if (isZero && formatChar === DigitPlaceholder) {\r\n                                            }\r\n                                            else {\r\n                                                result = value.charAt(vi) + result;\r\n                                            }\r\n                                            vi--;\r\n                                        }\r\n                                        else if (formatChar !== DigitPlaceholder) {\r\n                                            result = formatChar + result;\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                                case \",\":\r\n                                    // We should skip all the , chars\r\n                                    break;\r\n                                default:\r\n                                    leftBuffer = formatChar + leftBuffer;\r\n                                    break;\r\n                            }\r\n                        }\r\n                        // If the value didn't fit into the number of zeros provided in the format then we should insert the missing part of the value into the result\r\n                        if (!suppressModifyValue) {\r\n                            if (vi > -1 && result !== \"\") {\r\n                                if (enableGroups) {\r\n                                    while (vi > -1) {\r\n                                        if (groupDigitCount === groupSize) {\r\n                                            result = groupSeparator + result;\r\n                                            groupIndex++;\r\n                                            if (groupIndex < groupSizes.length) {\r\n                                                groupSize = groupSizes[groupIndex];\r\n                                            }\r\n                                            groupDigitCount = 1;\r\n                                        }\r\n                                        else {\r\n                                            groupDigitCount++;\r\n                                        }\r\n                                        result = value.charAt(vi) + result;\r\n                                        vi--;\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    result = value.substr(0, vi + 1) + result;\r\n                                }\r\n                            }\r\n                            // Insert sign in front of the leftBuffer and result\r\n                            return sign + leftBuffer + result;\r\n                        }\r\n                        if (fmtOnly)\r\n                            // If the format doesn't specify any digits to be displayed, then just return the format we've parsed up until now.\r\n                            return sign + leftBuffer + result;\r\n                        return sign + leftBuffer + value + result;\r\n                    }\r\n                    function fuseNumberWithCustomFormatRight(value, format, suppressModifyValue) {\r\n                        var vi = 0;\r\n                        var fCount = format.length;\r\n                        var vCount = value.length;\r\n                        if (suppressModifyValue) {\r\n                            var lastChar = format.charAt(fCount - 1);\r\n                            if (!lastChar.match(NumericPlaceholderRegex))\r\n                                return {\r\n                                    value: value + lastChar,\r\n                                    fmtOnly: value === \"\",\r\n                                };\r\n                            return {\r\n                                value: value,\r\n                                fmtOnly: value === \"\",\r\n                            };\r\n                        }\r\n                        var result = \"\", fmtOnly = true;\r\n                        for (var fi = 0; fi < fCount; fi++) {\r\n                            var formatChar = format.charAt(fi);\r\n                            if (vi < vCount) {\r\n                                switch (formatChar) {\r\n                                    case ZeroPlaceholder:\r\n                                    case DigitPlaceholder:\r\n                                        result += value[vi++];\r\n                                        fmtOnly = false;\r\n                                        break;\r\n                                    default:\r\n                                        result += formatChar;\r\n                                }\r\n                            }\r\n                            else {\r\n                                if (formatChar !== DigitPlaceholder) {\r\n                                    result += formatChar;\r\n                                    fmtOnly = fmtOnly && (formatChar !== ZeroPlaceholder);\r\n                                }\r\n                            }\r\n                        }\r\n                        return {\r\n                            value: result,\r\n                            fmtOnly: fmtOnly,\r\n                        };\r\n                    }\r\n                    function localize(value, dictionary) {\r\n                        var plus = dictionary[\"+\"];\r\n                        var minus = dictionary[\"-\"];\r\n                        var dot = dictionary[\".\"];\r\n                        var comma = dictionary[\",\"];\r\n                        if (plus === \"+\" && minus === \"-\" && dot === \".\" && comma === \",\") {\r\n                            return value;\r\n                        }\r\n                        var count = value.length;\r\n                        var result = \"\";\r\n                        for (var i = 0; i < count; i++) {\r\n                            var char = value.charAt(i);\r\n                            switch (char) {\r\n                                case \"+\":\r\n                                    result = result + plus;\r\n                                    break;\r\n                                case \"-\":\r\n                                    result = result + minus;\r\n                                    break;\r\n                                case \".\":\r\n                                    result = result + dot;\r\n                                    break;\r\n                                case \",\":\r\n                                    result = result + comma;\r\n                                    break;\r\n                                default:\r\n                                    result = result + char;\r\n                                    break;\r\n                            }\r\n                        }\r\n                        return result;\r\n                    }\r\n                })(numberFormat = formatting.numberFormat || (formatting.numberFormat = {}));\r\n                /** DateTimeScaleFormatInfo is used to calculate and keep the Date formats used for different units supported by the DateTimeScaleModel */\r\n                var DateTimeScaleFormatInfo = (function () {\r\n                    // Constructor\r\n                    /**\r\n                     * Creates new instance of the DateTimeScaleFormatInfo class.\r\n                     * @param culture - culture which calendar info is going to be used to derive the formats.\r\n                     */\r\n                    function DateTimeScaleFormatInfo(culture) {\r\n                        var calendar = culture.calendar;\r\n                        var patterns = calendar.patterns;\r\n                        var monthAbbreviations = calendar[\"months\"][\"namesAbbr\"];\r\n                        var cultureHasMonthAbbr = monthAbbreviations && monthAbbreviations[0];\r\n                        var yearMonthPattern = patterns[\"Y\"];\r\n                        var monthDayPattern = patterns[\"M\"];\r\n                        var fullPattern = patterns[\"f\"];\r\n                        var longTimePattern = patterns[\"T\"];\r\n                        var shortTimePattern = patterns[\"t\"];\r\n                        var separator = fullPattern.indexOf(\",\") > -1 ? \", \" : \" \";\r\n                        var hasYearSymbol = yearMonthPattern.indexOf(\"yyyy'\") === 0 && yearMonthPattern.length > 6 && yearMonthPattern[6] === \"\\'\";\r\n                        this.YearPattern = hasYearSymbol ? yearMonthPattern.substr(0, 7) : \"yyyy\";\r\n                        var yearPos = fullPattern.indexOf(\"yy\");\r\n                        var monthPos = fullPattern.indexOf(\"MMMM\");\r\n                        this.MonthPattern = cultureHasMonthAbbr && monthPos > -1 ? (yearPos > monthPos ? \"MMM yyyy\" : \"yyyy MMM\") : yearMonthPattern;\r\n                        this.DayPattern = cultureHasMonthAbbr ? monthDayPattern.replace(\"MMMM\", \"MMM\") : monthDayPattern;\r\n                        var minutePos = fullPattern.indexOf(\"mm\");\r\n                        var pmPos = fullPattern.indexOf(\"tt\");\r\n                        var shortHourPattern = pmPos > -1 ? shortTimePattern.replace(\":mm \", \"\") : shortTimePattern;\r\n                        this.HourPattern = yearPos < minutePos ? this.DayPattern + separator + shortHourPattern : shortHourPattern + separator + this.DayPattern;\r\n                        this.MinutePattern = shortTimePattern;\r\n                        this.SecondPattern = longTimePattern;\r\n                        this.MillisecondPattern = longTimePattern.replace(\"ss\", \"ss.fff\");\r\n                        // Special cases\r\n                        switch (culture.name) {\r\n                            case \"fi-FI\":\r\n                                this.DayPattern = this.DayPattern.replace(\"'ta'\", \"\"); // Fix for finish 'ta' suffix for month names.\r\n                                this.HourPattern = this.HourPattern.replace(\"'ta'\", \"\");\r\n                                break;\r\n                        }\r\n                    }\r\n                    // Methods\r\n                    /**\r\n                     * Returns the format string of the provided DateTimeUnit.\r\n                     * @param unit - date or time unit\r\n                     */\r\n                    DateTimeScaleFormatInfo.prototype.getFormatString = function (unit) {\r\n                        switch (unit) {\r\n                            case DateTimeUnit.Year:\r\n                                return this.YearPattern;\r\n                            case DateTimeUnit.Month:\r\n                                return this.MonthPattern;\r\n                            case DateTimeUnit.Week:\r\n                            case DateTimeUnit.Day:\r\n                                return this.DayPattern;\r\n                            case DateTimeUnit.Hour:\r\n                                return this.HourPattern;\r\n                            case DateTimeUnit.Minute:\r\n                                return this.MinutePattern;\r\n                            case DateTimeUnit.Second:\r\n                                return this.SecondPattern;\r\n                            case DateTimeUnit.Millisecond:\r\n                                return this.MillisecondPattern;\r\n                        }\r\n                    };\r\n                    return DateTimeScaleFormatInfo;\r\n                }());\r\n                formatting.formattingService = new FormattingService();\r\n            })(formatting = utils.formatting || (utils.formatting = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\"use strict\";\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var formatting;\r\n            (function (formatting) {\r\n                /** The system used to determine display units used during formatting */\r\n                var DisplayUnitSystemType;\r\n                (function (DisplayUnitSystemType) {\r\n                    /** Default display unit system, which saves space by using units such as K, M, bn with PowerView rules for when to pick a unit. Suitable for chart axes. */\r\n                    DisplayUnitSystemType[DisplayUnitSystemType[\"Default\"] = 0] = \"Default\";\r\n                    /** A verbose display unit system that will only respect the formatting defined in the model. Suitable for explore mode single-value cards. */\r\n                    DisplayUnitSystemType[DisplayUnitSystemType[\"Verbose\"] = 1] = \"Verbose\";\r\n                    /**\r\n                     * A display unit system that uses units such as K, M, bn if we have at least one of those units (e.g. 0.9M is not valid as it's less than 1 million).\r\n                     * Suitable for dashboard tile cards\r\n                     */\r\n                    DisplayUnitSystemType[DisplayUnitSystemType[\"WholeUnits\"] = 2] = \"WholeUnits\";\r\n                    /**A display unit system that also contains Auto and None units for data labels*/\r\n                    DisplayUnitSystemType[DisplayUnitSystemType[\"DataLabels\"] = 3] = \"DataLabels\";\r\n                })(DisplayUnitSystemType = formatting.DisplayUnitSystemType || (formatting.DisplayUnitSystemType = {}));\r\n            })(formatting = utils.formatting || (utils.formatting = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\"use strict\";\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var formatting;\r\n            (function (formatting) {\r\n                var Double = powerbi.extensibility.utils.type.Double;\r\n                var NumberFormat = powerbi.extensibility.utils.formatting.numberFormat;\r\n                var formattingService = powerbi.extensibility.utils.formatting.formattingService;\r\n                // Constants\r\n                var maxExponent = 24;\r\n                var defaultScientificBigNumbersBoundary = 1E15;\r\n                var scientificSmallNumbersBoundary = 1E-4;\r\n                var PERCENTAGE_FORMAT = \"%\";\r\n                var SCIENTIFIC_FORMAT = \"E+0\";\r\n                var DEFAULT_SCIENTIFIC_FORMAT = \"0.##\" + SCIENTIFIC_FORMAT;\r\n                // Regular expressions\r\n                /**\r\n                 * This regex looks for strings that match one of the following conditions:\r\n                 *   - Optionally contain \"0\", \"#\", followed by a period, followed by at least one \"0\" or \"#\" (Ex. ###,000.###)\r\n                 *   - Contains at least one of \"0\", \"#\", or \",\" (Ex. ###,000)\r\n                 *   - Contain a \"g\" (indicates to use the general .NET numeric format string)\r\n                 * The entire string (start to end) must match, and the match is not case-sensitive.\r\n                 */\r\n                var SUPPORTED_SCIENTIFIC_FORMATS = /^([0\\#,]*\\.[0\\#]+|[0\\#,]+|g)$/i;\r\n                var DisplayUnit = (function () {\r\n                    function DisplayUnit() {\r\n                    }\r\n                    // Methods\r\n                    DisplayUnit.prototype.project = function (value) {\r\n                        if (this.value) {\r\n                            return Double.removeDecimalNoise(value / this.value);\r\n                        }\r\n                        else {\r\n                            return value;\r\n                        }\r\n                    };\r\n                    DisplayUnit.prototype.reverseProject = function (value) {\r\n                        if (this.value) {\r\n                            return value * this.value;\r\n                        }\r\n                        else {\r\n                            return value;\r\n                        }\r\n                    };\r\n                    DisplayUnit.prototype.isApplicableTo = function (value) {\r\n                        value = Math.abs(value);\r\n                        var precision = Double.getPrecision(value, 3);\r\n                        return Double.greaterOrEqualWithPrecision(value, this.applicableRangeMin, precision) && Double.lessWithPrecision(value, this.applicableRangeMax, precision);\r\n                    };\r\n                    DisplayUnit.prototype.isScaling = function () {\r\n                        return this.value > 1;\r\n                    };\r\n                    return DisplayUnit;\r\n                }());\r\n                formatting.DisplayUnit = DisplayUnit;\r\n                var DisplayUnitSystem = (function () {\r\n                    // Constructor\r\n                    function DisplayUnitSystem(units) {\r\n                        this.units = units ? units : [];\r\n                    }\r\n                    Object.defineProperty(DisplayUnitSystem.prototype, \"title\", {\r\n                        // Properties\r\n                        get: function () {\r\n                            return this.displayUnit ? this.displayUnit.title : undefined;\r\n                        },\r\n                        enumerable: true,\r\n                        configurable: true\r\n                    });\r\n                    // Methods\r\n                    DisplayUnitSystem.prototype.update = function (value) {\r\n                        if (value === undefined)\r\n                            return;\r\n                        this.unitBaseValue = value;\r\n                        this.displayUnit = this.findApplicableDisplayUnit(value);\r\n                    };\r\n                    DisplayUnitSystem.prototype.findApplicableDisplayUnit = function (value) {\r\n                        for (var _i = 0, _a = this.units; _i < _a.length; _i++) {\r\n                            var unit = _a[_i];\r\n                            if (unit.isApplicableTo(value))\r\n                                return unit;\r\n                        }\r\n                        return undefined;\r\n                    };\r\n                    DisplayUnitSystem.prototype.format = function (value, format, decimals, trailingZeros, cultureSelector) {\r\n                        decimals = this.getNumberOfDecimalsForFormatting(format, decimals);\r\n                        var nonScientificFormat = \"\";\r\n                        if (this.isFormatSupported(format)\r\n                            && !this.hasScientitifcFormat(format)\r\n                            && this.isScalingUnit()\r\n                            && this.shouldRespectScalingUnit(format)) {\r\n                            value = this.displayUnit.project(value);\r\n                            nonScientificFormat = this.displayUnit.labelFormat;\r\n                        }\r\n                        return this.formatHelper({\r\n                            value: value,\r\n                            nonScientificFormat: nonScientificFormat,\r\n                            format: format,\r\n                            decimals: decimals,\r\n                            trailingZeros: trailingZeros,\r\n                            cultureSelector: cultureSelector\r\n                        });\r\n                    };\r\n                    DisplayUnitSystem.prototype.isFormatSupported = function (format) {\r\n                        return !DisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\r\n                    };\r\n                    DisplayUnitSystem.prototype.isPercentageFormat = function (format) {\r\n                        return format && format.indexOf(PERCENTAGE_FORMAT) >= 0;\r\n                    };\r\n                    DisplayUnitSystem.prototype.shouldRespectScalingUnit = function (format) {\r\n                        return true;\r\n                    };\r\n                    DisplayUnitSystem.prototype.getNumberOfDecimalsForFormatting = function (format, decimals) {\r\n                        return decimals;\r\n                    };\r\n                    DisplayUnitSystem.prototype.isScalingUnit = function () {\r\n                        return this.displayUnit && this.displayUnit.isScaling();\r\n                    };\r\n                    DisplayUnitSystem.prototype.formatHelper = function (options) {\r\n                        var value = options.value, nonScientificFormat = options.nonScientificFormat, cultureSelector = options.cultureSelector, format = options.format, decimals = options.decimals, trailingZeros = options.trailingZeros;\r\n                        // If the format is \"general\" and we want to override the number of decimal places then use the default numeric format string.\r\n                        if ((format === \"g\" || format === \"G\") && decimals != null) {\r\n                            format = \"#,0.00\";\r\n                        }\r\n                        format = NumberFormat.addDecimalsToFormat(format, decimals, trailingZeros);\r\n                        if (format && !formattingService.isStandardNumberFormat(format))\r\n                            return formattingService.formatNumberWithCustomOverride(value, format, nonScientificFormat, cultureSelector);\r\n                        if (!format) {\r\n                            format = \"G\";\r\n                        }\r\n                        if (!nonScientificFormat) {\r\n                            nonScientificFormat = \"{0}\";\r\n                        }\r\n                        var text = formattingService.formatValue(value, format, cultureSelector);\r\n                        return formattingService.format(nonScientificFormat, [text]);\r\n                    };\r\n                    /** Formats a single value by choosing an appropriate base for the DisplayUnitSystem before formatting. */\r\n                    DisplayUnitSystem.prototype.formatSingleValue = function (value, format, decimals, trailingZeros, cultureSelector) {\r\n                        // Change unit base to a value appropriate for this value\r\n                        this.update(this.shouldUseValuePrecision(value) ? Double.getPrecision(value, 8) : value);\r\n                        return this.format(value, format, decimals, trailingZeros, cultureSelector);\r\n                    };\r\n                    DisplayUnitSystem.prototype.shouldUseValuePrecision = function (value) {\r\n                        if (this.units.length === 0)\r\n                            return true;\r\n                        // Check if the value is big enough to have a valid unit by checking against the smallest unit (that it's value bigger than 1).\r\n                        var applicableRangeMin = 0;\r\n                        for (var i = 0; i < this.units.length; i++) {\r\n                            if (this.units[i].isScaling()) {\r\n                                applicableRangeMin = this.units[i].applicableRangeMin;\r\n                                break;\r\n                            }\r\n                        }\r\n                        return Math.abs(value) < applicableRangeMin;\r\n                    };\r\n                    DisplayUnitSystem.prototype.isScientific = function (value) {\r\n                        return value < -defaultScientificBigNumbersBoundary || value > defaultScientificBigNumbersBoundary ||\r\n                            (-scientificSmallNumbersBoundary < value && value < scientificSmallNumbersBoundary && value !== 0);\r\n                    };\r\n                    DisplayUnitSystem.prototype.hasScientitifcFormat = function (format) {\r\n                        return format && format.toUpperCase().indexOf(\"E\") !== -1;\r\n                    };\r\n                    DisplayUnitSystem.prototype.supportsScientificFormat = function (format) {\r\n                        if (format)\r\n                            return SUPPORTED_SCIENTIFIC_FORMATS.test(format);\r\n                        return true;\r\n                    };\r\n                    DisplayUnitSystem.prototype.shouldFallbackToScientific = function (value, format) {\r\n                        return !this.hasScientitifcFormat(format)\r\n                            && this.supportsScientificFormat(format)\r\n                            && this.isScientific(value);\r\n                    };\r\n                    DisplayUnitSystem.prototype.getScientificFormat = function (data, format, decimals, trailingZeros) {\r\n                        // Use scientific format outside of the range\r\n                        if (this.isFormatSupported(format) && this.shouldFallbackToScientific(data, format)) {\r\n                            var numericFormat = NumberFormat.getNumericFormat(data, format);\r\n                            if (decimals)\r\n                                numericFormat = NumberFormat.addDecimalsToFormat(numericFormat ? numericFormat : \"0\", Math.abs(decimals), trailingZeros);\r\n                            if (numericFormat)\r\n                                return numericFormat + SCIENTIFIC_FORMAT;\r\n                            else\r\n                                return DEFAULT_SCIENTIFIC_FORMAT;\r\n                        }\r\n                        return format;\r\n                    };\r\n                    return DisplayUnitSystem;\r\n                }());\r\n                DisplayUnitSystem.UNSUPPORTED_FORMATS = /^(p\\d*)|(e\\d*)$/i;\r\n                formatting.DisplayUnitSystem = DisplayUnitSystem;\r\n                /** Provides a unit system that is defined by formatting in the model, and is suitable for visualizations shown in single number visuals in explore mode. */\r\n                var NoDisplayUnitSystem = (function (_super) {\r\n                    __extends(NoDisplayUnitSystem, _super);\r\n                    // Constructor\r\n                    function NoDisplayUnitSystem() {\r\n                        return _super.call(this, []) || this;\r\n                    }\r\n                    return NoDisplayUnitSystem;\r\n                }(DisplayUnitSystem));\r\n                formatting.NoDisplayUnitSystem = NoDisplayUnitSystem;\r\n                /** Provides a unit system that creates a more concise format for displaying values. This is suitable for most of the cases where\r\n                    we are showing values (chart axes) and as such it is the default unit system. */\r\n                var DefaultDisplayUnitSystem = (function (_super) {\r\n                    __extends(DefaultDisplayUnitSystem, _super);\r\n                    // Constructor\r\n                    function DefaultDisplayUnitSystem(unitLookup) {\r\n                        return _super.call(this, DefaultDisplayUnitSystem.getUnits(unitLookup)) || this;\r\n                    }\r\n                    // Methods\r\n                    DefaultDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros, cultureSelector) {\r\n                        format = this.getScientificFormat(data, format, decimals, trailingZeros);\r\n                        return _super.prototype.format.call(this, data, format, decimals, trailingZeros, cultureSelector);\r\n                    };\r\n                    DefaultDisplayUnitSystem.reset = function () {\r\n                        DefaultDisplayUnitSystem.units = null;\r\n                    };\r\n                    DefaultDisplayUnitSystem.getUnits = function (unitLookup) {\r\n                        if (!DefaultDisplayUnitSystem.units) {\r\n                            DefaultDisplayUnitSystem.units = createDisplayUnits(unitLookup, function (value, previousUnitValue, min) {\r\n                                // When dealing with millions/billions/trillions we need to switch to millions earlier: for example instead of showing 100K 200K 300K we should show 0.1M 0.2M 0.3M etc\r\n                                if (value - previousUnitValue >= 1000) {\r\n                                    return value / 10;\r\n                                }\r\n                                return min;\r\n                            });\r\n                            // Ensure last unit has max of infinity\r\n                            DefaultDisplayUnitSystem.units[DefaultDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\r\n                        }\r\n                        return DefaultDisplayUnitSystem.units;\r\n                    };\r\n                    return DefaultDisplayUnitSystem;\r\n                }(DisplayUnitSystem));\r\n                formatting.DefaultDisplayUnitSystem = DefaultDisplayUnitSystem;\r\n                /** Provides a unit system that creates a more concise format for displaying values, but only allows showing a unit if we have at least\r\n                    one of those units (e.g. 0.9M is not allowed since it's less than 1 million). This is suitable for cases such as dashboard tiles\r\n                    where we have restricted space but do not want to show partial units. */\r\n                var WholeUnitsDisplayUnitSystem = (function (_super) {\r\n                    __extends(WholeUnitsDisplayUnitSystem, _super);\r\n                    // Constructor\r\n                    function WholeUnitsDisplayUnitSystem(unitLookup) {\r\n                        return _super.call(this, WholeUnitsDisplayUnitSystem.getUnits(unitLookup)) || this;\r\n                    }\r\n                    WholeUnitsDisplayUnitSystem.reset = function () {\r\n                        WholeUnitsDisplayUnitSystem.units = null;\r\n                    };\r\n                    WholeUnitsDisplayUnitSystem.getUnits = function (unitLookup) {\r\n                        if (!WholeUnitsDisplayUnitSystem.units) {\r\n                            WholeUnitsDisplayUnitSystem.units = createDisplayUnits(unitLookup);\r\n                            // Ensure last unit has max of infinity\r\n                            WholeUnitsDisplayUnitSystem.units[WholeUnitsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\r\n                        }\r\n                        return WholeUnitsDisplayUnitSystem.units;\r\n                    };\r\n                    WholeUnitsDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros, cultureSelector) {\r\n                        format = this.getScientificFormat(data, format, decimals, trailingZeros);\r\n                        return _super.prototype.format.call(this, data, format, decimals, trailingZeros, cultureSelector);\r\n                    };\r\n                    return WholeUnitsDisplayUnitSystem;\r\n                }(DisplayUnitSystem));\r\n                formatting.WholeUnitsDisplayUnitSystem = WholeUnitsDisplayUnitSystem;\r\n                var DataLabelsDisplayUnitSystem = (function (_super) {\r\n                    __extends(DataLabelsDisplayUnitSystem, _super);\r\n                    function DataLabelsDisplayUnitSystem(unitLookup) {\r\n                        return _super.call(this, DataLabelsDisplayUnitSystem.getUnits(unitLookup)) || this;\r\n                    }\r\n                    DataLabelsDisplayUnitSystem.prototype.isFormatSupported = function (format) {\r\n                        return !DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\r\n                    };\r\n                    DataLabelsDisplayUnitSystem.getUnits = function (unitLookup) {\r\n                        if (!DataLabelsDisplayUnitSystem.units) {\r\n                            var units = [];\r\n                            var adjustMinBasedOnPreviousUnit = function (value, previousUnitValue, min) {\r\n                                // Never returns true, we are always ignoring\r\n                                // We do not early switch (e.g. 100K instead of 0.1M)\r\n                                // Intended? If so, remove this function, otherwise, remove if statement\r\n                                if (value === -1)\r\n                                    if (value - previousUnitValue >= 1000) {\r\n                                        return value / 10;\r\n                                    }\r\n                                return min;\r\n                            };\r\n                            // Add Auto & None\r\n                            var names = unitLookup(-1);\r\n                            addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\r\n                            names = unitLookup(0);\r\n                            addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\r\n                            // Add normal units\r\n                            DataLabelsDisplayUnitSystem.units = units.concat(createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit));\r\n                            // Ensure last unit has max of infinity\r\n                            DataLabelsDisplayUnitSystem.units[DataLabelsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\r\n                        }\r\n                        return DataLabelsDisplayUnitSystem.units;\r\n                    };\r\n                    DataLabelsDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros, cultureSelector) {\r\n                        format = this.getScientificFormat(data, format, decimals, trailingZeros);\r\n                        return _super.prototype.format.call(this, data, format, decimals, trailingZeros, cultureSelector);\r\n                    };\r\n                    return DataLabelsDisplayUnitSystem;\r\n                }(DisplayUnitSystem));\r\n                // Constants\r\n                DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE = 0;\r\n                DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE = 1;\r\n                DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS = /^(e\\d*)$/i;\r\n                formatting.DataLabelsDisplayUnitSystem = DataLabelsDisplayUnitSystem;\r\n                function createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit) {\r\n                    var units = [];\r\n                    for (var i = 3; i < maxExponent; i++) {\r\n                        var names = unitLookup(i);\r\n                        if (names)\r\n                            addUnitIfNonEmpty(units, Double.pow10(i), names.title, names.format, adjustMinBasedOnPreviousUnit);\r\n                    }\r\n                    return units;\r\n                }\r\n                function addUnitIfNonEmpty(units, value, title, labelFormat, adjustMinBasedOnPreviousUnit) {\r\n                    if (title || labelFormat) {\r\n                        var min = value;\r\n                        if (units.length > 0) {\r\n                            var previousUnit = units[units.length - 1];\r\n                            if (adjustMinBasedOnPreviousUnit)\r\n                                min = adjustMinBasedOnPreviousUnit(value, previousUnit.value, min);\r\n                            previousUnit.applicableRangeMax = min;\r\n                        }\r\n                        var unit = new DisplayUnit();\r\n                        unit.value = value;\r\n                        unit.applicableRangeMin = min;\r\n                        unit.applicableRangeMax = min * 1000;\r\n                        unit.title = title;\r\n                        unit.labelFormat = labelFormat;\r\n                        units.push(unit);\r\n                    }\r\n                }\r\n            })(formatting = utils.formatting || (utils.formatting = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\"use strict\";\r\n/**\r\n * Contains functions/constants to aid in text manupilation.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var formatting;\r\n            (function (formatting) {\r\n                var textUtil;\r\n                (function (textUtil) {\r\n                    /**\r\n                     * Remove breaking spaces from given string and replace by none breaking space (&nbsp).\r\n                     */\r\n                    function removeBreakingSpaces(str) {\r\n                        return str.toString().replace(new RegExp(\" \", \"g\"), \"&nbsp\");\r\n                    }\r\n                    textUtil.removeBreakingSpaces = removeBreakingSpaces;\r\n                    /**\r\n                     * Remove ellipses from a given string\r\n                     */\r\n                    function removeEllipses(str) {\r\n                        return str.replace(/(…)|(\\.\\.\\.)/g, \"\");\r\n                    }\r\n                    textUtil.removeEllipses = removeEllipses;\r\n                    /**\r\n                    * Replace every whitespace (0x20) with Non-Breaking Space (0xA0)\r\n                     * @param {string} txt String to replace White spaces\r\n                     * @returns Text after replcing white spaces\r\n                     */\r\n                    function replaceSpaceWithNBSP(txt) {\r\n                        if (txt != null) {\r\n                            return txt.replace(/ /g, \"\\xA0\");\r\n                        }\r\n                    }\r\n                    textUtil.replaceSpaceWithNBSP = replaceSpaceWithNBSP;\r\n                })(textUtil = formatting.textUtil || (formatting.textUtil = {}));\r\n            })(formatting = utils.formatting || (utils.formatting = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\"use strict\";\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var formatting;\r\n            (function (formatting) {\r\n                // powerbi.extensibility.utils.type\r\n                var ValueType = powerbi.extensibility.utils.type.ValueType;\r\n                var PrimitiveType = powerbi.extensibility.utils.type.PrimitiveType;\r\n                var Double = powerbi.extensibility.utils.type.Double;\r\n                // powerbi.extensibility.utils.formatting\r\n                var stringExtensions = powerbi.extensibility.utils.formatting.stringExtensions;\r\n                var DisplayUnitSystemType = powerbi.extensibility.utils.formatting.DisplayUnitSystemType;\r\n                var DefaultDisplayUnitSystem = powerbi.extensibility.utils.formatting.DefaultDisplayUnitSystem;\r\n                var NumberFormat = powerbi.extensibility.utils.formatting.numberFormat;\r\n                var WholeUnitsDisplayUnitSystem = powerbi.extensibility.utils.formatting.WholeUnitsDisplayUnitSystem;\r\n                var DateTimeSequence = powerbi.extensibility.utils.formatting.DateTimeSequence;\r\n                var NoDisplayUnitSystem = powerbi.extensibility.utils.formatting.NoDisplayUnitSystem;\r\n                var DataLabelsDisplayUnitSystem = powerbi.extensibility.utils.formatting.DataLabelsDisplayUnitSystem;\r\n                var formattingService = powerbi.extensibility.utils.formatting.formattingService;\r\n                // powerbi.extensibility.utils.dataview\r\n                var DataViewObjects = powerbi.extensibility.utils.dataview.DataViewObjects;\r\n                var valueFormatter;\r\n                (function (valueFormatter) {\r\n                    var StringExtensions = stringExtensions;\r\n                    var BeautifiedFormat = {\r\n                        \"0.00 %;-0.00 %;0.00 %\": \"Percentage\",\r\n                        \"0.0 %;-0.0 %;0.0 %\": \"Percentage1\",\r\n                    };\r\n                    valueFormatter.DefaultIntegerFormat = \"g\";\r\n                    valueFormatter.DefaultNumericFormat = \"#,0.00\";\r\n                    valueFormatter.DefaultDateFormat = \"d\";\r\n                    var defaultLocalizedStrings = {\r\n                        \"NullValue\": \"(Blank)\",\r\n                        \"BooleanTrue\": \"True\",\r\n                        \"BooleanFalse\": \"False\",\r\n                        \"NaNValue\": \"NaN\",\r\n                        \"InfinityValue\": \"+Infinity\",\r\n                        \"NegativeInfinityValue\": \"-Infinity\",\r\n                        \"RestatementComma\": \"{0}, {1}\",\r\n                        \"RestatementCompoundAnd\": \"{0} and {1}\",\r\n                        \"RestatementCompoundOr\": \"{0} or {1}\",\r\n                        \"DisplayUnitSystem_EAuto_Title\": \"Auto\",\r\n                        \"DisplayUnitSystem_E0_Title\": \"None\",\r\n                        \"DisplayUnitSystem_E3_LabelFormat\": \"{0}K\",\r\n                        \"DisplayUnitSystem_E3_Title\": \"Thousands\",\r\n                        \"DisplayUnitSystem_E6_LabelFormat\": \"{0}M\",\r\n                        \"DisplayUnitSystem_E6_Title\": \"Millions\",\r\n                        \"DisplayUnitSystem_E9_LabelFormat\": \"{0}bn\",\r\n                        \"DisplayUnitSystem_E9_Title\": \"Billions\",\r\n                        \"DisplayUnitSystem_E12_LabelFormat\": \"{0}T\",\r\n                        \"DisplayUnitSystem_E12_Title\": \"Trillions\",\r\n                        \"Percentage\": \"#,0.##%\",\r\n                        \"Percentage1\": \"#,0.#%\",\r\n                        \"TableTotalLabel\": \"Total\",\r\n                        \"Tooltip_HighlightedValueDisplayName\": \"Highlighted\",\r\n                        \"Funnel_PercentOfFirst\": \"Percent of first\",\r\n                        \"Funnel_PercentOfPrevious\": \"Percent of previous\",\r\n                        \"Funnel_PercentOfFirst_Highlight\": \"Percent of first (highlighted)\",\r\n                        \"Funnel_PercentOfPrevious_Highlight\": \"Percent of previous (highlighted)\",\r\n                        // Geotagging strings\r\n                        \"GeotaggingString_Continent\": \"continent\",\r\n                        \"GeotaggingString_Continents\": \"continents\",\r\n                        \"GeotaggingString_Country\": \"country\",\r\n                        \"GeotaggingString_Countries\": \"countries\",\r\n                        \"GeotaggingString_State\": \"state\",\r\n                        \"GeotaggingString_States\": \"states\",\r\n                        \"GeotaggingString_City\": \"city\",\r\n                        \"GeotaggingString_Cities\": \"cities\",\r\n                        \"GeotaggingString_Town\": \"town\",\r\n                        \"GeotaggingString_Towns\": \"towns\",\r\n                        \"GeotaggingString_Province\": \"province\",\r\n                        \"GeotaggingString_Provinces\": \"provinces\",\r\n                        \"GeotaggingString_County\": \"county\",\r\n                        \"GeotaggingString_Counties\": \"counties\",\r\n                        \"GeotaggingString_Village\": \"village\",\r\n                        \"GeotaggingString_Villages\": \"villages\",\r\n                        \"GeotaggingString_Post\": \"post\",\r\n                        \"GeotaggingString_Zip\": \"zip\",\r\n                        \"GeotaggingString_Code\": \"code\",\r\n                        \"GeotaggingString_Place\": \"place\",\r\n                        \"GeotaggingString_Places\": \"places\",\r\n                        \"GeotaggingString_Address\": \"address\",\r\n                        \"GeotaggingString_Addresses\": \"addresses\",\r\n                        \"GeotaggingString_Street\": \"street\",\r\n                        \"GeotaggingString_Streets\": \"streets\",\r\n                        \"GeotaggingString_Longitude\": \"longitude\",\r\n                        \"GeotaggingString_Longitude_Short\": \"lon\",\r\n                        \"GeotaggingString_Longitude_Short2\": \"long\",\r\n                        \"GeotaggingString_Latitude\": \"latitude\",\r\n                        \"GeotaggingString_Latitude_Short\": \"lat\",\r\n                        \"GeotaggingString_PostalCode\": \"postal code\",\r\n                        \"GeotaggingString_PostalCodes\": \"postal codes\",\r\n                        \"GeotaggingString_ZipCode\": \"zip code\",\r\n                        \"GeotaggingString_ZipCodes\": \"zip codes\",\r\n                        \"GeotaggingString_Territory\": \"territory\",\r\n                        \"GeotaggingString_Territories\": \"territories\",\r\n                    };\r\n                    function beautify(format) {\r\n                        var key = BeautifiedFormat[format];\r\n                        if (key)\r\n                            return defaultLocalizedStrings[key] || format;\r\n                        return format;\r\n                    }\r\n                    function describeUnit(exponent) {\r\n                        var exponentLookup = (exponent === -1) ? \"Auto\" : exponent.toString();\r\n                        var title = defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_Title\"];\r\n                        var format = (exponent <= 0) ? \"{0}\" : defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_LabelFormat\"];\r\n                        if (title || format)\r\n                            return { title: title, format: format };\r\n                    }\r\n                    function getLocalizedString(stringId) {\r\n                        return defaultLocalizedStrings[stringId];\r\n                    }\r\n                    valueFormatter.getLocalizedString = getLocalizedString;\r\n                    // NOTE: Define default locale options, but these can be overriden by setLocaleOptions.\r\n                    var localizationOptions = {\r\n                        nullValue: defaultLocalizedStrings[\"NullValue\"],\r\n                        trueValue: defaultLocalizedStrings[\"BooleanTrue\"],\r\n                        falseValue: defaultLocalizedStrings[\"BooleanFalse\"],\r\n                        NaN: defaultLocalizedStrings[\"NaNValue\"],\r\n                        infinity: defaultLocalizedStrings[\"InfinityValue\"],\r\n                        negativeInfinity: defaultLocalizedStrings[\"NegativeInfinityValue\"],\r\n                        beautify: function (format) { return beautify(format); },\r\n                        describe: function (exponent) { return describeUnit(exponent); },\r\n                        restatementComma: defaultLocalizedStrings[\"RestatementComma\"],\r\n                        restatementCompoundAnd: defaultLocalizedStrings[\"RestatementCompoundAnd\"],\r\n                        restatementCompoundOr: defaultLocalizedStrings[\"RestatementCompoundOr\"],\r\n                    };\r\n                    var MaxScaledDecimalPlaces = 2;\r\n                    var MaxValueForDisplayUnitRounding = 1000;\r\n                    var MinIntegerValueForDisplayUnits = 10000;\r\n                    var MinPrecisionForDisplayUnits = 2;\r\n                    var DateTimeMetadataColumn = {\r\n                        displayName: \"\",\r\n                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.DateTime),\r\n                    };\r\n                    function getFormatMetadata(format) {\r\n                        return NumberFormat.getCustomFormatMetadata(format);\r\n                    }\r\n                    valueFormatter.getFormatMetadata = getFormatMetadata;\r\n                    function setLocaleOptions(options) {\r\n                        localizationOptions = options;\r\n                        DefaultDisplayUnitSystem.reset();\r\n                        WholeUnitsDisplayUnitSystem.reset();\r\n                    }\r\n                    valueFormatter.setLocaleOptions = setLocaleOptions;\r\n                    function createDefaultFormatter(formatString, allowFormatBeautification, cultureSelector) {\r\n                        var formatBeautified = allowFormatBeautification\r\n                            ? localizationOptions.beautify(formatString)\r\n                            : formatString;\r\n                        return {\r\n                            format: function (value) {\r\n                                if (value == null) {\r\n                                    return localizationOptions.nullValue;\r\n                                }\r\n                                return formatCore({\r\n                                    value: value,\r\n                                    cultureSelector: cultureSelector,\r\n                                    format: formatBeautified\r\n                                });\r\n                            }\r\n                        };\r\n                    }\r\n                    valueFormatter.createDefaultFormatter = createDefaultFormatter;\r\n                    /** Creates an IValueFormatter to be used for a range of values. */\r\n                    function create(options) {\r\n                        var format = !!options.allowFormatBeautification\r\n                            ? localizationOptions.beautify(options.format)\r\n                            : options.format;\r\n                        var cultureSelector = options.cultureSelector;\r\n                        if (shouldUseNumericDisplayUnits(options)) {\r\n                            var displayUnitSystem_1 = createDisplayUnitSystem(options.displayUnitSystemType);\r\n                            var singleValueFormattingMode_1 = !!options.formatSingleValues;\r\n                            displayUnitSystem_1.update(Math.max(Math.abs(options.value || 0), Math.abs(options.value2 || 0)));\r\n                            var forcePrecision_1 = options.precision != null;\r\n                            var decimals_1;\r\n                            if (forcePrecision_1)\r\n                                decimals_1 = -options.precision;\r\n                            else if (displayUnitSystem_1.displayUnit && displayUnitSystem_1.displayUnit.value > 1)\r\n                                decimals_1 = -MaxScaledDecimalPlaces;\r\n                            return {\r\n                                format: function (value) {\r\n                                    var formattedValue = getStringFormat(value, true /*nullsAreBlank*/);\r\n                                    if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue)) {\r\n                                        return formattedValue;\r\n                                    }\r\n                                    // Round to Double.DEFAULT_PRECISION\r\n                                    if (value\r\n                                        && !displayUnitSystem_1.isScalingUnit()\r\n                                        && Math.abs(value) < MaxValueForDisplayUnitRounding\r\n                                        && !forcePrecision_1) {\r\n                                        value = Double.roundToPrecision(value);\r\n                                    }\r\n                                    return singleValueFormattingMode_1\r\n                                        ? displayUnitSystem_1.formatSingleValue(value, format, decimals_1, forcePrecision_1, cultureSelector)\r\n                                        : displayUnitSystem_1.format(value, format, decimals_1, forcePrecision_1, cultureSelector);\r\n                                },\r\n                                displayUnit: displayUnitSystem_1.displayUnit,\r\n                                options: options\r\n                            };\r\n                        }\r\n                        if (shouldUseDateUnits(options.value, options.value2, options.tickCount)) {\r\n                            var unit_1 = DateTimeSequence.getIntervalUnit(options.value /* minDate */, options.value2 /* maxDate */, options.tickCount);\r\n                            return {\r\n                                format: function (value) {\r\n                                    if (value == null) {\r\n                                        return localizationOptions.nullValue;\r\n                                    }\r\n                                    var formatString = formattingService.dateFormatString(unit_1);\r\n                                    return formatCore({\r\n                                        value: value,\r\n                                        cultureSelector: cultureSelector,\r\n                                        format: formatString,\r\n                                    });\r\n                                },\r\n                                options: options\r\n                            };\r\n                        }\r\n                        return createDefaultFormatter(format, false, cultureSelector);\r\n                    }\r\n                    valueFormatter.create = create;\r\n                    function format(value, format, allowFormatBeautification, cultureSelector) {\r\n                        if (value == null) {\r\n                            return localizationOptions.nullValue;\r\n                        }\r\n                        var formatString = !!allowFormatBeautification\r\n                            ? localizationOptions.beautify(format)\r\n                            : format;\r\n                        return formatCore({\r\n                            value: value,\r\n                            cultureSelector: cultureSelector,\r\n                            format: formatString\r\n                        });\r\n                    }\r\n                    valueFormatter.format = format;\r\n                    /**\r\n                     * Value formatting function to handle variant measures.\r\n                     * For a Date/Time value within a non-date/time field, it's formatted with the default date/time formatString instead of as a number\r\n                     * @param {any} value Value to be formatted\r\n                     * @param {DataViewMetadataColumn} column Field which the value belongs to\r\n                     * @param {DataViewObjectPropertyIdentifier} formatStringProp formatString Property ID\r\n                     * @param {boolean} nullsAreBlank? Whether to show \"(Blank)\" instead of empty string for null values\r\n                     * @returns Formatted value\r\n                     */\r\n                    function formatVariantMeasureValue(value, column, formatStringProp, nullsAreBlank, cultureSelector) {\r\n                        // If column type is not datetime, but the value is of time datetime,\r\n                        // then use the default date format string\r\n                        if (!(column && column.type && column.type.dateTime) && value instanceof Date) {\r\n                            var valueFormat = getFormatString(DateTimeMetadataColumn, null, false);\r\n                            return formatCore({\r\n                                value: value,\r\n                                nullsAreBlank: nullsAreBlank,\r\n                                cultureSelector: cultureSelector,\r\n                                format: valueFormat\r\n                            });\r\n                        }\r\n                        else {\r\n                            var valueFormat = getFormatString(column, formatStringProp);\r\n                            return formatCore({\r\n                                value: value,\r\n                                nullsAreBlank: nullsAreBlank,\r\n                                cultureSelector: cultureSelector,\r\n                                format: valueFormat\r\n                            });\r\n                        }\r\n                    }\r\n                    valueFormatter.formatVariantMeasureValue = formatVariantMeasureValue;\r\n                    function createDisplayUnitSystem(displayUnitSystemType) {\r\n                        if (displayUnitSystemType == null)\r\n                            return new DefaultDisplayUnitSystem(localizationOptions.describe);\r\n                        switch (displayUnitSystemType) {\r\n                            case DisplayUnitSystemType.Default:\r\n                                return new DefaultDisplayUnitSystem(localizationOptions.describe);\r\n                            case DisplayUnitSystemType.WholeUnits:\r\n                                return new WholeUnitsDisplayUnitSystem(localizationOptions.describe);\r\n                            case DisplayUnitSystemType.Verbose:\r\n                                return new NoDisplayUnitSystem();\r\n                            case DisplayUnitSystemType.DataLabels:\r\n                                return new DataLabelsDisplayUnitSystem(localizationOptions.describe);\r\n                            default:\r\n                                return new DefaultDisplayUnitSystem(localizationOptions.describe);\r\n                        }\r\n                    }\r\n                    valueFormatter.createDisplayUnitSystem = createDisplayUnitSystem;\r\n                    function shouldUseNumericDisplayUnits(options) {\r\n                        var value = options.value;\r\n                        var value2 = options.value2;\r\n                        var format = options.format;\r\n                        // For singleValue visuals like card, gauge we don't want to roundoff data to the nearest thousands so format the whole number / integers below 10K to not use display units\r\n                        if (options.formatSingleValues && format) {\r\n                            if (Math.abs(value) < MinIntegerValueForDisplayUnits) {\r\n                                var isCustomFormat = !NumberFormat.isStandardFormat(format);\r\n                                if (isCustomFormat) {\r\n                                    var precision = NumberFormat.getCustomFormatMetadata(format, true /*calculatePrecision*/).precision;\r\n                                    if (precision < MinPrecisionForDisplayUnits)\r\n                                        return false;\r\n                                }\r\n                                else if (Double.isInteger(value))\r\n                                    return false;\r\n                            }\r\n                        }\r\n                        if ((typeof value === \"number\") || (typeof value2 === \"number\")) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                    function shouldUseDateUnits(value, value2, tickCount) {\r\n                        // must check both value and value2 because we'll need to get an interval for date units\r\n                        return (value instanceof Date) && (value2 instanceof Date) && (tickCount !== undefined && tickCount !== null);\r\n                    }\r\n                    /*\r\n                     * Get the column format. Order of precendence is:\r\n                     *  1. Column format\r\n                     *  2. Default PowerView policy for column type\r\n                     */\r\n                    function getFormatString(column, formatStringProperty, suppressTypeFallback) {\r\n                        if (column) {\r\n                            if (formatStringProperty) {\r\n                                var propertyValue = DataViewObjects.getValue(column.objects, formatStringProperty);\r\n                                if (propertyValue)\r\n                                    return propertyValue;\r\n                            }\r\n                            if (!suppressTypeFallback) {\r\n                                var columnType = column.type;\r\n                                if (columnType) {\r\n                                    if (columnType.dateTime)\r\n                                        return valueFormatter.DefaultDateFormat;\r\n                                    if (columnType.integer) {\r\n                                        if (columnType.temporal && columnType.temporal.year)\r\n                                            return \"0\";\r\n                                        return valueFormatter.DefaultIntegerFormat;\r\n                                    }\r\n                                    if (columnType.numeric)\r\n                                        return valueFormatter.DefaultNumericFormat;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    valueFormatter.getFormatString = getFormatString;\r\n                    function getFormatStringByColumn(column, suppressTypeFallback) {\r\n                        if (column) {\r\n                            if (column.format) {\r\n                                return column.format;\r\n                            }\r\n                            if (!suppressTypeFallback) {\r\n                                var columnType = column.type;\r\n                                if (columnType) {\r\n                                    if (columnType.dateTime) {\r\n                                        return valueFormatter.DefaultDateFormat;\r\n                                    }\r\n                                    if (columnType.integer) {\r\n                                        if (columnType.temporal && columnType.temporal.year) {\r\n                                            return \"0\";\r\n                                        }\r\n                                        return valueFormatter.DefaultIntegerFormat;\r\n                                    }\r\n                                    if (columnType.numeric) {\r\n                                        return valueFormatter.DefaultNumericFormat;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        return undefined;\r\n                    }\r\n                    valueFormatter.getFormatStringByColumn = getFormatStringByColumn;\r\n                    function formatListCompound(strings, conjunction) {\r\n                        var result;\r\n                        if (!strings) {\r\n                            return null;\r\n                        }\r\n                        var length = strings.length;\r\n                        if (length > 0) {\r\n                            result = strings[0];\r\n                            var lastIndex = length - 1;\r\n                            for (var i = 1, len = lastIndex; i < len; i++) {\r\n                                var value = strings[i];\r\n                                result = StringExtensions.format(localizationOptions.restatementComma, result, value);\r\n                            }\r\n                            if (length > 1) {\r\n                                var value = strings[lastIndex];\r\n                                result = StringExtensions.format(conjunction, result, value);\r\n                            }\r\n                        }\r\n                        else {\r\n                            result = null;\r\n                        }\r\n                        return result;\r\n                    }\r\n                    /** The returned string will look like 'A, B, ..., and C'  */\r\n                    function formatListAnd(strings) {\r\n                        return formatListCompound(strings, localizationOptions.restatementCompoundAnd);\r\n                    }\r\n                    valueFormatter.formatListAnd = formatListAnd;\r\n                    /** The returned string will look like 'A, B, ..., or C' */\r\n                    function formatListOr(strings) {\r\n                        return formatListCompound(strings, localizationOptions.restatementCompoundOr);\r\n                    }\r\n                    valueFormatter.formatListOr = formatListOr;\r\n                    function formatCore(options) {\r\n                        var value = options.value, format = options.format, nullsAreBlank = options.nullsAreBlank, cultureSelector = options.cultureSelector;\r\n                        var formattedValue = getStringFormat(value, nullsAreBlank ? nullsAreBlank : false);\r\n                        if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue)) {\r\n                            return formattedValue;\r\n                        }\r\n                        return formattingService.formatValue(value, format, cultureSelector);\r\n                    }\r\n                    function getStringFormat(value, nullsAreBlank) {\r\n                        if (value == null && nullsAreBlank) {\r\n                            return localizationOptions.nullValue;\r\n                        }\r\n                        if (value === true) {\r\n                            return localizationOptions.trueValue;\r\n                        }\r\n                        if (value === false) {\r\n                            return localizationOptions.falseValue;\r\n                        }\r\n                        if (typeof value === \"number\" && isNaN(value)) {\r\n                            return localizationOptions.NaN;\r\n                        }\r\n                        if (value === Number.NEGATIVE_INFINITY) {\r\n                            return localizationOptions.negativeInfinity;\r\n                        }\r\n                        if (value === Number.POSITIVE_INFINITY) {\r\n                            return localizationOptions.infinity;\r\n                        }\r\n                        return \"\";\r\n                    }\r\n                    function getDisplayUnits(displayUnitSystemType) {\r\n                        var displayUnitSystem = createDisplayUnitSystem(displayUnitSystemType);\r\n                        return displayUnitSystem.units;\r\n                    }\r\n                    valueFormatter.getDisplayUnits = getDisplayUnits;\r\n                })(valueFormatter = formatting.valueFormatter || (formatting.valueFormatter = {}));\r\n            })(formatting = utils.formatting || (utils.formatting = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var visual;\r\n        (function (visual) {\r\n            var testcell1F3809C28F3FF40148F8285F9834834B5;\r\n            (function (testcell1F3809C28F3FF40148F8285F9834834B5) {\r\n                \"use strict\";\r\n                var DataViewObjectsParser = powerbi.extensibility.utils.dataview.DataViewObjectsParser;\r\n                var VisualSettings = (function (_super) {\r\n                    __extends(VisualSettings, _super);\r\n                    function VisualSettings() {\r\n                        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n                        _this.dataPoint = new dataPointSettings();\r\n                        return _this;\r\n                    }\r\n                    return VisualSettings;\r\n                }(DataViewObjectsParser));\r\n                testcell1F3809C28F3FF40148F8285F9834834B5.VisualSettings = VisualSettings;\r\n                var dataPointSettings = (function () {\r\n                    function dataPointSettings() {\r\n                        // Default color\r\n                        this.defaultColor = \"#333\";\r\n                        // Text Size\r\n                        this.fontSize = 12;\r\n                        this.alignment = \"left\";\r\n                        // Default HTMLTemplate\r\n                        this.htmlTemplate = \"%VALUE%\";\r\n                        // Default hotmat\r\n                        this.formatString = \"\";\r\n                        // Default culture\r\n                        this.formatCulture = \"\";\r\n                        this.forceThousandSeparatorCharacter = \"\";\r\n                    }\r\n                    return dataPointSettings;\r\n                }());\r\n                testcell1F3809C28F3FF40148F8285F9834834B5.dataPointSettings = dataPointSettings;\r\n            })(testcell1F3809C28F3FF40148F8285F9834834B5 = visual.testcell1F3809C28F3FF40148F8285F9834834B5 || (visual.testcell1F3809C28F3FF40148F8285F9834834B5 = {}));\r\n        })(visual = extensibility.visual || (extensibility.visual = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n// TODO: Use column formatting by default.\r\nvar valueFormatter = powerbi.extensibility.utils.formatting.valueFormatter;\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var visual;\r\n        (function (visual) {\r\n            var testcell1F3809C28F3FF40148F8285F9834834B5;\r\n            (function (testcell1F3809C28F3FF40148F8285F9834834B5) {\r\n                \"use strict\";\r\n                function visualTransform(options, host, thisRef) {\r\n                    var dataViews = options.dataViews;\r\n                    var viewModel = {\r\n                        dataPoints: []\r\n                    };\r\n                    var numberValue = null;\r\n                    var stringValue = \"\";\r\n                    if (dataViews && dataViews[0] && dataViews[0].categorical && dataViews[0].categorical.values && dataViews[0].categorical.values[0] && dataViews[0].categorical.values[0].values && dataViews[0].categorical.values[0].values[0]) {\r\n                        numberValue = dataViews[0].categorical.values[0].values[0];\r\n                    }\r\n                    if (dataViews && dataViews[0] && dataViews[0].categorical && dataViews[0].categorical.categories && dataViews[0].categorical.categories[0] && dataViews[0].categorical.categories[0].values && dataViews[0].categorical.categories[0].values[0]) {\r\n                        stringValue = dataViews[0].categorical.categories[0].values[0].toString();\r\n                    }\r\n                    if (stringValue === \"\" && numberValue === null) {\r\n                        return viewModel;\r\n                    }\r\n                    viewModel.dataPoints.push({\r\n                        numberValue: numberValue,\r\n                        stringValue: stringValue,\r\n                        selectionId: null\r\n                    });\r\n                    return viewModel;\r\n                }\r\n                var Visual = (function () {\r\n                    function Visual(options) {\r\n                        this.host = options.host;\r\n                        this.selectionManager = options.host.createSelectionManager();\r\n                        var div = this.div = document.createElement(\"div\");\r\n                        options.element.appendChild(div);\r\n                    }\r\n                    Visual.prototype.update = function (options) {\r\n                        this.settings = Visual.parseSettings(options && options.dataViews && options.dataViews[0]);\r\n                        this.model = visualTransform(options, this.host, this);\r\n                        var width = options.viewport.width;\r\n                        var height = options.viewport.height;\r\n                        this.div.style.width = width + \"px\";\r\n                        this.div.style.height = height + \"px\";\r\n                        this.div.style.fontSize = this.settings.dataPoint.fontSize + \"pt\";\r\n                        this.div.style.color = this.settings.dataPoint.defaultColor;\r\n                        this.div.style.textAlign = this.settings.dataPoint.alignment;\r\n                        var value = \"\";\r\n                        if (this.model.dataPoints.length === 0) {\r\n                            value = \"-\";\r\n                        }\r\n                        else {\r\n                            if (this.model.dataPoints[0].numberValue !== null) {\r\n                                // Number value\r\n                                var iValueFormatter = valueFormatter.create({ format: this.settings.dataPoint.formatString, cultureSelector: this.settings.dataPoint.formatCulture });\r\n                                if (this.settings.dataPoint.formatString === \"\") {\r\n                                    // Use standard formatting if nothing is specified\r\n                                    iValueFormatter = valueFormatter.create({ format: options.dataViews[0].metadata.columns[0].format });\r\n                                }\r\n                                var v1 = this.model.dataPoints[0].numberValue;\r\n                                value = iValueFormatter.format(v1);\r\n                                if (this.settings.dataPoint.forceThousandSeparatorCharacter.length > 0) {\r\n                                    value = value.replace(/,/g, this.settings.dataPoint.forceThousandSeparatorCharacter);\r\n                                }\r\n                            }\r\n                            else {\r\n                                // String value\r\n                                value = this.model.dataPoints[0].stringValue;\r\n                            }\r\n                        }\r\n                        this.div.innerHTML = this.settings.dataPoint.htmlTemplate.replace(\"%VALUE%\", value);\r\n                    };\r\n                    Visual.parseSettings = function (dataView) {\r\n                        return testcell1F3809C28F3FF40148F8285F9834834B5.VisualSettings.parse(dataView);\r\n                    };\r\n                    /**\r\n                     * This function gets called for each of the objects defined in the capabilities files and allows you to select which of the\r\n                     * objects and properties you want to expose to the users in the property pane.\r\n                     *\r\n                     */\r\n                    Visual.prototype.enumerateObjectInstances = function (options) {\r\n                        return testcell1F3809C28F3FF40148F8285F9834834B5.VisualSettings.enumerateObjectInstances(this.settings || testcell1F3809C28F3FF40148F8285F9834834B5.VisualSettings.getDefault(), options);\r\n                    };\r\n                    return Visual;\r\n                }());\r\n                testcell1F3809C28F3FF40148F8285F9834834B5.Visual = Visual;\r\n            })(testcell1F3809C28F3FF40148F8285F9834834B5 = visual.testcell1F3809C28F3FF40148F8285F9834834B5 || (visual.testcell1F3809C28F3FF40148F8285F9834834B5 = {}));\r\n        })(visual = extensibility.visual || (extensibility.visual = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var visual;\r\n        (function (visual) {\r\n            var testcell1F3809C28F3FF40148F8285F9834834B5;\r\n            (function (testcell1F3809C28F3FF40148F8285F9834834B5) {\r\n                \"use strict\";\r\n                var VisualViewModel = (function () {\r\n                    function VisualViewModel() {\r\n                    }\r\n                    return VisualViewModel;\r\n                }());\r\n                testcell1F3809C28F3FF40148F8285F9834834B5.VisualViewModel = VisualViewModel;\r\n                ;\r\n                var VisualDataPoint = (function () {\r\n                    function VisualDataPoint() {\r\n                    }\r\n                    return VisualDataPoint;\r\n                }());\r\n                testcell1F3809C28F3FF40148F8285F9834834B5.VisualDataPoint = VisualDataPoint;\r\n                ;\r\n            })(testcell1F3809C28F3FF40148F8285F9834834B5 = visual.testcell1F3809C28F3FF40148F8285F9834834B5 || (visual.testcell1F3809C28F3FF40148F8285F9834834B5 = {}));\r\n        })(visual = extensibility.visual || (extensibility.visual = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var visuals;\r\n    (function (visuals) {\r\n        var plugins;\r\n        (function (plugins) {\r\n            plugins.testcell1F3809C28F3FF40148F8285F9834834B5_DEBUG = {\r\n                name: 'testcell1F3809C28F3FF40148F8285F9834834B5_DEBUG',\r\n                displayName: 'testcell1',\r\n                class: 'Visual',\r\n                version: '1.0.0',\r\n                apiVersion: '1.11.0',\r\n                create: function (options) { return new powerbi.extensibility.visual.testcell1F3809C28F3FF40148F8285F9834834B5.Visual(options); },\r\n                custom: true\r\n            };\r\n        })(plugins = visuals.plugins || (visuals.plugins = {}));\r\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\r\n})(powerbi || (powerbi = {}));\r\n//# sourceMappingURL=visual.js.map","css":".visual-testcell1F3809C28F3FF40148F8285F9834834B5_DEBUG p {\n  font-size: 20px;\n  font-weight: bold;\n}\n.visual-testcell1F3809C28F3FF40148F8285F9834834B5_DEBUG p em {\n  background: yellow;\n  padding: 5px;\n}\n","iconBase64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2RpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpBOEJGMzkxN0NBRDNFMDExQTcxQ0JFODI3ODBCQUE5RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo3NEY1QjA1NUQ0OTAxMUUwQTgxREI2NjMxMkNEMUNEMyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo3NEY1QjA1NEQ0OTAxMUUwQTgxREI2NjMxMkNEMUNEMyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5Mjk5RDU1ODBGRDRFMDExQTcxQ0JFODI3ODBCQUE5RSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBOEJGMzkxN0NBRDNFMDExQTcxQ0JFODI3ODBCQUE5RSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PpDoNX0AAAI3SURBVHjarJRLSFVRFIY9t7SiRDGLoEEPCRJRaCSYkxCiFCXCF+LIMExQLkilgumgwkbdBuWDRC2EomhURCOjgagkXEgKLUKhidobM6H0+i34rxyPnuvEA5/rXPda/1l7739vJxKJxG3ls93+hEKhTILxJhgMftmsiPxdhHw4CfepeR8dCyjWwwB0kZy3iVgCoQ2ewnmXxhrBD7Cgr/ZQVA17fDRPw2UYhzK6G99IsBse6/0QNME+H8FT4EA/YiPqOgA1q4IMzBNuw6iKjkCpj+Av+AdnEEmD3bxfhzvuDk30HaEaLsEkXCO53rN+Bwg5qsvTuj/TjGYtx9nINhRmEx7AYWiFW7AXOuEcbPOUvIZ2mnrl+PkQUbNEh4QHNKUSDdsSBWEOlmxTEfvs26FL9Khe211if6Acgee+xo7xzMgBxfq9qPe3fgWBGN2lEnqtG9nExM7CV3jp3bDos2bKJB0nHFRxAxRpA/5CIXyHh5ABv6GZqd9dJ6iz2SjbxMMypGhJFtTlNzu3kK7xgDxpove8U66FK2A+s6nul5gVVMEL+Ak7lG/T+g9JcIOGar2CRUoogxMwpP/bLTJMB9bRhDbkk5bBUU0y3ES0xS04CBfN9RSHiY90vJK0BHaSzG9h2eejS3RJeVfdtrGzuGyd8CX7Yq6ExuCH63jaVMPkFOv6OibB6DKs2+VEQp+WYBoqERn2sVWWRNN0YurIfeL14U6YkpkLYCSG6e0yqdCxvKBLIm5FgAEAV0nKuwMYRUsAAAAASUVORK5CYII="}}